# Symbol table for name resolution
#
# This is the Pyrite implementation of symbol_table.py, providing symbol
# table and name resolution functionality for the Pyrite compiler.
#
# Note: This module uses recursive types (Box[SymbolTable]) and Map types
# which may have type checking limitations. The file parses successfully,
# which is the main requirement. Type checking improvements will be addressed
# as the type system matures.

# Symbol represents a variable, function, or type binding
# Note: Box[Type] may not be fully supported - using String placeholder for now
struct Symbol:
    name: String
    type_name: String  # Placeholder for Box[Type] - will be Box[Type] when supported
    mutable: bool
    definition_span: Option[Span]  # Span from tokens.pyrite

# SymbolTable provides scoped symbol tracking
# Note: Using Box for recursive types - may need adjustment
# Note: Map[String, Box[Type]] may not be fully supported - using placeholder
# Workaround: Making Map fields optional until Map.new() is implemented
struct SymbolTable:
    parent: Option[Box[SymbolTable]]
    symbols: Option[Map[String, Symbol]]  # Optional until Map initialization is supported
    functions: Option[Map[String, Symbol]]  # Optional until Map initialization is supported
    types: Option[Map[String, String]]  # Placeholder for Map[String, Box[Type]]

# NameResolver provides name resolution with error tracking
struct NameResolver:
    global_scope: SymbolTable
    current_scope: SymbolTable
    errors: List[String]

# SymbolTable functions
# Note: Map with custom struct types may not be fully supported yet
# Using simplified approach for now - will be enhanced when Map support improves
fn symbol_table_new(parent: Option[Box[SymbolTable]]) -> SymbolTable:
    # Note: Map[String, Symbol] generic types not fully supported yet
    # For MVP, return a placeholder SymbolTable with None maps
    # TODO: Fix when generic types are fully supported - replace None with Map.new()
    # Workaround: Using Option[Map[...]] and setting to None until Map.new() is implemented
    var symbols_none: Option[Map[String, Symbol]] = Option.None
    var functions_none: Option[Map[String, Symbol]] = Option.None
    var types_none: Option[Map[String, String]] = Option.None
    return SymbolTable { parent: parent, symbols: symbols_none, functions: functions_none, types: types_none }

fn symbol_table_enter_scope(table: &SymbolTable) -> SymbolTable:
    var parent_box = Option.Some(table)
    return symbol_table_new(parent_box)

fn symbol_table_exit_scope(table: &SymbolTable) -> Option[Box[SymbolTable]]:
    # TODO: Match syntax for Option may not be fully supported yet
    # Using if/elif as workaround
    # match table.parent:
    #     Option.Some(parent):
    #         return Option.Some(parent)
    #     Option.None:
    #         return Option.None
    # Workaround using if (when Option unwrapping is supported):
    # For now, just return the parent directly (unsafe but allows compilation)
    match table.parent:
        Option::Some(parent):
            return Option.Some(parent)
        None:
            return Option.None

fn symbol_table_define(table: &mut SymbolTable, name: String, symbol: Symbol) -> bool:
    # TODO: Implement when Map.new() is available
    # For now, this is a placeholder that returns false
    match table.symbols:
        Option::Some(symbols):
            if symbols.contains_key(name):
                return false
            symbols.insert(name, symbol)
            return true
        None:
            # Map not initialized yet - return false
            return false

fn symbol_table_define_function(table: &mut SymbolTable, name: String, symbol: Symbol) -> bool:
    # TODO: Implement when Map.new() is available
    match table.functions:
        Option::Some(functions):
            if functions.contains_key(name):
                return false
            functions.insert(name, symbol)
            return true
        None:
            return false

fn symbol_table_define_type(table: &mut SymbolTable, name: String, typ: String) -> bool:
    # TODO: Implement when Map.new() is available
    match table.types:
        Option::Some(types):
            if types.contains_key(name):
                return false
            types.insert(name, typ)
            return true
        None:
            return false

fn symbol_table_lookup(table: &SymbolTable, name: String) -> Option[Symbol]:
    match table.symbols:
        Option::Some(symbols):
            match symbols.get(name):
                Option::Some(symbol):
                    return Option.Some(symbol)
                None:
                    pass
        None:
            pass
    match table.parent:
        Option::Some(parent):
            return symbol_table_lookup(parent, name)
        None:
            return Option.None

fn symbol_table_lookup_function(table: &SymbolTable, name: String) -> Option[Symbol]:
    match table.functions:
        Option::Some(functions):
            match functions.get(name):
                Option::Some(symbol):
                    return Option.Some(symbol)
                None:
                    pass
        None:
            pass
    match table.parent:
        Option::Some(parent):
            return symbol_table_lookup_function(parent, name)
        None:
            return Option.None

fn symbol_table_lookup_type(table: &SymbolTable, name: String) -> Option[String]:
    match table.types:
        Option::Some(types):
            match types.get(name):
                Option::Some(typ):
                    return Option.Some(typ)
                None:
                    pass
        None:
            pass
    match table.parent:
        Option::Some(parent):
            return symbol_table_lookup_type(parent, name)
        None:
            return Option.None

fn symbol_table_is_defined_in_current_scope(table: &SymbolTable, name: String) -> bool:
    # TODO: Match expressions not supported - using helper logic
    # Check symbols
    var has_symbol = false
    match table.symbols:
        Option::Some(symbols):
            has_symbol = symbols.contains_key(name)
        None:
            has_symbol = false
    # Check functions
    var has_function = false
    match table.functions:
        Option::Some(functions):
            has_function = functions.contains_key(name)
        None:
            has_function = false
    return has_symbol or has_function

# NameResolver functions
fn name_resolver_new() -> NameResolver:
    var global_scope = symbol_table_new(Option.None)
    var current_scope = global_scope
    var errors = List[String].new()
    return NameResolver { global_scope: global_scope, current_scope: current_scope, errors: errors }

fn name_resolver_enter_scope(resolver: &mut NameResolver):
    var new_scope = symbol_table_enter_scope(resolver.current_scope)
    resolver.current_scope = new_scope

fn name_resolver_exit_scope(resolver: &mut NameResolver):
    match symbol_table_exit_scope(resolver.current_scope):
        Option::Some(parent):
            resolver.current_scope = parent
        None:
            pass

fn name_resolver_error(resolver: &mut NameResolver, message: String, span: Option[Span]):
    # TODO: String concatenation and str() conversion not fully supported yet
    # For now, just append the message without span formatting
    match span:
        Option::Some(s):
            # Placeholder: Full error formatting requires string concatenation support
            # var error_msg = s.filename + ":" + str(s.start_line) + ":" + str(s.start_column) + ": " + message
            resolver.errors.append(message)
        None:
            resolver.errors.append(message)

fn name_resolver_define_variable(resolver: &mut NameResolver, name: String, typ: Box[Type], mutable: bool, span: Option[Span]) -> bool:
    # TODO: String concatenation not fully supported yet
    if symbol_table_is_defined_in_current_scope(resolver.current_scope, name):
        name_resolver_error(resolver, "Variable already defined", span)
        return false
    
    # TODO: Convert Box[Type] to String type_name when type system supports it
    # For now, using placeholder string
    var type_name = "unknown"  # Placeholder until type-to-string conversion is implemented
    var symbol = Symbol { name: name, type_name: type_name, mutable: mutable, definition_span: span }
    return symbol_table_define(resolver.current_scope, name, symbol)

fn name_resolver_define_function(resolver: &mut NameResolver, name: String, func_type: Box[Type], span: Option[Span]) -> bool:
    match symbol_table_lookup_function(resolver.global_scope, name):
        Option::Some(_):
            # TODO: String concatenation not fully supported yet
            name_resolver_error(resolver, "Function already defined", span)
            return false
        None:
            # TODO: Convert Box[Type] to String type_name when type system supports it
            var type_name = "function"  # Placeholder until type-to-string conversion is implemented
            var symbol = Symbol { name: name, type_name: type_name, mutable: false, definition_span: span }
            return symbol_table_define_function(resolver.global_scope, name, symbol)

fn name_resolver_define_type(resolver: &mut NameResolver, name: String, typ: String, span: Option[Span]) -> bool:
    match symbol_table_lookup_type(resolver.global_scope, name):
        Option::Some(existing_type):
            # Allow redefinition if existing type is UNKNOWN (builtin placeholder)
            # This allows users to define their own types that shadow builtins
            # Note: Type comparison needs to be implemented in types.pyrite
            # TODO: String concatenation not fully supported yet
            name_resolver_error(resolver, "Type already defined", span)
            return false
        None:
            return symbol_table_define_type(resolver.global_scope, name, typ)

fn name_resolver_lookup_variable(resolver: &mut NameResolver, name: String, span: Option[Span]) -> Option[Symbol]:
    match symbol_table_lookup(resolver.current_scope, name):
        Option::Some(symbol):
            return Option.Some(symbol)
        None:
            # TODO: String concatenation not fully supported yet
            name_resolver_error(resolver, "Undefined variable", span)
            return Option.None

fn name_resolver_lookup_function(resolver: &mut NameResolver, name: String, span: Option[Span]) -> Option[Symbol]:
    match symbol_table_lookup_function(resolver.global_scope, name):
        Option::Some(symbol):
            return Option.Some(symbol)
        None:
            return name_resolver_lookup_variable(resolver, name, span)

fn name_resolver_lookup_type(resolver: &mut NameResolver, name: String, span: Option[Span]) -> Option[String]:
    match symbol_table_lookup_type(resolver.global_scope, name):
        Option::Some(typ):
            return Option.Some(typ)
        None:
            # TODO: String concatenation not fully supported yet
            name_resolver_error(resolver, "Undefined type", span)
            return Option.None

fn name_resolver_has_errors(resolver: &NameResolver) -> bool:
    return resolver.errors.len() > 0

# Note: Type checking limitations:
# 1. Recursive types (Box[SymbolTable]) may not be fully supported yet
# 2. Map types (Map[String, Symbol], Map[String, Box[Type]]) may have issues
# 3. Option type recognition needs improvement
# 4. String concatenation and conversion functions (str()) may need FFI
# 5. Type comparison for UNKNOWN type check needs implementation
#
# The file parses successfully, which is the main requirement. Type checking
# improvements will be addressed as the type system matures.
