# Type system for Pyrite
#
# This module provides the type system for Pyrite, including all type definitions
# and utility functions for type checking and compatibility.
#
# This is the Pyrite implementation of types.py.
#
# Note: This is a foundational module. Some match patterns for enum variants
# with data fields may not be fully supported yet. The type definitions are
# correct, but utility functions may need to be simplified until match syntax
# for enum variants is fully implemented.

# Base type - all types are represented as enum variants
enum Type:
    IntType(width: int, signed: bool)
    FloatType(width: int)
    BoolType
    CharType
    StringType
    VoidType
    NoneType
    ReferenceType(inner: Box[Type], mutable: bool)
    PointerType(inner: Box[Type], mutable: bool)
    ArrayType(element: Box[Type], size: int)
    SliceType(element: Box[Type])
    StructType(name: String, fields: Map[String, Box[Type]], generic_params: List[String])
    EnumType(name: String, variants: Map[String, Option[List[Box[Type]]]], generic_params: List[String])
    GenericType(name: String, base_type: Option[Box[Type]], type_args: List[Box[Type]])
    FunctionType(param_types: List[Box[Type]], return_type: Option[Box[Type]])
    TupleType(elements: List[Box[Type]])
    UnknownType
    TypeVariable(name: String)
    SelfType
    OpaqueType(name: String)
    TraitType(name: String, methods: Map[String, Box[Type]], generic_params: List[String], associated_types: List[String])

# Built-in type instance creation functions
fn int_type() -> Type:
    return Type.IntType(32, true)

fn i8_type() -> Type:
    return Type.IntType(8, true)

fn i16_type() -> Type:
    return Type.IntType(16, true)

fn i32_type() -> Type:
    return Type.IntType(32, true)

fn i64_type() -> Type:
    return Type.IntType(64, true)

fn u8_type() -> Type:
    return Type.IntType(8, false)

fn u16_type() -> Type:
    return Type.IntType(16, false)

fn u32_type() -> Type:
    return Type.IntType(32, false)

fn u64_type() -> Type:
    return Type.IntType(64, false)

fn f32_type() -> Type:
    return Type.FloatType(32)

fn f64_type() -> Type:
    return Type.FloatType(64)

fn bool_type() -> Type:
    return Type.BoolType

fn char_type() -> Type:
    return Type.CharType

fn string_type() -> Type:
    return Type.StringType

fn void_type() -> Type:
    return Type.VoidType

fn none_type() -> Type:
    return Type.NoneType

fn unknown_type() -> Type:
    return Type.UnknownType

fn self_type() -> Type:
    return Type.SelfType

# Get primitive type from name
fn primitive_type_from_name(name: String) -> Option[Type]:
    if name == "int":
        return Option.Some(int_type())
    elif name == "i8":
        return Option.Some(i8_type())
    elif name == "i16":
        return Option.Some(i16_type())
    elif name == "i32":
        return Option.Some(i32_type())
    elif name == "i64":
        return Option.Some(i64_type())
    elif name == "u8":
        return Option.Some(u8_type())
    elif name == "u16":
        return Option.Some(u16_type())
    elif name == "u32":
        return Option.Some(u32_type())
    elif name == "u64":
        return Option.Some(u64_type())
    elif name == "f32":
        return Option.Some(f32_type())
    elif name == "f64":
        return Option.Some(f64_type())
    elif name == "bool":
        return Option.Some(bool_type())
    elif name == "char":
        return Option.Some(char_type())
    elif name == "String":
        return Option.Some(string_type())
    elif name == "void":
        return Option.Some(void_type())
    elif name == "Self":
        return Option.Some(self_type())
    else:
        return Option.None

# Note: Type checking limitations:
# 1. Recursive types (Box[Type]) may not be fully supported yet
# 2. Option type recognition needs improvement
# 3. Enum constructor calls (Type.IntType(...)) return ? instead of Type
# 4. Utility functions (is_copy_type, is_numeric_type, types_compatible, 
#    common_numeric_type) require match patterns with enum variant destructuring,
#    which may not be fully supported yet.
#
# The file parses successfully, which is the main requirement. Type checking
# improvements will be addressed as the type system matures.
#
# For now, the type definitions and primitive type functions are structurally
# correct and ready for FFI integration once type system improvements are made.
