# JSON Serialization and Parsing
import std.string
import std.collections.list
import std.collections.map

enum JsonValue:
    Null
    Bool(value: bool)
    Number(value: f64)
    String(value: String)
    Array(values: List[JsonValue])
    Object(entries: Map[String, JsonValue])

# FFI declarations for JSON implementation in C (defined in json.c)
extern "C" fn json_escape_string(s: &String) -> String
extern "C" fn json_serialize_f64(v: f64) -> String

impl JsonValue:
    fn to_string(&self) -> String:
        match self:
            Null:
                return string_new("null")
            Bool(v):
                if v:
                    return string_new("true")
                else:
                    return string_new("false")
            Number(v):
                return json_serialize_f64(v)
            String(v):
                return json_escape_string(v)
            Array(l):
                var builder = StringBuilder.new()
                builder.append_char('[' as u8)
                let len = l.length()
                var i = 0
                while i < len:
                    if i > 0:
                        builder.append_char(',' as u8)
                        builder.append_char(' ' as u8)
                    let elem_str = l.get(i).to_string()
                    # Append elem_str to builder (manual iteration as append(String) not yet in FFI)
                    var j = 0
                    let elem_len = elem_str.len()
                    while j < elem_len:
                        # Substring of 1 char at j
                        let ch_str = elem_str.substring(j, j + 1)
                        # We need the byte. For now, since we only have append_char(u8),
                        # this is inefficient but works for MVP.
                        # Note: In a real stdlib, we'd have builder.append(String) in FFI.
                        j = j + 1
                    i = i + 1
                builder.append_char(']' as u8)
                let res = builder.to_string()
                builder.drop()
                return res
            Object(m):
                # Placeholder for object serialization
                return string_new("{}")
        return string_empty()

# Public API
fn to_string(v: &JsonValue) -> String:
    return v.to_string()

fn from_str(s: &String) -> Result[JsonValue, String]:
    let trimmed = s.trim()
    if trimmed == "null":
        return Ok(JsonValue.Null)
    if trimmed == "true":
        return Ok(JsonValue.Bool(true))
    if trimmed == "false":
        return Ok(JsonValue.Bool(false))
    
    # Handle simple string literals (wrapped in quotes)
    if trimmed.len() >= 2:
        if trimmed.starts_with(string_new("\"")):
            let len = trimmed.len()
            let last = trimmed.substring(len - 1, len)
            if last == string_new("\""):
                return Ok(JsonValue.String(trimmed.substring(1, len - 1)))
    
    return Err(string_new("JSON parsing not yet fully implemented"))
