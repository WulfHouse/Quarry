# TOML Serialization and Parsing
import std.string
import std.collections.list
import std.collections.map

enum TomlValue:
    String(value: String)
    Integer(value: i64)
    Float(value: f64)
    Boolean(value: bool)
    Array(values: List[TomlValue])
    Table(entries: Map[String, TomlValue])

impl TomlValue:
    fn to_string(&self) -> String:
        match self:
            String(v):
                # Basic TOML string: "value"
                return v # Simplified
            Integer(v):
                return string_from_int(v)
            Float(v):
                return string_from_float(v)
            Boolean(v):
                if v:
                    return string_new("true")
                else:
                    return string_new("false")
            Array(l):
                var builder = StringBuilder.new()
                builder.append_char('[' as u8)
                let len = l.length()
                var i = 0
                while i < len:
                    if i > 0:
                        builder.append_char(',' as u8)
                        builder.append_char(' ' as u8)
                    let elem_str = l.get(i).to_string()
                    # Append elem_str manually
                    i = i + 1
                builder.append_char(']' as u8)
                let res = builder.to_string()
                builder.drop()
                return res
            Table(m):
                return string_new("[table]")
        return string_empty()

# Public API
fn to_string(v: &TomlValue) -> String:
    return v.to_string()

fn from_str(s: &String) -> Result[TomlValue, String]:
    let trimmed = s.trim()
    
    # Boolean values
    if trimmed == "true":
        return Ok(TomlValue.Boolean(true))
    if trimmed == "false":
        return Ok(TomlValue.Boolean(false))
    
    # String values (quoted)
    if trimmed.len() >= 2:
        if trimmed.starts_with(string_new("\"")):
            let len = trimmed.len()
            let last = trimmed.substring(len - 1, len)
            if last == string_new("\""):
                return Ok(TomlValue.String(trimmed.substring(1, len - 1)))
    
    # Integer values (simplified - assumes no leading/trailing whitespace)
    # Try parsing as integer
    var is_int = true
    var i = 0
    while i < trimmed.len():
        let ch = trimmed.substring(i, i + 1)
        if ch != string_new("0") and ch != string_new("1") and ch != string_new("2") and ch != string_new("3") and ch != string_new("4") and ch != string_new("5") and ch != string_new("6") and ch != string_new("7") and ch != string_new("8") and ch != string_new("9") and ch != string_new("-") and ch != string_new("+"):
            is_int = false
            break
        i = i + 1
    
    if is_int and trimmed.len() > 0:
        # For MVP, return as string - full implementation would parse to i64
        # This is a simplified version that at least recognizes integers
        return Ok(TomlValue.Integer(0))  # Placeholder - full impl would parse actual value
    
    # Float values (simplified - assumes decimal point)
    var has_dot = false
    i = 0
    while i < trimmed.len():
        let ch = trimmed.substring(i, i + 1)
        if ch == string_new("."):
            has_dot = true
            break
        i = i + 1
    
    if has_dot:
        # For MVP, return as float - full implementation would parse to f64
        return Ok(TomlValue.Float(0.0))  # Placeholder - full impl would parse actual value
    
    # Array values: [value1, value2, ...]
    if trimmed.starts_with(string_new("[")):
        let len = trimmed.len()
        if len >= 2 and trimmed.substring(len - 1, len) == string_new("]"):
            # Empty array
            if len == 2:
                return Ok(TomlValue.Array(List.new()))
            
            # Parse array elements (simplified)
            var elements = List.new()
            var i = 1  # Skip opening '['
            var start = i
            while i < len - 1:  # Stop before closing ']'
                let ch = trimmed.substring(i, i + 1)
                if ch == string_new(",") or (i == len - 2):
                    var end_idx = i
                    if ch == string_new(","):
                        end_idx = i
                    else:
                        end_idx = i + 1
                    
                    if end_idx > start:
                        let elem_str = trimmed.substring(start, end_idx).trim()
                        # Recursively parse element
                        match from_str(elem_str):
                            Ok(val):
                                elements.append(val)
                            Err(e):
                                return Err(e)
                    
                    start = i + 1
                i = i + 1
            
            return Ok(TomlValue.Array(elements))
    
    # Table values: key = value (simplified - single line tables)
    # For MVP, we'll parse simple key = value pairs
    var eq_pos = -1
    i = 0
    while i < trimmed.len():
        let ch = trimmed.substring(i, i + 1)
        if ch == string_new("="):
            eq_pos = i
            break
        i = i + 1
    
    if eq_pos >= 0:
        let key_str = trimmed.substring(0, eq_pos).trim()
        let value_str = trimmed.substring(eq_pos + 1, trimmed.len()).trim()
        
        # Parse value
        match from_str(value_str):
            Ok(val):
                var entries = Map.new()
                entries.set(key_str, val)
                return Ok(TomlValue.Table(entries))
            Err(e):
                return Err(e)
    
    return Err(string_new("TOML parsing not yet fully implemented for this format"))
