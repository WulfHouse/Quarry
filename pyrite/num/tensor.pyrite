# Numerics and Tensors

struct Tensor:
    data: *mut f64
    rows: i64
    cols: i64

extern "C" fn tensor_new(rows: i64, cols: i64) -> Tensor
extern "C" fn tensor_get(t: *const Tensor, r: i64, c: i64) -> f64
extern "C" fn tensor_set(t: *mut Tensor, r: i64, c: i64, val: f64)
extern "C" fn tensor_drop(t: *mut Tensor)

impl Tensor:
    # Creates a new tensor. May return an uninitialized tensor (data == null) on allocation failure.
    # For explicit error handling, use try_new() instead.
    fn new(rows: i64, cols: i64) -> Tensor:
        return tensor_new(rows, cols)
    
    # Creates a new tensor with explicit error handling.
    # Returns Ok(tensor) on success, Err("Allocation failed") if memory allocation fails.
    fn try_new(rows: i64, cols: i64) -> Result[Tensor, String]:
        let t = tensor_new(rows, cols)
        if t.data == 0 as *mut f64:
            return Err("Allocation failed")
        return Ok(t)
    
    fn get(&self, r: i64, c: i64) -> f64:
        # Safety: This FFI call dereferences raw pointers. The caller must ensure:
        # 1. The tensor is initialized (data pointer is valid)
        # 2. The indices are in bounds (0 <= r < rows, 0 <= c < cols)
        # 3. The pointer passed to tensor_get is valid
        unsafe:
            return tensor_get(self, r, c)
    
    fn set(&mut self, r: i64, c: i64, val: f64):
        # Safety: This FFI call dereferences raw pointers. The caller must ensure:
        # 1. The tensor is initialized (data pointer is valid)
        # 2. The indices are in bounds (0 <= r < rows, 0 <= c < cols)
        # 3. The pointer passed to tensor_set is valid
        unsafe:
            tensor_set(self, r, c, val)
    
    fn drop(&mut self):
        tensor_drop(self)
