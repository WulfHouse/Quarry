# TCP Networking
import std.string

struct TcpStream:
    handle: i64

struct TcpListener:
    handle: i64

extern "C" fn net_init() -> i32
extern "C" fn tcp_connect(addr: *const u8, port: i32) -> i64
extern "C" fn tcp_send(sock: i64, data: *const u8, len: i64) -> i32
extern "C" fn tcp_recv(sock: i64, buf: *mut u8, len: i64) -> i32
extern "C" fn tcp_close(sock: i64)
extern "C" fn tcp_listen(addr: *const u8, port: i32) -> i64
extern "C" fn tcp_accept(sock: i64) -> i64

impl TcpStream:
    fn connect(address: &String, port: i32) -> Result[TcpStream, String]:
        let init_result = net_init()
        if init_result != 0:
            return Err(string_new("Network initialization failed"))
        
        let handle = tcp_connect(address.data, port)
        if handle < 0:
            return Err(string_new("Failed to connect"))
        
        return Ok(TcpStream { handle: handle })
    
    fn send(&mut self, data: &String) -> i32:
        return tcp_send(self.handle, data.data, data.len())
    
    fn recv(&mut self, buf: &mut [u8]) -> i32:
        return tcp_recv(self.handle, buf.data, buf.len() as i64)
    
    fn close(&mut self):
        tcp_close(self.handle)

impl TcpListener:
    fn bind(address: &String, port: i32) -> Result[TcpListener, String]:
        let init_result = net_init()
        if init_result != 0:
            return Err(string_new("Network initialization failed"))
            
        let handle = tcp_listen(address.data, port)
        if handle < 0:
            return Err(string_new("Failed to bind to address"))
            
        return Ok(TcpListener { handle: handle })
        
    fn accept(&self) -> Result[TcpStream, String]:
        let client_handle = tcp_accept(self.handle)
        if client_handle < 0:
            return Err(string_new("Failed to accept connection"))
            
        return Ok(TcpStream { handle: client_handle })
        
    fn close(&mut self):
        tcp_close(self.handle)
