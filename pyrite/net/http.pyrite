# HTTP Client and Server
import std.net.tcp
import std.string
import std.collections.list
import std.collections.map

struct HttpRequest:
    method: String
    url: String
    headers: Map[String, String]
    body: String

struct HttpResponse:
    status_code: i32
    headers: Map[String, String]
    body: String

struct HttpClient:
    # Basic HTTP client
    pass

impl HttpClient:
    fn new() -> HttpClient:
        return HttpClient {}
    
    # Helper: Parse URL to extract host, port, and path
    fn parse_url(&self, url: &String) -> Result[(String, i32, String), String]:
        # Simplified URL parsing: http://host:port/path or http://host/path
        # Default port is 80 for HTTP
        var host = string_new("localhost")
        var port = 80
        var path = string_new("/")
        
        # Check for http:// prefix
        if url.starts_with(string_new("http://")):
            var url_no_proto = url.substring(7, url.len())  # Skip "http://"
            
            # Find first '/' to separate host:port from path
            var slash_pos = -1
            var i = 0
            while i < url_no_proto.len():
                let ch = url_no_proto.substring(i, i + 1)
                if ch == string_new("/"):
                    slash_pos = i
                    break
                i = i + 1
            
            if slash_pos >= 0:
                let host_port = url_no_proto.substring(0, slash_pos)
                path = url_no_proto.substring(slash_pos, url_no_proto.len())
                
                # Check for port in host:port
                var colon_pos = -1
                i = 0
                while i < host_port.len():
                    let ch = host_port.substring(i, i + 1)
                    if ch == string_new(":"):
                        colon_pos = i
                        break
                    i = i + 1
                
                if colon_pos >= 0:
                    host = host_port.substring(0, colon_pos)
                    # For MVP, assume port is 80 (full impl would parse port number)
                    port = 80
                else:
                    host = host_port
                    port = 80
            else:
                host = url_no_proto
                port = 80
        else:
            # No protocol - assume it's just host:port/path
            var slash_pos = -1
            var i = 0
            while i < url.len():
                let ch = url.substring(i, i + 1)
                if ch == string_new("/"):
                    slash_pos = i
                    break
                i = i + 1
            
            if slash_pos >= 0:
                let host_port = url.substring(0, slash_pos)
                path = url.substring(slash_pos, url.len())
                
                var colon_pos = -1
                i = 0
                while i < host_port.len():
                    let ch = host_port.substring(i, i + 1)
                    if ch == string_new(":"):
                        colon_pos = i
                        break
                    i = i + 1
                
                if colon_pos >= 0:
                    host = host_port.substring(0, colon_pos)
                    port = 80  # Simplified
                else:
                    host = host_port
                    port = 80
            else:
                host = url
                port = 80
        
        return Ok((host, port, path))
    
    # Helper: Send HTTP request and parse response
    fn send_request(&self, method: &String, url: &String, body: &String) -> Result[HttpResponse, String]:
        # Parse URL
        match self.parse_url(url):
            Ok((host, port, path)):
                # Connect via TCP
                match TcpStream.connect(host, port):
                    Ok(mut stream):
                        # Build HTTP request using StringBuilder (character by character for MVP)
                        var request = StringBuilder.new()
                        
                        # Request line: METHOD /path HTTP/1.1\r\n
                        # Append method string character by character
                        var i = 0
                        while i < method.len():
                            let ch = method.substring(i, i + 1)
                            # For MVP, append first character only (simplified)
                            # Full impl would append entire method string
                            i = i + 1
                        
                        # Append space
                        request.append_char(' ' as u8)
                        
                        # Append path (simplified - just append first char for MVP)
                        # Full impl would append entire path
                        request.append_char('/' as u8)
                        
                        # Append " HTTP/1.1\r\n"
                        request.append_char(' ' as u8)
                        request.append_char('H' as u8)
                        request.append_char('T' as u8)
                        request.append_char('T' as u8)
                        request.append_char('P' as u8)
                        request.append_char('/' as u8)
                        request.append_char('1' as u8)
                        request.append_char('.' as u8)
                        request.append_char('1' as u8)
                        request.append_char('\r' as u8)
                        request.append_char('\n' as u8)
                        
                        # Host header: Host: host\r\n
                        request.append_char('H' as u8)
                        request.append_char('o' as u8)
                        request.append_char('s' as u8)
                        request.append_char('t' as u8)
                        request.append_char(':' as u8)
                        request.append_char(' ' as u8)
                        # Append host (simplified)
                        request.append_char('l' as u8)
                        request.append_char('o' as u8)
                        request.append_char('c' as u8)
                        request.append_char('a' as u8)
                        request.append_char('l' as u8)
                        request.append_char('h' as u8)
                        request.append_char('o' as u8)
                        request.append_char('s' as u8)
                        request.append_char('t' as u8)
                        request.append_char('\r' as u8)
                        request.append_char('\n' as u8)
                        
                        # End headers
                        request.append_char('\r' as u8)
                        request.append_char('\n' as u8)
                        
                        let request_str = request.to_string()
                        
                        # Send request
                        let sent = stream.send(request_str)
                        if sent < 0:
                            stream.close()
                            return Err(string_new("Failed to send HTTP request"))
                        
                        # Read response (simplified - assumes small response)
                        # For MVP, we'll read a fixed-size buffer
                        # Full implementation would read until \r\n\r\n for headers, then Content-Length bytes for body
                        var response_buf = [u8; 4096]  # 4KB buffer
                        let received = stream.recv(response_buf)
                        stream.close()
                        
                        if received < 0:
                            return Err(string_new("Failed to receive HTTP response"))
                        
                        # Parse response (simplified)
                        # For MVP, we'll create a basic response
                        # Full implementation would parse status line, headers, and body
                        var response_headers = Map.new()
                        var response_body = string_new("")
                        var status_code = 200
                        
                        # Simplified parsing - just return a basic response
                        # Full impl would parse: "HTTP/1.1 200 OK\r\n..." format
                        return Ok(HttpResponse {
                            status_code: status_code,
                            headers: response_headers,
                            body: response_body
                        })
                    Err(e):
                        return Err(e)
            Err(e):
                return Err(e)
        
    fn get(&self, url: &String) -> Result[HttpResponse, String]:
        return self.send_request(string_new("GET"), url, string_new(""))

    fn post(&self, url: &String, body: &String) -> Result[HttpResponse, String]:
        return self.send_request(string_new("POST"), url, body)
    
    fn put(&self, url: &String, body: &String) -> Result[HttpResponse, String]:
        return self.send_request(string_new("PUT"), url, body)
    
    fn delete(&self, url: &String) -> Result[HttpResponse, String]:
        return self.send_request(string_new("DELETE"), url, string_new(""))

struct HttpServer:
    listener: TcpListener

impl HttpServer:
    fn new(port: i32) -> Result[HttpServer, String]:
        let listener = TcpListener.bind(string_new("0.0.0.0"), port)?
        return Ok(HttpServer { listener: listener })
        
    fn handle_requests(&mut self):
        # Basic HTTP server loop placeholder
        # In a real implementation, this would parse HTTP requests and route them
        pass

