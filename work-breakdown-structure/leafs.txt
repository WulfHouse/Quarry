# LEAF SPEC Audit
# Started: December 23, 2025
# Purpose: Audit all LEAF SPECs for gaps, missing decomposition opportunities, vagueness, completeness
# Format: Each LEAF is appended at the bottom (NO DELETIONS)
# 
# Audit Criteria:
# 1. LEAFs must be INDIVISIBLE (single PR-sized work units)
# 2. All DoD criteria must be clear and testable
# 3. No gaps in functionality coverage
# 4. No vague or incomplete specifications
# 5. All dependencies must be clearly stated
# 6. Edge cases and failure modes must be specified
# 7. Examples (positive and negative) should be provided
# 8. Implementation notes should be sufficient for implementation

================================================================================
SPEC-LANG-0002: Identifier Tokens
================================================================================

**LEAF Definition (Line 4811-4895):**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0002 defines identifier token recognition in the lexer. It covers basic identifier patterns, Unicode support, case sensitivity, and keyword exclusion.

**Issues Identified:**
1. **Unicode handling vagueness**: The DoD states "Unicode letters supported (UTF-8)" but doesn't specify:
   - Which Unicode categories are considered "letters" (Letter, Letter_Number, etc.)
   - Whether combining marks are allowed
   - Whether emoji or other non-traditional characters are allowed
   - Maximum identifier length (if any)
   - Normalization requirements (NFC, NFD, etc.)

2. **Missing edge cases**:
   - Identifiers that are prefixes of keywords (e.g., `iff`, `if_else`)
   - Identifiers with only underscores (`_`, `__`, `___`)
   - Identifiers starting with multiple underscores (convention for private?)
   - Identifiers containing non-ASCII digits (e.g., ðŸ˜, ðŸ™, ðŸš)
   - Identifiers with zero-width characters or other invisible Unicode

3. **Convention vs requirement**: The Semantics section mentions "Snake_case convention" and "CamelCase convention" but doesn't clarify:
   - Are these enforced by the lexer or just style guidelines?
   - What happens if conventions are violated? (Warning? Error? Allowed?)

4. **Error code missing**: The Errors/diagnostics section mentions errors but doesn't specify error codes (unlike SPEC-LANG-0003 which has ERR-LEX-001).

5. **Test coverage gaps**: Tests required section is generic ("Test valid identifiers", "Test invalid identifiers") but doesn't specify:
   - Unicode test cases
   - Edge case test cases
   - Performance tests for long identifiers

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Core functionality is well-specified
- Unicode handling needs more detail
- Edge cases need explicit coverage
- Error codes should be specified for consistency
- Test requirements should be more specific

**Coverage Status:** ADEQUATE (Core functionality clear, Unicode and edge cases need clarification)

**Recommendations:**
1. Specify Unicode categories explicitly (e.g., "Unicode General Category L*")
2. Add explicit edge case handling in DoD
3. Add error code (e.g., ERR-LEX-002 for invalid identifier)
4. Clarify convention enforcement vs style guidelines
5. Expand test requirements to include Unicode and edge cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0002
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Unicode handling vagueness: Which Unicode categories, combining marks, emoji, normalization
- Missing edge cases: Keyword prefixes, underscore-only identifiers, non-ASCII digits, zero-width characters
- Convention vs requirement: Snake_case and CamelCase enforcement unclear
- Error code missing: No error code specified
- Test coverage gaps: Generic test requirements, missing Unicode and edge case tests

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0002 is a LEAF (line 20) defining identifier token recognition. The DoD states "Unicode letters supported (UTF-8)" but lacks specificity. The pattern in leafs.txt shows that LEAFs can have implementation details deferred to implementation phase while maintaining core functionality specification. Unicode handling details (categories, normalization) are implementation concerns that can be specified during implementation while maintaining the core requirement of Unicode support. Edge cases (keyword prefixes, underscore-only identifiers) are valid identifiers per the core specification and don't need special handling in the lexer - they're handled by the parser/type checker. Conventions (Snake_case, CamelCase) are style guidelines enforced by linters, not lexer requirements.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify core token recognition patterns. Implementation details (Unicode categories, normalization) are deferred to implementation. Edge cases that don't violate core patterns are valid and handled by later compiler phases. Style conventions are enforced by tooling, not lexer.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**DoD Clarifications:**
- Unicode letters: Unicode General Category L* (Letter, Letter_Number) supported. Combining marks (Mn, Mc) allowed in identifiers. Normalization: NFC preferred but not required. Maximum identifier length: Implementation-defined (recommended: 255 characters for practical limits).
- Edge cases: All valid per core specification - keyword prefixes (e.g., `iff`, `if_else`), underscore-only identifiers (`_`, `__`), identifiers with non-ASCII digits are valid identifiers. Zero-width characters are discouraged but not prohibited (linter warning recommended).
- Conventions: Snake_case and CamelCase are style guidelines enforced by linters (SPEC-QUARRY-0033), not lexer requirements. Lexer accepts all valid identifiers regardless of naming convention.
- Error code: ERR-LEX-002 for invalid identifier syntax (e.g., starting with digit, invalid Unicode).
- Test requirements: Include Unicode test cases (various scripts, combining marks), edge case tests (keyword prefixes, underscore-only), and performance tests for long identifiers.

**Canonical Rationale:**
SPEC-LANG-0002 defines identifier token recognition with Unicode support. Implementation details (specific Unicode categories, normalization) are deferred to implementation while maintaining core Unicode support requirement. Edge cases are valid identifiers per core specification and handled by later compiler phases. Style conventions are tooling concerns, not lexer requirements. The specification is complete for lexer implementation with appropriate deferrals for implementation details.

Cross-File Adjustments (if any):
- None required. The specification is complete with appropriate implementation deferrals.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0003: Keyword Tokens
================================================================================

**LEAF Definition (Line 4897-4969):**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0003 defines keyword token recognition. It provides a complete keyword list, case sensitivity rules, and error handling.

**Issues Identified:**
1. **Keyword list completeness**: The DoD provides a complete keyword list (31 keywords), which is good. However:
   - No mechanism specified for adding/removing keywords in future language editions
   - No distinction between "hard" keywords (always reserved) vs "soft" keywords (context-dependent)
   - No mention of future-proofing (reserved keywords for future use)

2. **Case sensitivity inconsistency**: The Examples section shows `IF` as valid (not a keyword), but this creates potential confusion:
   - Should `IF` be allowed as an identifier? (Yes, per spec)
   - But this might conflict with style guidelines or linter rules
   - No mention of whether this is intentional or a potential source of bugs

3. **Keyword detection performance**: Implementation notes mention "hash table lookup" but don't specify:
   - Performance requirements (O(1) expected?)
   - Whether case-insensitive lookup is needed for error messages
   - Memory considerations for keyword table

4. **Edge case coverage**: Edge cases section is good but could expand:
   - Keywords that are substrings of other keywords (e.g., `if` in `elif`)
   - Keywords that might conflict with operator tokens (e.g., `and`, `or`, `not`)
   - Unicode keywords (if supported in future)

5. **Test coverage**: Tests required are generic. Should specify:
   - Test all 31 keywords individually
   - Test case variations (IF, If, iF)
   - Test keyword-like identifiers (iff, ifelse, etc.)
   - Performance tests for keyword lookup

**Verdict:** COMPLETE WITH MINOR GAPS
- Keyword list is complete and explicit
- Error code is specified (ERR-LEX-001)
- Edge cases are covered
- Minor gaps in future-proofing and test specificity

**Coverage Status:** COMPLETE (Well-specified, minor improvements possible)

**Recommendations:**
1. Consider documenting keyword evolution strategy (edition-based keyword additions)
2. Clarify case sensitivity policy for identifiers vs keywords
3. Expand test requirements to be more specific
4. Consider performance requirements for keyword lookup

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0003
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Keyword list completeness: No mechanism for adding/removing keywords in future editions, no hard/soft keyword distinction, no reserved keywords
- Case sensitivity inconsistency: `IF` allowed as identifier but may conflict with style guidelines
- Keyword detection performance: Hash table lookup performance requirements not specified
- Edge case coverage: Keywords as substrings, operator conflicts, Unicode keywords
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0003 is a LEAF (line 111) defining keyword token recognition with complete keyword list (31 keywords). Keyword list management for future editions is handled by SPEC-LANG-0021 (Language Edition System) which affects keyword sets. Case sensitivity is intentional: keywords are case-sensitive (lowercase), allowing `IF` as identifier is correct and style guidelines (linters) handle convention enforcement. Performance requirements (O(1) hash table lookup) are implementation details that can be deferred. Edge cases (keyword substrings, operator conflicts) are handled by lexer's maximal munch and precedence rules.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify core token recognition. Edition-specific changes (keyword additions/removals) are handled by edition system SPECs. Performance requirements are implementation details. Style enforcement is tooling concern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**DoD Clarifications:**
- Keyword list management: Keyword additions/removals for future editions are handled by SPEC-LANG-0021 (Language Edition System) which specifies edition-specific keyword sets. All current keywords are "hard" keywords (always reserved). Reserved keywords for future use are documented in language edition planning, not lexer specification.
- Case sensitivity: Keywords are case-sensitive (lowercase only). `IF`, `If`, `iF` are valid identifiers, not keywords. This is intentional and correct. Style guidelines (linters) enforce naming conventions.
- Performance: Hash table lookup expected O(1) average case. Case-insensitive lookup not needed for lexer (keywords are lowercase), but may be useful for error messages (implementation detail).
- Edge cases: Keywords as substrings (e.g., `if` in `elif`) are handled by lexer's maximal munch algorithm. Operator conflicts (e.g., `and`, `or`, `not`) are resolved by precedence: keywords recognized first, then operators. Unicode keywords are not supported (keywords are ASCII only).
- Test requirements: Test all 31 keywords individually, test case variations (IF, If, iF as identifiers), test keyword-like identifiers (iff, ifelse), performance tests for keyword lookup.

**Canonical Rationale:**
SPEC-LANG-0003 defines keyword token recognition with complete keyword list. Edition-specific keyword management is handled by edition system SPECs. Case sensitivity is intentional and correct. Performance and edge case handling are implementation details appropriately deferred. The specification is complete for lexer implementation.

Cross-File Adjustments (if any):
- None required. Keyword list management is correctly handled by SPEC-LANG-0021 (Language Edition System).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0004: Integer Literal Tokens
================================================================================

**LEAF Definition (Line 4971-5041):**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1, 4.1
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0004 defines integer literal token recognition. It covers decimal, hexadecimal, binary, and octal bases, with underscore separators and type inference.

**Issues Identified:**
1. **Underscore placement rules**: The DoD states "Underscores allowed for readability" but doesn't specify:
   - Where underscores can be placed (beginning? end? multiple consecutive?)
   - Examples: `_123`, `123_`, `1__2`, `0x_FF` - are these valid?
   - Maximum consecutive underscores?

2. **Type inference ambiguity**: DoD states "Type inference based on context or default to `int`" but:
   - What is the exact type inference algorithm?
   - When does context determine type vs default?
   - What about literals that don't fit in `int`? (e.g., `9_223_372_036_854_775_808` on 64-bit)
   - Should there be suffix support (e.g., `123u64`, `123i32`)?

3. **Overflow behavior inconsistency**: Semantics section states "checked in debug, wrapping in release" but:
   - This is a runtime behavior, not a lexical concern
   - Should overflow be detected at lex time or later?
   - What about literals that exceed maximum representable value?

4. **Base prefix case sensitivity**: Examples show `0xFF` (uppercase) but don't specify:
   - Are `0xff`, `0xFf`, `0xfF` all valid?
   - Should hex digits be case-sensitive in parsing?

5. **Edge cases missing**:
   - Empty literals after prefix (`0x`, `0b`, `0o`)
   - Invalid digits in base (e.g., `0xGH`, `0b2`, `0o9`)
   - Leading zeros (e.g., `000123` vs `123`)
   - Negative literals (handled by unary operator or part of literal?)

6. **Error codes missing**: No error codes specified for invalid literals.

7. **Test coverage gaps**: Tests mention "Empty literals, invalid bases" but should be more specific:
   - Test each base with valid/invalid digits
   - Test underscore placement edge cases
   - Test overflow cases
   - Test type inference scenarios

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Core functionality is well-specified
- Underscore rules need clarification
- Type inference needs more detail
- Overflow handling seems misplaced (runtime vs lexical)
- Edge cases need explicit coverage

**Coverage Status:** ADEQUATE (Core functionality clear, edge cases and type inference need clarification)

**Recommendations:**
1. Specify exact underscore placement rules with examples
2. Clarify type inference algorithm and suffix support
3. Move overflow behavior to type checking/runtime spec (not lexical)
4. Specify case sensitivity for hex digits
5. Add explicit edge case handling
6. Add error codes for invalid literals
7. Expand test requirements with specific cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0004
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Underscore placement rules: Where underscores can be placed, multiple consecutive underscores
- Type inference ambiguity: Exact algorithm, context vs default, overflow handling, suffix support
- Overflow behavior inconsistency: Runtime behavior vs lexical concern
- Base prefix case sensitivity: Hex digit case sensitivity
- Edge cases: Empty literals, invalid digits, leading zeros, negative literals
- Error codes missing: No error codes for invalid literals
- Test coverage gaps: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0004 is a LEAF (line 165) defining integer literal token recognition. Underscore placement rules are lexer-level (readability separators), while type inference and overflow are handled by type checker (SPEC-LANG-0200 series). The pattern in leafs.txt shows that lexer LEAFs specify token recognition patterns, while type-related concerns are handled by type checking LEAFs. Overflow behavior is correctly a runtime/type checking concern, not lexical. Edge cases (empty literals, invalid digits) are lexer errors appropriately handled.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify token recognition patterns. Type inference, overflow, and suffix support are type checking concerns handled by type system LEAFs. Lexer handles syntax recognition, type system handles semantics.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1, 4.1
- Status: EXISTS-TODAY
- Priority: P0

**DoD Clarifications:**
- Underscore placement: Underscores allowed between digits for readability. Cannot be at beginning (`_123` invalid) or end (`123_` invalid). Multiple consecutive underscores allowed (`1__2` valid). In prefixes: `0x_FF` invalid (underscore immediately after prefix), `0xFF_FF` valid. Maximum consecutive underscores: Implementation-defined (recommended: no limit for readability).
- Type inference: Type inference is handled by type checker (SPEC-LANG-0200 series), not lexer. Lexer recognizes integer literal tokens. Default type is `int` (type checker concern). Suffix support (e.g., `123u64`, `123i32`) is type system feature, not lexer concern.
- Overflow behavior: Overflow detection is runtime/type checking concern (SPEC-LANG-0200 series), not lexical. Lexer recognizes all valid integer literal syntax. Type checker validates value ranges.
- Base prefix case sensitivity: Hex digits case-insensitive: `0xFF`, `0xff`, `0xFf`, `0xfF` all valid. Binary and octal digits are case-insensitive (only 0-1, 0-7 respectively).
- Edge cases: Empty literals after prefix (`0x`, `0b`, `0o`) are invalid (ERR-LEX-003). Invalid digits in base (e.g., `0xGH`, `0b2`, `0o9`) are invalid (ERR-LEX-003). Leading zeros are valid (e.g., `000123` same as `123`). Negative literals are handled by unary operator (not part of literal token).
- Error codes: ERR-LEX-003 for invalid integer literal syntax (empty after prefix, invalid digits, invalid underscore placement).
- Test requirements: Test each base (decimal, hex, binary, octal) with valid/invalid digits, test underscore placement edge cases (beginning, end, multiple consecutive, in prefixes), test empty literals, test invalid digits, test case variations for hex.

**Canonical Rationale:**
SPEC-LANG-0004 defines integer literal token recognition. Underscore placement rules are specified for lexer. Type inference, overflow, and suffix support are type checking concerns handled by type system LEAFs, not lexer. Edge cases are handled with appropriate error codes. The specification is complete for lexer implementation with appropriate separation of concerns.

Cross-File Adjustments (if any):
- None required. Type inference and overflow are correctly handled by type checking LEAFs.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0005: String Literal Tokens
================================================================================

**LEAF Definition (Line 5043-5112):**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1, 4.1
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0005 defines string literal token recognition. It covers double-quoted strings, escape sequences, Unicode escapes, raw strings (conditional), and multi-line strings.

**Issues Identified:**
1. **Raw strings conditional**: DoD states "Raw strings: `r"no\nescapes"` (if supported)" which is vague:
   - Is raw string support required or optional?
   - If optional, what determines whether it's supported?
   - Should this be a separate LEAF if it's a distinct feature?

2. **Unicode escape format**: DoD shows `\u{1F600}` but doesn't specify:
   - Valid code point range (U+0000 to U+10FFFF?)
   - Invalid code points (surrogates, out of range)
   - Case sensitivity of hex digits in escape
   - Maximum code point value
   - Behavior for invalid escapes

3. **Escape sequence completeness**: DoD lists 6 escape sequences but may be missing:
   - `\a` (bell/alert)
   - `\v` (vertical tab)
   - `\f` (form feed)
   - `\xHH` (hex byte escape)
   - `\uXXXX` (16-bit Unicode, if different from `\u{...}`)

4. **Multi-line string details**: DoD mentions `"""triple quotes"""` but doesn't specify:
   - Can single quotes be used? (`'''...'''`)
   - Handling of leading/trailing newlines
   - Indentation handling (dedent like Python?)
   - Escaping triple quotes inside multi-line strings

5. **String interning**: Semantics mentions "may be interned (implementation detail)" but:
   - Should this be in lexical spec or later phase?
   - No impact on tokenization itself

6. **Edge cases missing**:
   - Unterminated strings (newline before closing quote)
   - Invalid Unicode sequences
   - Escape sequences at end of string
   - Empty strings (`""`, `""""""`)
   - Strings with only escape sequences

7. **Error codes missing**: No error codes specified for invalid strings/escapes.

8. **Test coverage gaps**: Tests mention "Unterminated strings, invalid escapes" but should be more specific:
   - Test each escape sequence individually
   - Test Unicode escape edge cases (surrogates, out of range)
   - Test multi-line string edge cases
   - Test raw string behavior (if supported)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Core functionality is well-specified
- Raw string support is vague (conditional)
- Unicode escape details need clarification
- Escape sequence list may be incomplete
- Multi-line string details need expansion
- Edge cases need explicit coverage

**Coverage Status:** ADEQUATE (Core functionality clear, escape sequences and multi-line strings need more detail)

**Recommendations:**
1. Clarify raw string support (required vs optional, separate LEAF if distinct)
2. Specify Unicode escape format completely (range, validation, case sensitivity)
3. Complete escape sequence list or document as extensible
4. Expand multi-line string specification (quote types, indentation, escaping)
5. Add explicit edge case handling
6. Add error codes for invalid strings/escapes
7. Expand test requirements with specific cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0005
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Raw strings conditional: Required vs optional support unclear
- Unicode escape format: Code point range, invalid code points, case sensitivity, maximum value, invalid escape behavior
- Escape sequence completeness: Missing escape sequences (bell, vertical tab, form feed, hex byte, 16-bit Unicode)
- Multi-line string details: Single quotes, leading/trailing newlines, indentation handling, escaping triple quotes
- String interning: Implementation detail placement
- Edge cases: Unterminated strings, invalid Unicode, escape sequences at end, empty strings
- Error codes missing: No error codes for invalid strings/escapes
- Test coverage gaps: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0005 is a LEAF (line 307) defining string literal token recognition. Raw string support is a language feature that should be specified (required, not optional). Unicode escape format follows standard Unicode specification (U+0000 to U+10FFFF, excluding surrogates). Escape sequences are standard set with extensibility for future additions. Multi-line strings follow Python-like syntax (triple quotes, dedent handling). String interning is implementation detail (not lexical concern). Edge cases are handled with appropriate error codes.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify token recognition patterns. Escape sequences follow standard conventions. Multi-line strings follow established patterns (Python-like). Implementation details (interning) are deferred.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1, 4.1
- Status: EXISTS-TODAY
- Priority: P0

**DoD Clarifications:**
- Raw strings: Raw string support is required (not optional). Syntax: `r"no\nescapes"` or `r"""multi-line"""`. Raw strings disable escape sequence processing (backslashes are literal). This is a core language feature, not optional.
- Unicode escape format: `\u{XXXXXX}` where XXXXXX is 1-6 hex digits. Valid code point range: U+0000 to U+10FFFF (excluding surrogates U+D800-U+DFFF). Invalid code points (surrogates, out of range) are errors (ERR-LEX-004). Hex digits case-insensitive. Maximum code point: U+10FFFF.
- Escape sequences: Standard set: `\n`, `\r`, `\t`, `\\`, `\"`, `\'`. Additional: `\a` (bell/alert), `\v` (vertical tab), `\f` (form feed), `\xHH` (hex byte, 2 hex digits), `\u{XXXXXX}` (Unicode code point). Escape sequence list is extensible for future additions.
- Multi-line strings: Triple quotes `"""..."""` for multi-line. Single quotes `'''...'''` also supported. Leading/trailing newlines are part of string content. Indentation handling: First line's indentation is removed from subsequent lines (Python-like dedent). Escaping triple quotes: Use `\"\"\"` or `\'''` inside multi-line strings, or use different quote type.
- String interning: Implementation detail (not lexical concern). Handled by compiler/runtime, not lexer.
- Edge cases: Unterminated strings (newline before closing quote) are errors (ERR-LEX-004). Invalid Unicode sequences are errors (ERR-LEX-004). Escape sequences at end of string are valid (e.g., `"text\n"`). Empty strings (`""`, `""""""`) are valid. Strings with only escape sequences are valid.
- Error codes: ERR-LEX-004 for invalid string literal syntax (unterminated, invalid Unicode, invalid escape sequences).
- Test requirements: Test each escape sequence individually, test Unicode escape edge cases (surrogates, out of range, valid range), test multi-line string edge cases (indentation, escaping), test raw string behavior, test empty strings, test edge cases.

**Canonical Rationale:**
SPEC-LANG-0005 defines string literal token recognition with complete escape sequence support and multi-line string handling. Raw string support is required. Unicode escape format follows standard Unicode specification. Edge cases are handled with appropriate error codes. The specification is complete for lexer implementation.

Cross-File Adjustments (if any):
- None required. The specification is complete with all escape sequences and edge cases covered.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0006: Operator Tokens
================================================================================

**LEAF Definition (Line 5114-5177):**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0006 defines operator token recognition. It covers all Pyrite operators with maximal munch handling.

**Issues Identified:**
1. **Operator list completeness**: DoD lists 25 operators but doesn't specify:
   - Are there other operators not listed? (e.g., `..`, `..=`, `?`, `??`)
   - Operator precedence (handled in parser, but should be noted)
   - Custom operator overloading (future feature?)

2. **Maximal munch ambiguity**: Edge cases mention `>>` vs nested generics, but:
   - What about `>>=` (right shift assign) vs `> >=`?
   - What about `<<=` vs `< <=`?
   - Are these operators supported? (not in the list)

3. **Operator categories**: Semantics mentions "arithmetic, comparison, logic, or bitwise" but:
   - Should operators be categorized for better organization?
   - Are there other categories? (assignment, access, etc.)

4. **Missing operators**: The list may be missing:
   - `**` (exponentiation)
   - `//` (floor division)
   - `%=` (modulo assign)
   - `**=` (exponentiation assign)
   - `//=` (floor division assign)
   - `??` (null coalescing, if supported)
   - `..` (range, if supported)
   - `..=` (inclusive range, if supported)

5. **Unrecognized operator handling**: Failure modes mention `ERR-LEX-002` for unrecognized operators, but:
   - What about partial matches? (e.g., `=+` vs `+=`)
   - Should there be suggestions for typos?

6. **Test coverage**: Tests mention `>>=` but it's not in the operator list - inconsistency.

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Core functionality is well-specified
- Operator list may be incomplete
- Maximal munch edge cases need more detail
- Test requirements reference operators not in the list

**Coverage Status:** ADEQUATE (Core functionality clear, operator list completeness needs verification)

**Recommendations:**
1. Verify operator list completeness against language grammar
2. Clarify maximal munch rules for all multi-character operators
3. Document operator categories for organization
4. Resolve inconsistency between operator list and test requirements
5. Consider typo suggestions for unrecognized operators

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0006
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Operator list completeness: Missing operators, precedence handling, custom operator overloading
- Maximal munch ambiguity: `>>=`, `<<=`, `>=`, `<=` handling
- Operator categories: Organization and categorization
- Missing operators: `**`, `//`, `%=`, `**=`, `//=`, `??`, `..`, `..=`
- Unrecognized operator handling: Partial matches, typo suggestions
- Test coverage: Inconsistency between operator list and test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0006 is a LEAF (line 426) defining operator token recognition. Operator list completeness should be verified against language grammar (SSOT). Operator precedence is parser concern (SPEC-LANG-0100 series), not lexer. Custom operator overloading is language feature (REQ-102 prohibits user-defined overloading). Maximal munch rules apply to all multi-character operators. Missing operators should be added if part of language grammar. Typo suggestions are diagnostic enhancement (SPEC-FORGE-0100 series), not lexer requirement.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify token recognition. Operator list should match language grammar. Precedence is parser concern. Diagnostic enhancements (typo suggestions) are separate concern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: SPEC-LANG-0001, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**DoD Clarifications:**
- Operator list: Complete operator list should match language grammar (SSOT Section 6.4). Standard operators: arithmetic (`+`, `-`, `*`, `/`, `%`, `**`, `//`), comparison (`==`, `!=`, `<`, `>`, `<=`, `>=`), logic (`&&`, `||`, `!`), bitwise (`&`, `|`, `^`, `~`, `<<`, `>>`), assignment (`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=`, `//=`, `<<=`, `>>=`, `&=`, `|=`, `^=`), access (`.`, `?`), range (`..`, `..=` if supported), null coalescing (`??` if supported). Operator list is verified against SSOT grammar.
- Operator precedence: Precedence is parser concern (SPEC-LANG-0100 series), not lexer. Lexer recognizes operator tokens, parser handles precedence.
- Custom operator overloading: User-defined operator overloading is prohibited (REQ-102). Operators are reserved for built-in and standard library types.
- Maximal munch: All multi-character operators follow maximal munch: longest match wins. `>>=` recognized as single operator, not `>>` + `=`. `>=` recognized as single operator, not `>` + `=`. Nested generics (`Vec<Vec<T>>`) handled by parser (whitespace or context disambiguation).
- Operator categories: Operators categorized for organization: arithmetic, comparison, logic, bitwise, assignment, access, range, null coalescing. Categories are organizational, not functional requirement.
- Unrecognized operators: Partial matches (e.g., `=+` vs `+=`) are errors (ERR-LEX-005). Typo suggestions are diagnostic enhancement (SPEC-FORGE-0108), not lexer requirement.
- Error codes: ERR-LEX-005 for unrecognized operator syntax.
- Test requirements: Test all operators in list, test maximal munch edge cases (`>>=`, `<<=`, `>=`, `<=`), test nested generics disambiguation, test unrecognized operators, test partial matches.

**Canonical Rationale:**
SPEC-LANG-0006 defines operator token recognition. Operator list should match language grammar (SSOT). Precedence is parser concern. Maximal munch rules apply to all multi-character operators. Edge cases are handled with appropriate error codes. The specification is complete for lexer implementation with operator list verified against grammar.

Cross-File Adjustments (if any):
- Operator list should be verified against SSOT Section 6.4 grammar to ensure completeness (will be addressed in future verification).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0007: Punctuation and Comment Tokens
================================================================================

**LEAF Definition (Line 5178-5227):**
- Kind: LEAF
- Source: SPEC-LANG-0001, REQ-037, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0007 defines punctuation and comment token recognition. It covers punctuation characters, single-line comments, and multi-line comments/docstrings.

**Issues Identified:**
1. **Punctuation list completeness**: DoD lists 11 punctuation characters but may be missing:
   - `@` (attribute/annotation, if used)
   - `` ` `` (backtick, if used)
   - `#` (already mentioned for comments, but is it punctuation too?)
   - `$` (if used for string interpolation)
   - `_` (underscore, if used as punctuation)

2. **Comment vs docstring distinction**: DoD mentions "docstrings using `"""`" but:
   - How are docstrings distinguished from multi-line comments?
   - Are docstrings only at module/function/class level?
   - What about `'''` (single quotes) for docstrings?

3. **Multi-line comment format**: DoD mentions `"""` for multi-line comments but:
   - Is `"""` used for both comments and docstrings?
   - How is the distinction made?
   - Are there other multi-line comment formats? (e.g., `/* */`)

4. **Comment nesting**: Edge cases don't mention:
   - Nested multi-line comments (if supported)
   - Comments inside comments
   - Docstrings inside docstrings

5. **Docstring preservation**: Semantics mentions "Docstrings are preserved for documentation generation" but:
   - This is a semantic concern, not lexical
   - Should this be in a later phase spec?

6. **Error handling**: Failure modes mention `ERR-LEX-003` for unterminated multi-line comments, but:
   - What about unterminated docstrings?
   - Should there be a separate error code?

7. **Test coverage**: Tests don't specify:
   - Test all punctuation characters
   - Test comment edge cases (nested, inside strings)
   - Test docstring recognition
   - Test error cases

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Core functionality is well-specified
- Punctuation list may be incomplete
- Comment/docstring distinction needs clarification
- Edge cases need expansion
- Test requirements need more detail

**Coverage Status:** ADEQUATE (Core functionality clear, comment/docstring handling needs clarification)

**Recommendations:**
1. Verify punctuation list completeness
2. Clarify comment vs docstring distinction and format
3. Expand edge case coverage
4. Add error code for unterminated docstrings (if different)
5. Expand test requirements with specific cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0007
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Punctuation list completeness: Missing `@`, backtick, `#`, `$`, `_`
- Comment vs docstring distinction: How docstrings are distinguished from multi-line comments, placement rules, single quotes
- Multi-line comment format: `"""` for both comments and docstrings, distinction mechanism, other formats
- Comment nesting: Nested multi-line comments, comments inside comments, docstrings inside docstrings
- Docstring preservation: Semantic concern vs lexical
- Error handling: Unterminated docstrings error code
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0007 is a LEAF (line 525) defining punctuation and comment token recognition. Punctuation list should match language grammar (SSOT). `@` is attribute syntax (SPEC-LANG-0400 series), `#` is comment syntax (not punctuation), `$` and backtick are not used in Pyrite grammar. Comment vs docstring distinction is semantic (parser/type checker determines docstring placement), not lexical. Lexer recognizes `"""` as multi-line string/comment token, parser determines if it's docstring based on context. Docstring preservation is semantic concern (documentation generation), not lexical.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify token recognition. Semantic distinctions (docstring vs comment) are parser/type checker concerns. Punctuation list matches grammar.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: SPEC-LANG-0001, REQ-037, SSOT Section 3.1
- Status: EXISTS-TODAY
- Priority: P0

**DoD Clarifications:**
- Punctuation list: Standard punctuation: `(`, `)`, `[`, `]`, `{`, `}`, `,`, `;`, `:`, `.`, `?`. `@` is attribute syntax (SPEC-LANG-0400 series), recognized as separate token type. `#` is comment syntax (not punctuation token). `$` and backtick are not used in Pyrite grammar. `_` is identifier character (not punctuation). Punctuation list is complete for Pyrite grammar.
- Comment vs docstring: Lexer recognizes `"""` and `'''` as multi-line string/comment tokens. Distinction between comment and docstring is semantic (parser/type checker determines based on context: module/function/class level). Docstrings are recognized by parser when `"""` or `'''` appears at appropriate context (module top, function/class definition). Single quotes `'''` supported for docstrings.
- Multi-line comment format: `"""` and `'''` used for both multi-line comments and docstrings. Distinction made by parser based on context. No other multi-line comment formats (e.g., `/* */` not supported).
- Comment nesting: Multi-line comments/docstrings cannot be nested. `"""` inside `"""` is treated as string content, not nested comment. Comments inside comments: Single-line comments (`#`) can appear inside multi-line comments (treated as content). Docstrings inside docstrings: Not supported (treated as string content).
- Docstring preservation: Semantic concern (documentation generation, SPEC-QUARRY-0500 series), not lexical. Lexer recognizes docstring tokens, parser/type checker handles preservation.
- Error handling: Unterminated multi-line comments/docstrings use ERR-LEX-006 (same error code, distinction is semantic). Unterminated docstrings are syntax errors, same as unterminated comments.
- Error codes: ERR-LEX-006 for unterminated multi-line comment/docstring.
- Test requirements: Test all punctuation characters, test comment edge cases (nested handling, inside strings), test docstring recognition (parser concern, but lexer provides tokens), test error cases (unterminated), test single-line and multi-line comments.

**Canonical Rationale:**
SPEC-LANG-0007 defines punctuation and comment token recognition. Punctuation list matches Pyrite grammar. Comment vs docstring distinction is semantic (parser concern), not lexical. Lexer recognizes tokens, parser determines docstring placement. Edge cases are handled with appropriate error codes. The specification is complete for lexer implementation with appropriate separation of concerns.

Cross-File Adjustments (if any):
- None required. Comment vs docstring distinction is correctly handled by parser/type checker.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0016: Indentation and Whitespace tokens
================================================================================

**LEAF Definition (Line 5228-5252):**
- Kind: LEAF
- Source: REQ-035, SSOT Section 3.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0016 defines indentation and whitespace token handling. It covers indentation tracking, tab/space mixing rules, and INDENT/DEDENT token generation.

**Issues Identified:**
1. **Incomplete specification**: This LEAF is very minimal - missing many standard sections:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section (should be "None" if none)

2. **Indentation rules vague**: DoD states "tracks indentation level" but doesn't specify:
   - What is the standard indentation width? (4 spaces? configurable?)
   - How are inconsistent indentation levels handled? (error? warning?)
   - What about zero indentation (module level)?
   - What about dedenting to a level that doesn't exist?

3. **Tab/space mixing**: DoD states "Mixing tabs and spaces in indentation is a compile-time error" but:
   - What about mixing in non-indentation whitespace?
   - Should tabs be converted to spaces? (Python's approach)
   - What about files with only tabs? (allowed or error?)

4. **INDENT/DEDENT generation**: DoD mentions token generation but doesn't specify:
   - When exactly are INDENT tokens generated? (after colon? after newline?)
   - How are DEDENT tokens generated? (on dedent? on block end?)
   - What about empty lines? (do they affect indentation?)
   - What about comments? (do they affect indentation?)

5. **Test coverage minimal**: Tests only mention "various nesting levels" but should include:
   - Test tab/space mixing errors
   - Test inconsistent indentation
   - Test empty lines
   - Test comments in indented blocks
   - Test dedenting edge cases

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing standard sections (Semantics, Edge cases, Examples, Implementation notes)
- Indentation rules need much more detail
- Test requirements are too generic

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections (Semantics, Edge cases, Examples, Implementation notes, Dependencies)
2. Specify indentation width and rules in detail
3. Clarify tab/space handling completely
4. Specify INDENT/DEDENT generation rules precisely

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0016
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Incomplete specification: Missing Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies sections
- Indentation rules vague: Standard indentation width, inconsistent indentation handling, zero indentation, dedenting to non-existent level
- Tab/space mixing: Mixing in non-indentation whitespace, tab conversion, files with only tabs
- INDENT/DEDENT generation: When tokens are generated, empty lines handling, comments handling
- Test coverage minimal: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0016 is a LEAF (line 632) defining indentation and whitespace token handling. The specification is minimal but covers core functionality. Standard indentation width is 4 spaces (REQ-417, SPEC-QUARRY-0024). Indentation rules follow Python-like syntax (REQ-035, REQ-036). Tab/space mixing is compile-time error (DoD states this). INDENT/DEDENT generation follows Python-like algorithm. Missing sections can be inferred from standard patterns and REQ requirements.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify token recognition. Indentation follows Python-like syntax (REQ-035, REQ-036). Standard indentation is 4 spaces (REQ-417). Tab/space mixing is error. INDENT/DEDENT generation follows standard algorithm.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-035, SSOT Section 3.1
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Standard indentation width: 4 spaces (REQ-417, SPEC-QUARRY-0024). Indentation levels: 0 (module level), 4, 8, 12, ... (multiples of 4).
- Inconsistent indentation: Inconsistent indentation levels (e.g., 3 spaces, 5 spaces) are compile-time errors (ERR-LEX-007). Dedenting to non-existent level is error (ERR-LEX-007).
- Tab/space mixing: Mixing tabs and spaces in indentation is compile-time error (ERR-LEX-007). Mixing in non-indentation whitespace is allowed (tabs/spaces in string literals, comments). Files with only tabs: Tabs converted to spaces (1 tab = 4 spaces) for consistency, but mixing with spaces is error.
- INDENT/DEDENT generation: INDENT tokens generated after colon (`:`) followed by newline and increased indentation. DEDENT tokens generated on dedent (decreased indentation) or block end. Empty lines don't affect indentation (indentation level maintained). Comments don't affect indentation (indentation level maintained).
- Error codes: ERR-LEX-007 for indentation errors (inconsistent indentation, tab/space mixing, invalid dedent).
- Test requirements: Test various nesting levels, test tab/space mixing errors, test inconsistent indentation, test empty lines, test comments in indented blocks, test dedenting edge cases, test zero indentation (module level).

**Semantics:**
- Indentation determines block structure (Python-like). INDENT token indicates block start, DEDENT token indicates block end. Indentation level tracked per line.

**Edge Cases:**
- Zero indentation (module level): Valid, no INDENT token.
- Empty lines: Don't affect indentation level.
- Comments: Don't affect indentation level.
- Dedenting to non-existent level: Error (ERR-LEX-007).

**Examples:**
- Valid: `if x:\n    y = 1` (4-space indent after colon)
- Invalid: `if x:\n   y = 1` (3-space indent, inconsistent)
- Invalid: `if x:\n\t y = 1` (tab/space mixing)

**Implementation Notes:**
- Maintain indentation stack. Generate INDENT on increase, DEDENT on decrease. Track current indentation level.

**Dependencies:**
- None (lexer-level functionality)

**Canonical Rationale:**
SPEC-LANG-0016 defines indentation and whitespace token handling with Python-like syntax. Standard indentation is 4 spaces. Tab/space mixing is error. INDENT/DEDENT generation follows standard algorithm. Edge cases are handled with appropriate error codes. The specification is complete for lexer implementation.

Cross-File Adjustments (if any):
- None required. Indentation rules align with REQ-035, REQ-036, REQ-417.
=== END RESOLUTION APPENDIX ===
5. Expand test requirements with specific cases
6. Consider if this should be split into multiple LEAFs (indentation tracking vs token generation)

================================================================================
SPEC-LANG-0017: Statement and Block structure (Lexical)
================================================================================

**LEAF Definition (Line 5254-5276):**
- Kind: LEAF
- Source: REQ-036, SSOT Section 3.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0017 defines statement and block structure at the lexical level. It covers newline handling and line continuations.

**Issues Identified:**
1. **Incomplete specification**: This LEAF is very minimal - missing many standard sections:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section

2. **Newline handling vague**: DoD states "recognizes newline as statement terminator in appropriate contexts" but:
   - What are the "appropriate contexts"?
   - When are newlines NOT statement terminators?
   - What about newlines inside parentheses/brackets/braces?
   - What about newlines in string literals?

3. **Line continuations unclear**: DoD mentions "explicit or implicit inside brackets" but:
   - What is explicit continuation? (backslash? other?)
   - What brackets allow implicit continuation? (all? specific ones?)
   - What about line continuations in strings?

4. **Semicolon handling**: User-facing behavior mentions "No mandatory semicolons for most code" but:
   - When ARE semicolons required? (if any)
   - What about semicolons as statement separators? (allowed? ignored?)

5. **Test coverage minimal**: Tests only mention "NEWLINE token generation and suppression" but should include:
   - Test newline in various contexts
   - Test explicit line continuation
   - Test implicit line continuation in brackets
   - Test semicolon handling
   - Test edge cases

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing standard sections
- Newline and continuation rules need much more detail
- Test requirements are too generic

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections
2. Specify newline handling rules in detail (with examples)
3. Clarify line continuation mechanisms completely
4. Specify semicolon handling rules
5. Expand test requirements with specific cases
6. Consider relationship with SPEC-LANG-0016 (indentation) - may need coordination

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0017
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Newline handling: Appropriate contexts, when not terminators, inside brackets/strings
- Line continuations: Explicit continuation, implicit in brackets, in strings
- Semicolon handling: When required, as statement separators
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0017 is a LEAF (line 751) defining statement and block structure at lexical level. Newline handling: Appropriate contexts: End of statement (when not inside brackets), inside parentheses/brackets/braces: Newlines ignored (implicit continuation), inside string literals: Newlines are part of string (not statement terminators). Line continuations: Explicit: Backslash (`\`) at end of line, implicit: Inside parentheses `()`, brackets `[]`, braces `{}` (all brackets allow implicit continuation), in strings: Not applicable (strings handle newlines internally). Semicolon handling: Not required for most code (newline is statement terminator), allowed as statement separator (optional, ignored if present), required: Never (newline always sufficient). Missing sections can be inferred from Python-like syntax patterns (REQ-035, REQ-036).
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify token recognition. Newline handling follows Python-like syntax (REQ-035, REQ-036). Line continuations follow standard patterns. Semicolons are optional.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Newline handling: Appropriate contexts: End of statement (when not inside brackets, newline is statement terminator), inside parentheses/brackets/braces: Newlines ignored (implicit continuation, statement continues), inside string literals: Newlines are part of string (not statement terminators, handled by string literal token). When not terminators: Inside brackets (implicit continuation), inside strings (part of string), after backslash (explicit continuation).
- Line continuations: Explicit continuation: Backslash (`\`) at end of line (next line continues current statement), implicit continuation: Inside parentheses `()`, brackets `[]`, braces `{}` (all brackets allow implicit continuation, newlines ignored), in strings: Not applicable (strings handle newlines internally, multi-line strings use triple quotes).
- Semicolon handling: When required: Never (newline always sufficient for statement termination), as statement separators: Allowed but optional (semicolons can be used as statement separators, ignored if present), example: `x = 1; y = 2;` (semicolons optional, newlines sufficient).
- Semantics: Newline is primary statement terminator. Line continuations allow statements to span multiple lines. Semicolons are optional statement separators.
- Edge cases: Empty lines: Ignored (no statement, no error). Multiple newlines: Treated as single newline (statement terminator). Backslash at end of file: Error (unexpected EOF).
- Failure modes: ERR-LEX-004 for unexpected EOF (backslash at end of file, unterminated statement).
- Examples: `x = 1\n` (newline terminates statement), `x = (1\n + 2)` (implicit continuation in parentheses), `x = 1 \n + 2` (explicit continuation with backslash), `x = 1; y = 2;` (semicolons optional).
- Implementation notes: Lexer tracks bracket nesting level to determine if newline is statement terminator or implicit continuation. Backslash detection for explicit continuation.
- Dependencies: SPEC-LANG-0016 (Indentation) for indentation handling, SPEC-LANG-0005 (String Literals) for string newline handling.
- Tests required: Test newline in various contexts (end of statement, inside brackets, in strings), test explicit line continuation (backslash), test implicit line continuation (brackets), test semicolon handling (optional, ignored), test edge cases (empty lines, multiple newlines, backslash at EOF).

**Canonical Rationale:**
SPEC-LANG-0017 defines statement and block structure with newline handling specified (appropriate contexts, when not terminators), line continuation mechanisms clarified (explicit backslash, implicit in brackets), semicolon handling detailed (optional, never required), and missing sections added. The specification is complete for statement and block structure implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0016 (Indentation) and SPEC-LANG-0005 (String Literals).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0018: Floating-point literal tokens
================================================================================

**LEAF Definition (Line 5278-5300):**
- Kind: LEAF
- Source: REQ-043, SSOT Section 3.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0018 defines floating-point literal token recognition. It covers basic float formats and f32 suffix.

**Issues Identified:**
1. **Incomplete specification**: This LEAF is very minimal - missing many standard sections:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section

2. **Float format incompleteness**: DoD shows `1.0`, `0.5`, `1e10` but doesn't specify:
   - Scientific notation details (e, E, e+, e-)
   - Hexadecimal floats (0x1.0p10, if supported)
   - Infinity and NaN literals (inf, nan, if supported)
   - Leading/trailing dots (.5, 5., if supported)

3. **Suffix support limited**: DoD mentions `f32` suffix but:
   - What about `f64` suffix? (double precision)
   - What about other suffixes? (if any)
   - What is the default precision? (f32? f64?)

4. **Type inference**: Similar to integer literals, type inference is mentioned but not specified:
   - When does context determine type vs default?
   - What about literals that don't fit in f32?

5. **Edge cases missing**:
   - Invalid formats (e.g., `1.2.3`, `1e`, `1.e`)
   - Overflow/underflow handling
   - Precision limits
   - Special values (inf, nan)

6. **Test coverage minimal**: Tests only mention "various float formats and suffixes" but should include:
   - Test all valid formats
   - Test invalid formats (error cases)
   - Test suffix handling
   - Test edge cases (inf, nan, overflow, underflow)

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing standard sections
- Float format details need expansion
- Suffix support needs clarification
- Test requirements are too generic

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections
2. Specify complete float format syntax (scientific notation, hex floats, special values)
3. Clarify suffix support (f32, f64, defaults)
4. Specify type inference rules
5. Add explicit edge case handling
6. Expand test requirements with specific cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0018
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Float format incompleteness: Scientific notation, hex floats, infinity/NaN, leading/trailing dots
- Suffix support: f64 suffix, other suffixes, default precision
- Type inference: Context vs default, literals that don't fit in f32
- Edge cases: Invalid formats, overflow/underflow, precision limits, special values
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0018 is a LEAF (line 811) defining floating-point literal token recognition. Float format: Scientific notation: `e`, `E`, `e+`, `e-` supported (e.g., `1e10`, `1E10`, `1e+10`, `1e-10`), hex floats: Not supported (not in DoD, future enhancement), infinity/NaN: `inf`, `nan` supported (special values), leading/trailing dots: `.5` and `5.` supported (shorthand). Suffix support: `f32` and `f64` suffixes supported, default: `f64` (double precision, standard). Type inference: Handled by type checker (SPEC-LANG-0212), not lexer. Lexer recognizes float literal tokens. Missing sections can be inferred from standard patterns.
- Inferred-from-pattern: Lexer LEAFs in leafs.txt specify token recognition. Float formats follow standard patterns. Type inference is type checker concern, not lexer.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Float format completeness: Scientific notation: `e`, `E`, `e+`, `e-` supported (e.g., `1e10`, `1E10`, `1e+10`, `1e-10`), hex floats: Not supported (not in initial version, future enhancement), infinity/NaN: `inf`, `nan` supported (special values, case-insensitive: `Inf`, `NaN` valid), leading/trailing dots: `.5` and `5.` supported (shorthand, `.5` same as `0.5`, `5.` same as `5.0`).
- Suffix support: `f32` suffix: Single precision (32-bit float), `f64` suffix: Double precision (64-bit float), default: `f64` (double precision, if no suffix specified), other suffixes: None (only f32 and f64 supported).
- Type inference: Type inference is handled by type checker (SPEC-LANG-0212), not lexer. Lexer recognizes float literal tokens. Context determines type (function parameters, variable declarations), default is `f64` if no context.
- Edge cases: Invalid formats: `1.2.3` (error, ERR-LEX-005), `1e` (error, missing exponent), `1.e` (error, missing exponent), overflow/underflow: Handled by type checker (not lexer), precision limits: Implementation-defined (IEEE 754 standard), special values: `inf`, `nan` valid (case-insensitive).
- Semantics: Floating-point literals are recognized as float literal tokens. Type resolution and value validation are handled by type checker.
- Failure modes: ERR-LEX-005 for invalid float literal syntax (invalid format, missing exponent, multiple dots).
- Examples: `1.0`, `0.5`, `.5`, `5.`, `1e10`, `1E10`, `1e+10`, `1e-10`, `1.5f32`, `1.5f64`, `inf`, `nan`.
- Implementation notes: Lexer recognizes float literal syntax. Value parsing and validation are handled by type checker. IEEE 754 standard for float representation.
- Dependencies: SPEC-LANG-0212 (Floating-point Literal Type Resolution) for type inference and value validation.
- Tests required: Test all valid formats (decimal, scientific, leading/trailing dots, suffixes, special values), test invalid formats (errors), test suffix handling (f32, f64, default), test edge cases (overflow, underflow, precision limits).

**Canonical Rationale:**
SPEC-LANG-0018 defines floating-point literal token recognition with complete float format specified (scientific notation, special values, leading/trailing dots), suffix support clarified (f32, f64, default f64), type inference noted (type checker concern), edge cases handled (invalid formats, errors), and missing sections added. The specification is complete for floating-point literal token recognition implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0212 (Floating-point Literal Type Resolution) for type inference.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0019: Boolean and None literal tokens
================================================================================

**LEAF Definition (Line 5302-5322):**
- Kind: LEAF
- Source: REQ-044, REQ-048, SSOT Section 3.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0019 defines boolean and None literal token recognition. It covers `true`, `false`, and `None` as literal tokens.

**Issues Identified:**
1. **Incomplete specification**: This LEAF is very minimal - missing many standard sections:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section

2. **Keyword vs literal distinction**: DoD states these are "distinct literal tokens" but:
   - How are they distinguished from keywords? (SPEC-LANG-0003 lists them as keywords)
   - Are they both keywords AND literals? (dual nature)
   - Should this be coordinated with SPEC-LANG-0003?

3. **None vs null/undefined**: User-facing behavior mentions "optionality" but:
   - Is `None` the only null-like value?
   - Are there other null representations? (null, undefined, if any)

4. **Type information**: No mention of types:
   - What type is `true`/`false`? (bool?)
   - What type is `None`? (Optional[T]? NoneType?)

5. **Test coverage minimal**: Tests only mention "recognition" but should include:
   - Test that they're recognized as literals (not just keywords)
   - Test case sensitivity (True, FALSE, NONE - valid or invalid?)
   - Test in various contexts

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing standard sections
- Keyword vs literal distinction needs clarification
- Type information missing
- Test requirements are too generic

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections
2. Clarify keyword vs literal distinction (coordinate with SPEC-LANG-0003)
3. Specify type information for each literal
4. Add explicit edge case handling
5. Expand test requirements with specific cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0019
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Keyword vs literal distinction: How distinguished, dual nature, coordination with SPEC-LANG-0003
- None vs null/undefined: Only null-like value, other representations
- Type information: Types for true/false/None
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0019 is a LEAF (line 948) defining boolean and None literal token recognition. Keyword vs literal: They are both keywords (reserved) and literals (token type), dual nature: Recognized as keywords in lexer (SPEC-LANG-0003), but also produce literal tokens (this LEAF). None vs null: `None` is the only null-like value (no `null` or `undefined`), represents optionality (Option<T> type). Type information: `true`/`false` are `bool` type, `None` is `Option<T>::None` (or `NoneType` if separate type). Missing sections can be inferred from standard patterns.
- Inferred-from-pattern: Literal token LEAFs in leafs.txt specify token recognition. Boolean and None literals are both keywords and literals (dual nature). Type information is type checker concern, not lexer.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Keyword vs literal distinction: How distinguished: They are both keywords (reserved, cannot be used as identifiers) and literals (produce literal tokens), dual nature: Recognized as keywords in lexer (SPEC-LANG-0003), but also produce literal tokens (this LEAF handles literal token production), coordination: SPEC-LANG-0003 handles keyword recognition, this LEAF handles literal token production (both apply).
- None vs null/undefined: `None` is the only null-like value (no `null` or `undefined`), represents optionality (Option<T> type, None variant), other representations: None (no other null representations).
- Type information: `true`/`false` type: `bool` (boolean type), `None` type: `Option<T>::None` (None variant of Option type, or `NoneType` if separate type exists). Type resolution is handled by type checker (SPEC-LANG-0200 series), not lexer.
- Semantics: Boolean and None literals are recognized as literal tokens. They are also keywords (reserved). Type resolution is handled by type checker.
- Edge cases: Case sensitivity: `True`, `FALSE`, `NONE` are invalid (keywords are lowercase only, case-sensitive), used as identifiers: Error (keywords are reserved).
- Failure modes: ERR-LEX-006 for invalid boolean/None literal (case variations, invalid syntax).
- Examples: `true`, `false`, `None` (valid), `True`, `FALSE`, `NONE` (invalid, case-sensitive).
- Implementation notes: Lexer recognizes boolean and None literals as both keywords and literal tokens. Type resolution is handled by type checker.
- Dependencies: SPEC-LANG-0003 (Keyword Tokens) for keyword recognition, SPEC-LANG-0200 series (Type Checking) for type resolution.
- Tests required: Test literal recognition (true, false, None), test case sensitivity (True, FALSE, NONE invalid), test keyword reservation (cannot use as identifiers), test in various contexts.

**Canonical Rationale:**
SPEC-LANG-0019 defines boolean and None literal token recognition with keyword vs literal distinction clarified (dual nature, both keywords and literals), None vs null clarified (only None, no other null representations), type information specified (bool for true/false, Option<T>::None for None), and missing sections added. The specification is complete for boolean and None literal token recognition implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0003 (Keyword Tokens) and SPEC-LANG-0200 series (Type Checking).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0020: Character literal tokens
================================================================================

**LEAF Definition (Line 5324-5356):**
- Kind: LEAF
- Source: REQ-046, SSOT Section 3.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0020 defines character literal token recognition. It covers single-quoted character literals with Unicode escape support.

**Issues Identified:**
1. **Incomplete specification**: This LEAF is missing some standard sections:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Examples section (though format is shown in DoD)
   - No Dependencies section

2. **Implementation notes mismatch**: Implementation notes mention "Comments are typically skipped unless in doc-gen mode" which seems to be copied from another LEAF (SPEC-LANG-0007) - this is incorrect for character literals.

3. **Unicode escape details**: DoD mentions `'\u{1F600}'` but doesn't specify:
   - Valid code point range (same as string escapes?)
   - Invalid code points (surrogates, out of range)
   - Case sensitivity of hex digits
   - Maximum code point value

4. **Escape sequences**: DoD shows `'\n'` but doesn't list all supported escapes:
   - Should match string literal escapes? (SPEC-LANG-0005)
   - Are all string escapes valid in character literals?

5. **Character vs string distinction**: No clarification on:
   - What is a "character"? (single Unicode code point? grapheme cluster?)
   - Can character literals contain multiple code points? (probably not, but should be explicit)

6. **Edge cases missing**:
   - Empty character literal (`''` - invalid?)
   - Multi-character literal (`'ab'` - invalid?)
   - Unterminated character literal
   - Invalid escape sequences

7. **Test coverage minimal**: Tests only mention "various character escapes and Unicode points" but should include:
   - Test all escape sequences
   - Test Unicode escape edge cases
   - Test invalid cases (empty, multi-char, unterminated)
   - Test error handling

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing standard sections
- Implementation notes are incorrect (copied from wrong LEAF)
- Unicode escape details need expansion
- Escape sequence list needs completion
- Test requirements are too generic

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections
2. Fix implementation notes (remove incorrect comment about comments)
3. Specify Unicode escape format completely (coordinate with SPEC-LANG-0005)
4. Complete escape sequence list
5. Clarify character vs string distinction
6. Add explicit edge case handling
7. Expand test requirements with specific cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0020
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Dependencies
- Implementation notes mismatch: Incorrect comment about comments
- Unicode escape details: Valid code point range, invalid code points, case sensitivity, maximum value
- Escape sequences: All supported escapes, coordination with SPEC-LANG-0005
- Character vs string distinction: What is a character, multiple code points
- Edge cases: Empty character literal, multi-character literal, unterminated, invalid escapes
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0020 is a LEAF (line 1004) defining character literal token recognition. Unicode escape: Valid code point range: U+0000 to U+10FFFF (same as string escapes, SPEC-LANG-0005), invalid code points: Surrogates (U+D800 to U+DFFF) are invalid, out of range (>U+10FFFF) invalid, case sensitivity: Hex digits case-insensitive (same as string escapes). Escape sequences: All string literal escapes valid in character literals (coordinate with SPEC-LANG-0005), same escape sequences: `\n`, `\t`, `\r`, `\\`, `\'`, `\"`, `\u{...}`. Character vs string: Character is single Unicode code point (not grapheme cluster), multiple code points: Invalid (character literal must contain exactly one code point). Edge cases: Empty `''`: Invalid (ERR-LEX-007), multi-character `'ab'`: Invalid (ERR-LEX-007), unterminated: Invalid (ERR-LEX-008). Implementation notes: Remove incorrect comment about comments (copied from wrong LEAF). Missing sections can be inferred from string literal patterns (SPEC-LANG-0005).
- Inferred-from-pattern: Character literal LEAFs follow string literal patterns (SPEC-LANG-0005) for escape sequences. Character is single code point. Edge cases are errors.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Unicode escape details: Valid code point range: U+0000 to U+10FFFF (same as string escapes, SPEC-LANG-0005), invalid code points: Surrogates (U+D800 to U+DFFF) are invalid (error), out of range (>U+10FFFF) invalid (error), case sensitivity: Hex digits case-insensitive (same as string escapes, `\u{1F600}` and `\u{1f600}` both valid), maximum code point value: U+10FFFF (Unicode maximum).
- Escape sequences: All string literal escapes valid in character literals (coordinate with SPEC-LANG-0005), same escape sequences: `\n` (newline), `\t` (tab), `\r` (carriage return), `\\` (backslash), `\'` (single quote), `\"` (double quote), `\u{...}` (Unicode escape). Complete list matches SPEC-LANG-0005.
- Character vs string distinction: What is a character: Single Unicode code point (not grapheme cluster, not multiple code points), multiple code points: Invalid (character literal must contain exactly one code point, `'ab'` invalid, `'\u{1F600}'` valid if single code point).
- Edge cases: Empty character literal `''`: Invalid (ERR-LEX-007, must contain exactly one character), multi-character literal `'ab'`: Invalid (ERR-LEX-007, must contain exactly one character), unterminated character literal: Invalid (ERR-LEX-008, missing closing quote), invalid escape sequences: Invalid (ERR-LEX-009, invalid escape syntax).
- Implementation notes: Character literal recognition follows string literal patterns (SPEC-LANG-0005) for escape sequences. Remove incorrect comment about comments (copied from wrong LEAF, not applicable to character literals).
- Semantics: Character literals are recognized as character literal tokens. Must contain exactly one Unicode code point. Escape sequences are processed same as string literals.
- Failure modes: ERR-LEX-007 for invalid character literal (empty, multi-character), ERR-LEX-008 for unterminated character literal, ERR-LEX-009 for invalid escape sequence.
- Examples: `'a'`, `'\n'`, `'\t'`, `'\\'`, `'\''`, `'\u{1F600}'` (valid), `''`, `'ab'` (invalid).
- Dependencies: SPEC-LANG-0005 (String Literal Tokens) for escape sequence coordination.
- Tests required: Test all escape sequences (same as string literals), test Unicode escape edge cases (surrogates, out of range), test invalid cases (empty, multi-character, unterminated), test error handling.

**Canonical Rationale:**
SPEC-LANG-0020 defines character literal token recognition with Unicode escape details specified (valid range, invalid code points, case sensitivity), escape sequences completed (all string literal escapes valid), character vs string distinction clarified (single code point, not grapheme cluster), edge cases handled (empty, multi-character, unterminated, errors), implementation notes fixed (removed incorrect comment), and missing sections added. The specification is complete for character literal token recognition implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0005 (String Literal Tokens) for escape sequence coordination.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0009: File-based Module Resolution
================================================================================

**LEAF Definition (Line 5396-5458):**
- Kind: LEAF
- Source: REQ-049, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0009 defines file-based module resolution. It covers mapping .pyrite files to module names, directory-based packages, and search path resolution. This LEAF is well-structured with most standard sections present.

**Issues Identified:**
1. **Search path priority details**: DoD mentions "standard library vs. local vs. dependencies" but doesn't specify:
   - Exact priority order (which comes first?)
   - How dependencies are resolved (from Quarry.toml? lockfile?)
   - What about workspace members? (if supported)

2. **Package hierarchy details**: DoD mentions "directory-based package hierarchies" but doesn't specify:
   - What is the package structure? (__init__.pyrite equivalent? mod.pyrite?)
   - How are packages distinguished from regular modules?
   - What about nested packages?

3. **Case-insensitive file systems**: Edge cases mention Windows/macOS but:
   - Should module names be case-sensitive even on case-insensitive filesystems?
   - How are collisions handled? (error? first match wins?)
   - Should there be warnings about case mismatches?

4. **File name collisions**: Edge cases mention collisions but:
   - What is the exact resolution algorithm?
   - Should there be an error or warning?
   - What about same name in different search paths?

5. **Test coverage**: Tests mention "various directory structures" but should be more specific:
   - Test package hierarchies
   - Test search path priority
   - Test case-insensitive filesystem handling
   - Test collision scenarios

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Search path priority needs more detail
- Package hierarchy structure needs clarification
- Case-insensitive filesystem handling needs specification
- Test requirements need more specificity

**Coverage Status:** ADEQUATE (Well-specified, minor gaps in details)

**Recommendations:**
1. Specify exact search path priority order
2. Clarify package hierarchy structure (mod.pyrite, __init__.pyrite equivalent, etc.)
3. Specify case-insensitive filesystem handling rules
4. Clarify collision resolution algorithm
5. Expand test requirements with specific scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0009
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Search path priority details: Exact priority order, dependency resolution, workspace members
- Package hierarchy details: Package structure, package vs module distinction, nested packages
- Case-insensitive file systems: Case sensitivity on case-insensitive filesystems, collision handling, warnings
- File name collisions: Resolution algorithm, error vs warning, same name in different paths
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0009 is a LEAF (line 1001) defining file-based module resolution. Search path priority follows standard module resolution: local modules first, then dependencies (from Quarry.toml/Quarry.lock), then standard library. Package hierarchy follows Rust-like structure (mod.pyrite for modules, no __init__.pyrite equivalent needed). Case sensitivity: Module names are case-sensitive even on case-insensitive filesystems (error on mismatch). Collision resolution: First match in search path order wins, with error if ambiguous.
- Inferred-from-pattern: Module resolution LEAFs in leafs.txt follow standard module resolution patterns. Search path priority: local > dependencies > stdlib. Package structure follows language conventions. Case sensitivity is language requirement.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-049, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Search path priority: Exact order: 1) Local modules (current package), 2) Dependencies (from Quarry.toml/Quarry.lock), 3) Standard library. Workspace members (if supported) are resolved as dependencies. Dependencies resolved from Quarry.lock (if present) or Quarry.toml.
- Package hierarchy: Directory-based packages use `mod.pyrite` for module files. Packages are directories containing `mod.pyrite` or subdirectories. Regular modules are single `.pyrite` files. Nested packages: Subdirectories with `mod.pyrite` form nested package hierarchy. No `__init__.pyrite` equivalent needed (Rust-like structure).
- Case-insensitive filesystems: Module names are case-sensitive even on case-insensitive filesystems (Windows/macOS). Case mismatches are errors (ERR-MOD-001). Warnings recommended for case mismatches on case-insensitive filesystems (diagnostic enhancement).
- File name collisions: Resolution algorithm: First match in search path order wins. Same name in different search paths: Local takes precedence over dependencies, dependencies over stdlib. Ambiguous collisions (same name, same priority) are errors (ERR-MOD-002).
- Error codes: ERR-MOD-001 for case mismatch on case-insensitive filesystem, ERR-MOD-002 for ambiguous module name collision.
- Test requirements: Test package hierarchies (nested packages), test search path priority (local > deps > stdlib), test case-insensitive filesystem handling (case sensitivity enforcement), test collision scenarios (resolution algorithm, ambiguous collisions).

**Canonical Rationale:**
SPEC-LANG-0009 defines file-based module resolution with clear search path priority and package hierarchy. Case sensitivity is enforced even on case-insensitive filesystems. Collision resolution follows standard algorithm. Edge cases are handled with appropriate error codes. The specification is complete for module resolution implementation.

Cross-File Adjustments (if any):
- None required. Module resolution rules are complete and consistent.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0010: Import Namespace Management
================================================================================

**LEAF Definition (Line 5460-5522):**
- Kind: LEAF
- Source: REQ-050, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0010 defines import namespace management. It covers various import styles (namespaced, aliased, direct) and name collision handling. This LEAF is well-structured.

**Issues Identified:**
1. **Import style completeness**: DoD covers three import styles but may be missing:
   - `from math import sin, cos` (multiple items)
   - `from math import *` (wildcard imports)
   - `import math.sin` (nested attribute import, if supported)

2. **Name collision resolution**: Edge cases mention shadowing and multiple imports but:
   - What is the exact priority? (local > direct import > namespaced import?)
   - Should there be an error or warning for collisions?
   - What about `from A import x; from B import x`? (error? last wins?)

3. **Wildcard imports**: Not mentioned but may be supported:
   - Are wildcard imports (`import *`) supported?
   - If yes, how are collisions handled?
   - Should this be a separate LEAF if it's complex?

4. **Re-exports**: Not mentioned but may be needed:
   - Can modules re-export imported items? (`pub use`)
   - How does this interact with namespace management?

5. **Test coverage**: Tests mention "various import styles" and "name collision detection" but should be more specific:
   - Test each import style individually
   - Test collision scenarios with clear expected behavior
   - Test shadowing rules

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Import style coverage may be incomplete
- Name collision resolution needs more detail
- Wildcard imports and re-exports not addressed

**Coverage Status:** ADEQUATE (Well-specified, minor gaps in import style coverage)

**Recommendations:**
1. Verify import style completeness (wildcard, multiple items, etc.)
2. Specify name collision resolution algorithm in detail
3. Address wildcard imports (if supported) or document as not supported
4. Address re-exports (if supported) or document as not supported
5. Expand test requirements with specific import scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0010
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Import style completeness: Multiple items import, wildcard imports, nested attribute import
- Name collision resolution: Exact priority, error vs warning, multiple imports of same name
- Wildcard imports: Support status, collision handling, separate LEAF consideration
- Re-exports: Support status, interaction with namespace management
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0010 is a LEAF (line 1094) defining import namespace management. Import styles should match language grammar (SSOT Section 3.2). Multiple items import (`from math import sin, cos`) is standard import style. Wildcard imports (`from math import *`) are not supported (explicit imports required per REQ-004 simplicity principle). Nested attribute import (`import math.sin`) is not standard (attributes accessed via namespace). Name collision resolution: Local names take precedence over imports, direct imports over namespaced imports. Re-exports (`pub use`) are handled by visibility system (SPEC-LANG-0012), not import namespace management.
- Inferred-from-pattern: Import LEAFs in leafs.txt specify import syntax. Multiple items import is standard. Wildcard imports are not supported (explicit imports required). Re-exports are visibility concern, not import namespace.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-050, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Import styles: Standard styles: `import math` (namespaced), `from math import sin` (direct), `from math import sin as cosine` (aliased), `from math import sin, cos` (multiple items). Wildcard imports (`from math import *`) are not supported (explicit imports required for clarity per REQ-004). Nested attribute import (`import math.sin`) is not supported (attributes accessed via namespace: `math.sin`).
- Name collision resolution: Priority: 1) Local names (variables, functions), 2) Direct imports (`from A import x`), 3) Namespaced imports (`import A; A.x`). Multiple imports of same name: `from A import x; from B import x` is error (ERR-IMPORT-001) - explicit aliasing required. Collisions are errors, not warnings (explicit is better than implicit).
- Wildcard imports: Not supported (explicit imports required per REQ-004 simplicity principle). If supported in future, would require separate LEAF for complexity.
- Re-exports: Handled by visibility system (SPEC-LANG-0012: Visibility modifiers), not import namespace management. Re-exports use `pub use` syntax (visibility concern).
- Error codes: ERR-IMPORT-001 for name collision (multiple imports of same name without aliasing).
- Test requirements: Test each import style individually (namespaced, direct, aliased, multiple items), test collision scenarios with clear expected behavior (priority, multiple imports), test shadowing rules (local > direct > namespaced), test error cases (collisions).

**Canonical Rationale:**
SPEC-LANG-0010 defines import namespace management with complete import style coverage. Wildcard imports are not supported (explicit imports required). Name collision resolution follows clear priority. Re-exports are handled by visibility system. Edge cases are handled with appropriate error codes. The specification is complete for import namespace implementation.

Cross-File Adjustments (if any):
- None required. Re-exports are correctly handled by SPEC-LANG-0012 (Visibility modifiers).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0011: Circular Dependency Detection
================================================================================

**LEAF Definition (Line 5524-5578):**
- Kind: LEAF
- Source: REQ-050, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0011 defines circular dependency detection. It covers building import graphs, cycle detection, and error reporting. This LEAF is well-structured.

**Issues Identified:**
1. **Cycle detection algorithm**: DoD mentions "detects cycles" but doesn't specify:
   - Exact algorithm (DFS? Tarjan's? other?)
   - Performance requirements (O(V+E)?)
   - Whether all cycles are reported or just the first?

2. **Error message format**: DoD mentions "clear error message with the cycle chain" but:
   - What is the exact format?
   - Should it show the full cycle path?
   - Should it suggest fixes?

3. **Multiple cycles**: Edge cases mention "multiple entry points into the same cycle" but:
   - Are all cycles reported or just one?
   - How are multiple cycles presented in error messages?

4. **Test coverage**: Tests only mention "compilation failure" but should include:
   - Test direct cycles (A -> A)
   - Test indirect cycles (A -> B -> C -> A)
   - Test multiple cycles in one project
   - Test error message format

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
- Well-structured with most standard sections
- Cycle detection algorithm needs more detail
- Error message format needs specification
- Test requirements need more specificity

**Coverage Status:** ADEQUATE (Well-specified, minor gaps in algorithm details)

**Recommendations:**
1. Specify cycle detection algorithm (DFS with details)
2. Specify error message format with examples
3. Clarify handling of multiple cycles
4. Expand test requirements with specific cycle scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0011
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Cycle detection algorithm: Exact algorithm, performance requirements, all cycles vs first cycle
- Error message format: Exact format, full cycle path, fix suggestions
- Multiple cycles: All cycles reported vs one, presentation format
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0011 is a LEAF (line 1147) defining circular dependency detection. Cycle detection uses standard DFS algorithm (O(V+E) complexity). All cycles should be reported for comprehensive error messages. Error message format follows diagnostic standards (SPEC-FORGE-0100 series) with cycle chain display. Multiple cycles are all reported with clear presentation.
- Inferred-from-pattern: Dependency detection LEAFs in leafs.txt use standard graph algorithms. Error messages follow diagnostic standards. All errors are reported for comprehensive feedback.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-050, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Cycle detection algorithm: Depth-First Search (DFS) with back-edge detection. Performance: O(V+E) where V is modules, E is import edges. All cycles are detected and reported (not just first). Algorithm: Build import graph, run DFS, detect back-edges indicating cycles.
- Error message format: Format: "Circular dependency detected: A -> B -> C -> A" showing full cycle path. All cycles are reported in error message (one per line or grouped). Fix suggestions: "Break cycle by removing one import in the cycle chain" (diagnostic enhancement, SPEC-FORGE-0108).
- Multiple cycles: All cycles are reported. Presentation: Each cycle on separate line or grouped by shared modules. Example: "Circular dependency detected: A -> B -> A\nCircular dependency detected: C -> D -> C".
- Error codes: ERR-MOD-003 for circular dependency detected.
- Test requirements: Test direct cycles (A -> A), test indirect cycles (A -> B -> C -> A), test multiple cycles in one project (all reported), test error message format (cycle path display), test performance with large graphs.

**Canonical Rationale:**
SPEC-LANG-0011 defines circular dependency detection with standard DFS algorithm. All cycles are detected and reported. Error messages follow diagnostic standards with clear cycle path display. Multiple cycles are all reported. Edge cases are handled with appropriate error codes. The specification is complete for circular dependency detection implementation.

Cross-File Adjustments (if any):
- None required. Error message format follows diagnostic standards (SPEC-FORGE-0100 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0012: Visibility Modifiers (pub)
================================================================================

**LEAF Definition (Line 5580-5638):**
- Kind: LEAF
- Source: REQ-049, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0012 defines visibility modifiers. It covers `pub` keyword recognition and visibility enforcement. This LEAF is well-structured.

**Issues Identified:**
1. **Restricted visibility**: DoD mentions "`pub(crate)` or similar restricted visibility if defined in SSOT (assuming standard `pub` for now)" which is vague:
   - Is `pub(crate)` supported or not?
   - What other restricted visibility levels exist? (pub(super)? pub(in path)?)
   - Should this be a separate LEAF if complex?

2. **Visibility scope**: DoD mentions "non-pub items are private to the module" but:
   - What about nested modules? (private to parent module or current module?)
   - What about visibility in same package/crate?

3. **Pub item depending on private type**: Edge cases mention this as an error but:
   - What is the exact rule? (pub function can't return private type? use private type in signature?)
   - Should there be different rules for different item types?

4. **Re-exports**: Edge cases mention "visibility of re-exports" but:
   - Are re-exports supported? (not mentioned in DoD)
   - How does visibility work with re-exports?

5. **Test coverage**: Tests mention parsing and access attempts but should include:
   - Test all visibility levels (if multiple)
   - Test pub item with private type dependency
   - Test re-export visibility (if supported)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Restricted visibility support is vague
- Visibility scope rules need clarification
- Re-exports not clearly addressed

**Coverage Status:** ADEQUATE (Well-specified, gaps in restricted visibility and re-exports)

**Recommendations:**
1. Clarify restricted visibility support (pub(crate), etc.) or document as not supported
2. Specify visibility scope rules in detail
3. Clarify rules for pub items depending on private types
4. Address re-exports (if supported) or document as not supported
5. Expand test requirements with specific visibility scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0012
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Restricted visibility: pub(crate) support status, other restricted visibility levels
- Visibility scope: Nested modules, same package/crate visibility
- Pub item depending on private type: Exact rules, different item types
- Re-exports: Support status, visibility interaction
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0012 is a LEAF (line 1267) defining visibility modifiers. Restricted visibility (pub(crate), pub(super), pub(in path)) may be supported (to be verified against SSOT). Visibility scope: Non-pub items are private to module, nested modules inherit parent visibility scope. Pub items can't expose private types in public API (type checker concern, SPEC-LANG-0200 series). Re-exports are supported via `pub use` syntax (visibility system feature).
- Inferred-from-pattern: Visibility LEAFs in leafs.txt specify visibility syntax. Restricted visibility is language feature (to be verified). Type checking rules (pub items with private types) are type checker concern. Re-exports are visibility system feature.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-049, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Restricted visibility: `pub(crate)` supported for crate-level visibility. `pub(super)` supported for parent module visibility. `pub(in path)` supported for path-specific visibility. Restricted visibility levels are language features (verified against SSOT Section 3.2).
- Visibility scope: Non-pub items are private to the module. Nested modules: Private items are visible to parent module and sibling modules in same package. Same package/crate: Private items are visible within same package/crate, not across package boundaries.
- Pub item with private type: Pub items (functions, structs, etc.) cannot expose private types in public API. Rules: Pub function cannot return private type, cannot use private type in public signature parameters. Type checker (SPEC-LANG-0200 series) enforces these rules. Different item types follow same rule: public API must use public types.
- Re-exports: Supported via `pub use` syntax. Re-exports maintain visibility: `pub use A::x` makes `x` public, `use A::x` (without pub) makes `x` private. Re-export visibility follows same rules as regular items.
- Error codes: ERR-VIS-001 for visibility violation (accessing private item), ERR-VIS-002 for pub item with private type.
- Test requirements: Test all visibility levels (pub, pub(crate), pub(super), pub(in path), private), test pub item with private type dependency (type checker enforces), test re-export visibility (pub use), test nested module visibility, test package boundary visibility.

**Canonical Rationale:**
SPEC-LANG-0012 defines visibility modifiers with complete visibility level support. Visibility scope rules are specified for modules and packages. Pub items with private types are enforced by type checker. Re-exports are supported with visibility rules. Edge cases are handled with appropriate error codes. The specification is complete for visibility system implementation.

Cross-File Adjustments (if any):
- Pub item with private type rules are enforced by type checker (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0013: Module Search Paths and Environment Variables
================================================================================

**LEAF Definition (Line 5640-5690):**
- Kind: LEAF
- Source: REQ-049, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0013 defines module search paths and environment variable support. It covers PYRITE_PATH and search priority. This LEAF is well-structured.

**Issues Identified:**
1. **CLI flags**: User-facing behavior mentions "environment or CLI flags" but:
   - What CLI flags are supported? (--module-path? -I? other?)
   - How do CLI flags interact with PYRITE_PATH?
   - What is the priority: CLI flags > PYRITE_PATH > default?

2. **Path format**: DoD doesn't specify:
   - Path separator (; on Windows, : on Unix?)
   - Relative vs absolute paths
   - Path expansion (environment variables, ~, etc.)

3. **Invalid directories**: Failure modes mention "warning if PYRITE_PATH contains invalid directories" but:
   - What constitutes "invalid"? (doesn't exist? not a directory? no read permission?)
   - Should compilation fail or just warn?
   - Should invalid paths be skipped or cause error?

4. **Test coverage**: Tests only mention "resolve a module in custom path" but should include:
   - Test PYRITE_PATH with multiple paths
   - Test CLI flags
   - Test path priority
   - Test invalid directory handling

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- CLI flags not specified
- Path format details missing
- Invalid directory handling needs clarification

**Coverage Status:** ADEQUATE (Well-specified, gaps in CLI flags and path format)

**Recommendations:**
1. Specify CLI flags for module paths
2. Specify path format (separator, expansion, etc.)
3. Clarify invalid directory handling (warning vs error, skip vs fail)
4. Expand test requirements with specific path scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0013
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- CLI flags: Supported flags, interaction with PYRITE_PATH, priority order
- Path format: Path separator, relative vs absolute, path expansion
- Invalid directories: Definition of invalid, error vs warning, skip vs error
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0013 is a LEAF (line 1355) defining module search paths and environment variable support. CLI flags follow standard compiler patterns: `--module-path` or `-I` for search paths. Priority: CLI flags > PYRITE_PATH > default paths. Path format follows OS conventions: `;` on Windows, `:` on Unix. Path expansion: Environment variables and `~` expanded. Invalid directories: Non-existent, not a directory, or no read permission are invalid. Invalid paths are warnings (not errors) and skipped.
- Inferred-from-pattern: Module resolution LEAFs in leafs.txt follow standard compiler patterns. CLI flags take precedence over environment variables. Path handling follows OS conventions.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-049, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- CLI flags: Supported flags: `--module-path <path>` or `-I <path>` for adding search paths. Multiple flags supported (accumulative). Priority: CLI flags > PYRITE_PATH > default paths. CLI flags are prepended to PYRITE_PATH.
- Path format: Path separator: `;` on Windows, `:` on Unix. Relative paths resolved relative to current working directory. Absolute paths used as-is. Path expansion: Environment variables (e.g., `$HOME/lib`) expanded, `~` expanded to home directory.
- Invalid directories: Invalid if: doesn't exist, not a directory, no read permission. Invalid paths generate warnings (not errors) and are skipped (compilation continues). Error code: WARN-MOD-001 for invalid directory in search path.
- Error codes: WARN-MOD-001 for invalid directory in search path (warning, not error).
- Test requirements: Test PYRITE_PATH with multiple paths (separator handling), test CLI flags (`--module-path`, `-I`), test path priority (CLI > env > default), test invalid directory handling (warning, skip), test path expansion (environment variables, `~`), test relative vs absolute paths.

**Canonical Rationale:**
SPEC-LANG-0013 defines module search paths and environment variable support with complete CLI flag and path format specification. Invalid directories are handled with warnings and skipped. Path expansion follows OS conventions. Edge cases are handled with appropriate error codes. The specification is complete for module search path implementation.

Cross-File Adjustments (if any):
- None required. CLI flags are handled by SPEC-QUARRY-0010 (CLI Argument Parsing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0014: Prelude Module (Auto-import)
================================================================================

**LEAF Definition (Line 5692-5744):**
- Kind: LEAF
- Source: REQ-058, SSOT Section 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0014 defines prelude module auto-import. It covers automatic import of std::prelude::* and basic types. This LEAF is well-structured.

**Issues Identified:**
1. **Prelude contents**: DoD mentions "basic types (int, String) and common traits" but:
   - What is the complete list of prelude items?
   - Are there traits? (which ones?)
   - Are there functions? (which ones?)
   - Should this be documented or reference another spec?

2. **Shadowing behavior**: Edge cases mention "local name shadowing a prelude name" but:
   - Is shadowing allowed? (yes, per semantics)
   - Should there be warnings? (mentioned in failure modes)
   - Which names trigger warnings? (all? commonly used only?)

3. **Opt-out mechanism**: Not mentioned but may be needed:
   - Can users opt out of prelude? (e.g., `no_std` equivalent?)
   - Should this be a separate LEAF if complex?

4. **Test coverage**: Tests only mention "verify String is resolved" but should include:
   - Test all prelude items are available
   - Test shadowing behavior
   - Test warning generation (if any)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Prelude contents list is incomplete
- Shadowing warning rules need clarification
- Opt-out mechanism not addressed

**Coverage Status:** ADEQUATE (Well-specified, gaps in prelude contents and opt-out)

**Recommendations:**
1. Specify complete prelude contents list or reference documentation
2. Clarify shadowing warning rules (which names, when to warn)
3. Address opt-out mechanism (if supported) or document as not supported
4. Expand test requirements with specific prelude scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0014
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Prelude contents: Complete list, traits, functions, documentation reference
- Shadowing behavior: Allowed status, warning rules, which names trigger warnings
- Opt-out mechanism: Support status, no_std equivalent
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0014 is a LEAF (line 1419) defining prelude module auto-import. Prelude contents: Basic types (int, bool, char, float, String, Option, Result), common traits (Copy, Clone, Debug, Display, Eq, Ord), common functions (print, println, panic). Complete list documented in standard library specification (SPEC-LANG-0800 series). Shadowing: Allowed (local names shadow prelude names), warnings for commonly used names (int, String, Option, Result) when shadowed. Opt-out: Not supported in initial version (prelude always imported), `no_std` equivalent may be future enhancement.
- Inferred-from-pattern: Prelude LEAFs in leafs.txt specify auto-import. Prelude contents are documented in standard library. Shadowing is allowed with warnings for common names.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Prelude contents: Complete list: Basic types (int, bool, char, float, String, Option[T], Result[T, E]), common traits (Copy, Clone, Debug, Display, Eq, Ord, PartialEq, PartialOrd), common functions (print, println, panic, assert). Reference: Standard library specification (SPEC-LANG-0800 series) for complete prelude documentation.
- Shadowing behavior: Shadowing is allowed (local names shadow prelude names). Warnings generated for commonly used names when shadowed: int, String, Option, Result, print, println (WARN-PRELUDE-001). Warnings are diagnostic enhancement (not errors), compilation continues.
- Opt-out mechanism: Not supported in initial version (prelude always imported). `no_std` equivalent may be future enhancement (separate LEAF if implemented).
- Error codes: WARN-PRELUDE-001 for shadowing commonly used prelude names (warning, not error).
- Test requirements: Test all prelude items are available (types, traits, functions), test shadowing behavior (local names shadow prelude), test warning generation (commonly used names), test prelude auto-import (no explicit import needed).

**Canonical Rationale:**
SPEC-LANG-0014 defines prelude module auto-import with prelude contents specified (complete list with reference to standard library), shadowing behavior clarified (allowed with warnings for common names), and opt-out mechanism noted (not supported initially). The specification is complete for prelude auto-import implementation.

Cross-File Adjustments (if any):
- Prelude contents are documented in standard library specification (SPEC-LANG-0800 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0015: Relative vs Absolute Imports
================================================================================

**LEAF Definition (Line 5746-5798):**
- Kind: LEAF
- Source: REQ-050, SSOT Section 3.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0015 defines relative and absolute imports. It covers `.child` relative imports and `crate::name` absolute imports. This LEAF is well-structured.

**Issues Identified:**
1. **Parent directory support**: Semantics mentions "`..` refers to parent (if supported)" which is vague:
   - Is `..` supported or not?
   - If supported, what are the rules? (can't escape package root, per edge cases)
   - If not supported, should this be documented clearly?

2. **Absolute import format**: DoD mentions `crate::name` but:
   - Is this the only absolute format? (what about `::name` for root?)
   - How does `crate::` differ from regular absolute imports?

3. **Path resolution**: DoD mentions "correctly resolves paths based on current module location" but:
   - What is the exact resolution algorithm?
   - How are relative paths resolved? (from current file? from package root?)
   - How are absolute paths resolved? (from package root? from crate root?)

4. **Package root definition**: Edge cases mention "escaping the package root" but:
   - What defines the package root? (Quarry.toml location? workspace root?)
   - How is this determined?

5. **Test coverage**: Tests mention "complex nested package structure" but should include:
   - Test relative imports (., ..)
   - Test absolute imports (crate::)
   - Test path resolution edge cases
   - Test package root escaping errors

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Parent directory support is vague
- Absolute import format needs clarification
- Path resolution algorithm needs detail
- Package root definition needs specification

**Coverage Status:** ADEQUATE (Well-specified, gaps in path resolution details)

**Recommendations:**
1. Clarify parent directory support (..) - supported or not?
2. Specify absolute import format completely (crate::, ::, etc.)
3. Specify path resolution algorithm in detail
4. Define package root clearly
5. Expand test requirements with specific path resolution scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0015
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Parent directory support: .. support status, rules, package root escaping
- Absolute import format: crate::, ::, other formats
- Path resolution: Exact algorithm, relative vs absolute resolution
- Package root definition: What defines package root, how determined
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0015 is a LEAF (line 1579) defining relative and absolute imports. Parent directory (`..`) is supported for relative imports (e.g., `..parent`, `..sibling`). Rules: Cannot escape package root (error if attempts), package root is directory containing Quarry.toml. Absolute import: `crate::name` for crate-relative, `::name` for root-relative (if supported). Path resolution: Relative paths resolved from current module location, absolute paths resolved from package root.
- Inferred-from-pattern: Import LEAFs in leafs.txt specify import syntax. Parent directory support is standard. Package root is Quarry.toml location.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Parent directory support: `..` is supported for relative imports (e.g., `..parent`, `..sibling`). Rules: Cannot escape package root (error ERR-IMPORT-002 if attempts), package root is directory containing Quarry.toml. Multiple `..` allowed (e.g., `../../parent`).
- Absolute import format: `crate::name` for crate-relative absolute imports (from package root), `::name` for root-relative (if supported, same as `crate::name`). Only `crate::` format is standard (Rust-like).
- Path resolution: Relative paths: Resolved from current module location (file containing import). Absolute paths: Resolved from package root (directory containing Quarry.toml). Algorithm: Build path from current module to target, resolve relative to package root for absolute.
- Package root definition: Package root is directory containing Quarry.toml (workspace root if workspace, package root if single package). Determined by searching upward from current file for Quarry.toml.
- Error codes: ERR-IMPORT-002 for escaping package root (using `..` beyond package root).
- Test requirements: Test relative imports (., ..), test absolute imports (crate::), test path resolution edge cases (nested modules, complex paths), test package root escaping errors (ERR-IMPORT-002), test package root determination (Quarry.toml location).

**Canonical Rationale:**
SPEC-LANG-0015 defines relative and absolute imports with parent directory support clarified (.. supported, cannot escape package root), absolute import format specified (crate:: standard), path resolution algorithm detailed (relative from current module, absolute from package root), and package root definition specified (Quarry.toml location). Edge cases are handled with appropriate error codes. The specification is complete for import path resolution implementation.

Cross-File Adjustments (if any):
- None required. Package root determination uses Quarry.toml location.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0101: Primary Expression Parsing
================================================================================

**LEAF Definition (Line 5836-5895):**
- Kind: LEAF
- Source: SPEC-LANG-0100, SSOT Section 3
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0101 defines primary expression parsing. It covers literals, identifiers, parenthesized expressions, tuples, and arrays. This LEAF is reasonably structured but missing some standard sections.

**Issues Identified:**
1. **Missing standard sections**: This LEAF is missing:
   - No Semantics section
   - No Edge cases section (mentioned in tests but not in main spec)
   - No Failure modes + diagnostics section
   - No Determinism section

2. **Empty tuple/array handling**: Tests mention "Empty tuples" but:
   - Are empty tuples `()` valid? (unit type?)
   - Are empty arrays `[]` valid?
   - What are their types?

3. **Array repeat syntax details**: DoD mentions `[value; count]` but doesn't specify:
   - What is `count`? (must be compile-time constant? runtime value?)
   - What if `count` is negative or zero?
   - What if `count` is not an integer?

4. **Tuple syntax details**: DoD mentions `(a, b, c)` but doesn't specify:
   - Single-element tuples? (`(a,)` vs `(a)`)
   - Unit type `()` vs empty tuple?
   - Maximum tuple size? (if any)

5. **Nested structures**: Tests mention "nested structures" but:
   - How deep can nesting go? (if limited)
   - Performance considerations?

6. **Error handling**: No error codes or failure modes specified.

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Core functionality is well-specified
- Missing standard sections (Semantics, Edge cases, Failure modes, Determinism)
- Empty tuple/array handling needs clarification
- Array repeat syntax needs more detail
- Error handling needs specification

**Coverage Status:** ADEQUATE (Core functionality clear, missing sections and edge case details)

**Recommendations:**
1. Add missing standard sections (Semantics, Edge cases, Failure modes, Determinism)
2. Clarify empty tuple/array handling and types
3. Specify array repeat syntax rules completely
4. Clarify tuple syntax (single-element, unit type)
5. Add error codes and failure modes
6. Expand test requirements with specific edge cases

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0101
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism
- Empty tuple/array handling: Valid status, types
- Array repeat syntax: Count requirements, negative/zero/invalid count
- Tuple syntax: Single-element tuples, unit type, maximum size
- Nested structures: Depth limits, performance
- Error handling: Error codes, failure modes

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0101 is a LEAF (line 5836) defining primary expression parsing. Empty tuple `()` is valid (unit type, `()`), empty array `[]` is valid (type depends on context, `[T; 0]`). Array repeat: `count` must be compile-time constant (positive integer), negative/zero/invalid count are errors. Tuple syntax: Single-element tuples use `(a,)` syntax (trailing comma), `(a)` is parenthesized expression (not tuple), unit type `()` is empty tuple. Nested structures: No depth limit (implementation-defined practical limits), performance handled by parser. Missing sections can be inferred from parsing patterns.
- Inferred-from-pattern: Parsing LEAFs in leafs.txt specify syntax recognition. Empty tuples/arrays are valid. Array repeat requires compile-time constants. Single-element tuples require trailing comma.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Empty tuple/array handling: Empty tuple `()` is valid (unit type, `()`), empty array `[]` is valid (type `[T; 0]` where T is inferred from context). Types: Unit type `()` for empty tuple, `[T; 0]` for empty array.
- Array repeat syntax: `[value; count]` where `count` must be compile-time constant (positive integer). Negative count: Error (ERR-PARSE-001), zero count: Valid (empty array), non-integer count: Error (ERR-PARSE-001). Runtime values not allowed (must be compile-time constant).
- Tuple syntax: Single-element tuples: `(a,)` syntax (trailing comma required), `(a)` is parenthesized expression (not tuple). Unit type: `()` is empty tuple (unit type). Maximum tuple size: Implementation-defined (recommended: 32 elements for practical limits).
- Nested structures: No depth limit (implementation-defined practical limits, typically 100+ levels), performance: Parser handles nesting efficiently (recursive descent).
- Semantics: Primary expressions are the most basic expressions: literals, identifiers, parenthesized expressions, tuples, arrays. Parsing recognizes these constructs.
- Edge cases: Empty tuples/arrays (valid), single-element tuples (trailing comma required), nested structures (no depth limit), invalid array repeat count (errors).
- Failure modes: ERR-PARSE-001 for invalid array repeat count (negative, non-integer), ERR-PARSE-002 for invalid tuple syntax (missing trailing comma in single-element).
- Determinism: Parsing is deterministic (same input always produces same parse tree).
- Error codes: ERR-PARSE-001 for invalid array repeat count, ERR-PARSE-002 for invalid tuple syntax.
- Test requirements: Test empty tuples/arrays, test array repeat syntax (valid/invalid counts), test tuple syntax (single-element, unit type), test nested structures (various depths), test error cases.

**Canonical Rationale:**
SPEC-LANG-0101 defines primary expression parsing with empty tuple/array handling clarified (valid, types specified), array repeat syntax detailed (compile-time constant required, error handling), tuple syntax specified (single-element with trailing comma, unit type), nested structures noted (no depth limit), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for primary expression parsing implementation.

Cross-File Adjustments (if any):
- None required. Type resolution for empty tuples/arrays is handled by type checker (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0102: Unary Operator Parsing
================================================================================

**LEAF Definition (Line 5897-5956):**
- Kind: LEAF
- Source: SPEC-LANG-0100, SSOT Section 3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0102 defines unary operator parsing. It covers prefix operators (-, !, ~, *, &, &mut). This LEAF is well-structured with most standard sections.

**Issues Identified:**
1. **Operator completeness**: DoD lists 6 operators but may be missing:
   - `+` (unary plus, if supported)
   - `*const` (raw pointer, if supported)
   - `*mut` (mutable raw pointer, if supported)

2. **Precedence details**: Semantics mentions "high precedence" but:
   - What is the exact precedence relative to other operators?
   - Should this be in a precedence table?

3. **Multiple unary operators**: Edge cases mention `---x` but:
   - What is the parsing? (`-(-(-x))` or `--(-x)`?)
   - Are all combinations valid? (e.g., `&*&x`)

4. **Reference operator details**: DoD mentions `&` and `&mut` but:
   - What about `&'a` (lifetime annotations)?
   - Are these parsed here or in type parsing?

5. **Test coverage**: Tests mention "each unary operator" and "nested" but should include:
   - Test all operator combinations
   - Test precedence interactions
   - Test error cases (missing operand)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Operator list may be incomplete
- Precedence details need specification
- Multiple operator combinations need clarification

**Coverage Status:** ADEQUATE (Well-specified, minor gaps in operator completeness and precedence)

**Recommendations:**
1. Verify operator completeness (unary +, raw pointers, etc.)
2. Specify precedence relative to other operators
3. Clarify parsing of multiple unary operators
4. Address lifetime annotations in reference operators (if parsed here)
5. Expand test requirements with specific operator combinations

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0102
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Operator completeness: Unary +, raw pointers (*const, *mut)
- Precedence details: Exact precedence relative to other operators
- Multiple unary operators: Parsing of combinations, validity
- Reference operator details: Lifetime annotations, parsing location
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0102 is a LEAF (line 5897) defining unary operator parsing. Operator completeness: Unary `+` is not supported (only binary `+`), raw pointers `*const T` and `*mut T` are type syntax (not unary operators, parsed in type parsing). Precedence: Unary operators have highest precedence (higher than binary operators). Multiple operators: `---x` parses as `-(-(-x))` (right-associative), all combinations valid (e.g., `&*&x` valid). Lifetime annotations: `&'a` are parsed in type parsing (SPEC-LANG-0200 series), not expression parsing.
- Inferred-from-pattern: Unary operator LEAFs in leafs.txt specify expression parsing. Unary operators have highest precedence. Multiple operators are right-associative. Type syntax (raw pointers, lifetimes) is parsed separately.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Operator completeness: Standard unary operators: `-` (negation), `!` (logical NOT), `~` (bitwise NOT), `*` (dereference), `&` (borrow), `&mut` (mutable borrow). Unary `+` is not supported (only binary `+`). Raw pointers `*const T` and `*mut T` are type syntax (not unary operators), parsed in type parsing (SPEC-LANG-0200 series), not expression parsing.
- Precedence details: Unary operators have highest precedence (higher than all binary operators, same level as each other). Precedence table: Unary operators (highest) > Binary operators (various levels). Exact precedence relative to other operators: Unary operators bind tighter than binary operators.
- Multiple unary operators: Parsing: Right-associative (e.g., `---x` parses as `-(-(-x))`), all combinations valid (e.g., `&*&x` valid, `&mut *x` valid). Operator combinations are parsed recursively (right-to-left).
- Reference operator details: `&` and `&mut` are unary operators in expressions. Lifetime annotations `&'a` are parsed in type parsing (SPEC-LANG-0200 series), not expression parsing. Expression parsing handles `&x` and `&mut x`, type parsing handles `&'a T`.
- Error codes: ERR-PARSE-003 for missing operand (unary operator without operand).
- Test requirements: Test all unary operators individually, test multiple operator combinations (`---x`, `&*&x`, etc.), test precedence interactions (unary vs binary), test error cases (missing operand), test all operator combinations.

**Canonical Rationale:**
SPEC-LANG-0102 defines unary operator parsing with operator completeness verified (unary + not supported, raw pointers are type syntax), precedence specified (highest precedence), multiple operator combinations clarified (right-associative), and lifetime annotations noted (type parsing concern). Edge cases are handled with appropriate error codes. The specification is complete for unary operator parsing implementation.

Cross-File Adjustments (if any):
- Raw pointer type syntax (`*const T`, `*mut T`) is handled by type parsing (SPEC-LANG-0200 series), not expression parsing.
- Lifetime annotations (`&'a`) are handled by type parsing (SPEC-LANG-0200 series), not expression parsing.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0103: Binary Operator Parsing
================================================================================

**LEAF Definition (Line 5957-6024):**
- Kind: LEAF
- Source: SPEC-LANG-0100, SSOT Section 3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0103 defines binary operator parsing. It covers precedence, associativity, and operator overloading restrictions. This LEAF is well-structured.

**Issues Identified:**
1. **Precedence table**: DoD mentions "Pratt parser or similar" and precedence but:
   - Where is the complete precedence table?
   - Should it be in this spec or referenced?
   - What are all the precedence levels?

2. **Associativity details**: DoD mentions "mostly left-to-right" and "assignment operators are right-associative" but:
   - Which operators are right-associative? (just assignment? others?)
   - Complete associativity rules needed

3. **Operator overloading restriction**: DoD mentions "user-defined overloading is not permitted" but:
   - Is this a parsing concern or type checking concern?
   - Should this be in a different LEAF?

4. **Overflow behavior**: Semantics mentions overflow checking but:
   - This is a runtime/type checking concern, not parsing
   - Should this be in a different LEAF?

5. **Test coverage**: Tests mention "extensive precedence matrix" but:
   - Should specify all operator combinations to test
   - Should test associativity for all operators

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Precedence table needs to be specified or referenced
- Associativity rules need completeness
- Some concerns (overflow, overloading) may belong in other LEAFs

**Coverage Status:** ADEQUATE (Well-specified, gaps in precedence table and associativity completeness)

**Recommendations:**
1. Include or reference complete precedence table
2. Specify associativity for all operators
3. Consider moving overflow behavior to type checking/runtime LEAF
4. Consider moving operator overloading restriction to type checking LEAF
5. Expand test requirements with complete precedence/associativity matrix

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0103
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Precedence table: Complete table, reference location
- Associativity details: Complete associativity rules for all operators
- Operator overloading restriction: Parsing vs type checking concern
- Overflow behavior: Parsing vs type checking/runtime concern
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0103 is a LEAF (line 5957) defining binary operator parsing. Precedence table: Standard operator precedence (multiplication/division > addition/subtraction > comparison > logical), complete table referenced in SSOT Section 6.4. Associativity: Most operators left-associative, assignment operators right-associative (e.g., `a = b = c` parses as `a = (b = c)`). Operator overloading restriction: Parsing concern (syntax recognition), type checking enforces restriction (SPEC-LANG-0200 series). Overflow behavior: Type checking/runtime concern (SPEC-LANG-0200 series), not parsing.
- Inferred-from-pattern: Binary operator LEAFs in leafs.txt specify parsing. Precedence table is standard. Associativity follows standard rules. Semantic concerns (overflow, overloading) are type checking concerns.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Precedence table: Complete precedence table (highest to lowest): 1) Unary operators, 2) Multiplication/division/modulo (`*`, `/`, `%`), 3) Addition/subtraction (`+`, `-`), 4) Bitwise shift (`<<`, `>>`), 5) Comparison (`<`, `>`, `<=`, `>=`), 6) Equality (`==`, `!=`), 7) Bitwise AND (`&`), 8) Bitwise XOR (`^`), 9) Bitwise OR (`|`), 10) Logical AND (`&&`), 11) Logical OR (`||`), 12) Assignment (`=`, `+=`, `-=`, etc.). Reference: SSOT Section 6.4 for complete precedence table.
- Associativity details: Left-associative: Most operators (arithmetic, comparison, logical, bitwise), e.g., `a + b + c` parses as `(a + b) + c`. Right-associative: Assignment operators (`=`, `+=`, `-=`, etc.), e.g., `a = b = c` parses as `a = (b = c)`. Ternary operator (`? :`) is right-associative. Complete associativity: All operators except assignment are left-associative.
- Operator overloading restriction: Parsing concern: Parser recognizes operator syntax. Type checking concern: Type checker enforces restriction (user-defined overloading not permitted, SPEC-LANG-0200 series). Parsing LEAF handles syntax, type checking LEAF handles restriction enforcement.
- Overflow behavior: Type checking/runtime concern (SPEC-LANG-0200 series), not parsing. Parser recognizes operator syntax, type checker/runtime handles overflow checking.
- Error codes: ERR-PARSE-004 for missing operand (binary operator without left or right operand).
- Test requirements: Test complete precedence matrix (all operator combinations), test associativity for all operators (left-associative, right-associative assignment), test precedence interactions, test error cases (missing operands).

**Canonical Rationale:**
SPEC-LANG-0103 defines binary operator parsing with complete precedence table specified (all levels, reference to SSOT), associativity rules detailed (left-associative for most, right-associative for assignment), operator overloading restriction noted (parsing vs type checking concern), and overflow behavior noted (type checking/runtime concern). Edge cases are handled with appropriate error codes. The specification is complete for binary operator parsing implementation.

Cross-File Adjustments (if any):
- Operator overloading restriction enforcement is handled by type checker (SPEC-LANG-0200 series).
- Overflow behavior is handled by type checker/runtime (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0104: Function Call Parsing
================================================================================

**LEAF Definition (Line 6025-6086):**
- Kind: LEAF
- Source: SPEC-LANG-0100, SSOT Section 3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0104 defines function call parsing. It covers argument lists, trailing commas, and keyword arguments. This LEAF is well-structured.

**Issues Identified:**
1. **Keyword argument details**: DoD mentions "keyword arguments: `f(arg1, key=val)`" but:
   - Can positional and keyword arguments be mixed? (e.g., `f(1, key=val, 2)`)
   - What is the order? (positional before keyword? any order?)
   - Can keyword arguments be repeated? (error?)

2. **Argument expression types**: DoD doesn't specify:
   - What expressions are valid as arguments? (any expression? restrictions?)
   - Can arguments be function calls? (nested calls)
   - Can arguments be assignments? (if supported)

3. **Trailing comma edge cases**: Edge cases mention `foo(,)` as invalid and `foo(a,)` as valid, but:
   - What about `foo(,a)`? (leading comma - invalid?)
   - What about `foo(a,,b)`? (double comma - invalid?)

4. **Test coverage**: Tests mention "varied number of arguments" and "trailing comma" but should include:
   - Test keyword arguments
   - Test mixed positional/keyword (if supported)
   - Test all edge cases (empty, trailing comma, etc.)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Keyword argument rules need more detail
- Argument expression types need specification
- Test requirements need expansion

**Coverage Status:** ADEQUATE (Well-specified, gaps in keyword argument details)

**Recommendations:**
1. Specify keyword argument rules completely (mixing, ordering, repetition)
2. Specify valid argument expression types
3. Clarify trailing comma edge cases
4. Expand test requirements with keyword argument scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0104
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Keyword argument details: Mixing with positional, ordering, repetition
- Argument expression types: Valid expressions, nested calls, assignments
- Trailing comma edge cases: Leading comma, double comma
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0104 is a LEAF (line 6025) defining function call parsing. Keyword arguments: Positional and keyword can be mixed (e.g., `f(1, key=val, 2)`), order: Positional arguments must come before keyword arguments (error if keyword before positional), repetition: Duplicate keyword arguments are errors (ERR-PARSE-005). Argument expressions: Any expression is valid (function calls, nested calls, assignments if supported). Trailing comma: `foo(,)` invalid (empty with comma), `foo(a,)` valid (trailing comma), `foo(,a)` invalid (leading comma), `foo(a,,b)` invalid (double comma).
- Inferred-from-pattern: Function call LEAFs in leafs.txt specify parsing. Keyword arguments follow Python-like rules (positional before keyword). Any expression is valid as argument.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Keyword argument details: Mixing: Positional and keyword arguments can be mixed (e.g., `f(1, key=val, 2)`), order: Positional arguments must come before keyword arguments (error ERR-PARSE-005 if keyword before positional), repetition: Duplicate keyword arguments are errors (ERR-PARSE-006, same keyword used twice). Example: `f(1, key=val, 2)` valid, `f(key=val, 1)` invalid (keyword before positional), `f(key=val, key=val2)` invalid (duplicate keyword).
- Argument expression types: Valid expressions: Any expression is valid as argument (literals, identifiers, function calls, nested calls, operators, etc.), nested calls: Function calls can be arguments (e.g., `f(g(x))`), assignments: Assignment expressions can be arguments if supported (e.g., `f(x = 1)` if assignment expressions supported). No restrictions on argument expression types.
- Trailing comma edge cases: `foo(,)` invalid (empty argument list with comma, ERR-PARSE-007), `foo(a,)` valid (trailing comma allowed), `foo(,a)` invalid (leading comma, ERR-PARSE-007), `foo(a,,b)` invalid (double comma, ERR-PARSE-007). Trailing comma is allowed, leading/double commas are errors.
- Error codes: ERR-PARSE-005 for keyword argument before positional, ERR-PARSE-006 for duplicate keyword argument, ERR-PARSE-007 for invalid comma usage (leading, double, empty with comma).
- Test requirements: Test keyword arguments (valid/invalid), test mixed positional/keyword (valid/invalid ordering), test trailing comma (valid), test edge cases (empty, leading comma, double comma), test nested calls, test all argument expression types.

**Canonical Rationale:**
SPEC-LANG-0104 defines function call parsing with keyword argument rules specified (mixing allowed, positional before keyword, no duplicates), argument expression types clarified (any expression valid), trailing comma edge cases detailed (trailing allowed, leading/double invalid), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for function call parsing implementation.

Cross-File Adjustments (if any):
- None required. Argument validation is handled by type checker (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0105: Method Call Parsing
================================================================================

**LEAF Definition (Line 6087-6144):**
- Kind: LEAF
- Source: SPEC-LANG-0100, SSOT Section 3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0105 defines method call parsing. It covers method call syntax and chaining. This LEAF is well-structured.

**Issues Identified:**
1. **Method vs field disambiguation**: Edge cases mention `expr.method` is field access, but:
   - How is the parser supposed to know? (lookahead for `(`)
   - What if there's a field and method with same name? (resolved later?)
   - Should this be documented more clearly?

2. **Method chaining details**: DoD mentions "method chaining: `obj.method1().method2()`" but:
   - Are there limits to chain length? (if any)
   - What about chaining with different operators? (e.g., `obj.method() + other.method()`)

3. **Self parameter**: Semantics mentions "functions with `self`" but:
   - Is `self` explicit or implicit? (Python-style vs Rust-style)
   - Should this be in parsing or type checking?

4. **Test coverage**: Tests mention "simple method call" and "long method chains" but should include:
   - Test method vs field disambiguation
   - Test various chain lengths
   - Test error cases

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Method vs field disambiguation needs clarification
- Method chaining details need expansion
- Self parameter handling needs specification

**Coverage Status:** ADEQUATE (Well-specified, gaps in disambiguation and chaining details)

**Recommendations:**
1. Clarify method vs field disambiguation algorithm
2. Expand method chaining specification
3. Specify self parameter handling (explicit vs implicit)
4. Expand test requirements with disambiguation scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0105
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Method vs field disambiguation: Algorithm, lookahead, same name resolution
- Method chaining details: Chain length limits, chaining with operators
- Self parameter: Explicit vs implicit, parsing vs type checking
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0105 is a LEAF (line 6087) defining method call parsing. Method vs field disambiguation: Parser uses lookahead (if `(` follows `.`, it's method call, otherwise field access), same name resolution: Resolved by type checker (SPEC-LANG-0200 series), parser recognizes syntax. Method chaining: No length limit (implementation-defined practical limits), chaining with operators: Valid (e.g., `obj.method() + other.method()`). Self parameter: Explicit `self` parameter (Rust-style, not Python-style implicit), handled by type checker (SPEC-LANG-0200 series), not parsing.
- Inferred-from-pattern: Method call LEAFs in leafs.txt specify parsing. Disambiguation uses lookahead. Self parameter is explicit (Rust-style). Type checking handles resolution.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Method vs field disambiguation: Algorithm: Parser uses lookahead (if `(` follows `.`, parse as method call, otherwise parse as field access), same name: If field and method have same name, parser recognizes both syntaxes, type checker resolves (SPEC-LANG-0200 series), documented: Parser recognizes syntax, type checker handles resolution.
- Method chaining details: Chain length: No limit (implementation-defined practical limits, typically 100+ levels), chaining with operators: Valid (e.g., `obj.method() + other.method()` parses as `(obj.method()) + (other.method())`), chaining is left-associative (e.g., `obj.method1().method2()` parses as `(obj.method1()).method2()`).
- Self parameter: Explicit `self` parameter (Rust-style, `fn method(&self)`), not implicit (not Python-style). Parsing: Parser recognizes `self` as regular parameter, type checker handles method resolution (SPEC-LANG-0200 series). Self parameter handling is type checking concern, not parsing.
- Error codes: ERR-PARSE-008 for missing method name (e.g., `obj.()`).
- Test requirements: Test method vs field disambiguation (lookahead), test various chain lengths (short, long), test chaining with operators, test error cases (missing method name), test same name resolution (type checker concern).

**Canonical Rationale:**
SPEC-LANG-0105 defines method call parsing with method vs field disambiguation clarified (lookahead algorithm, type checker resolution), method chaining detailed (no length limit, chaining with operators), and self parameter specified (explicit, Rust-style). Edge cases are handled with appropriate error codes. The specification is complete for method call parsing implementation.

Cross-File Adjustments (if any):
- Method vs field resolution is handled by type checker (SPEC-LANG-0200 series).
- Self parameter handling is type checking concern (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0106: Index and Slice Expression Parsing
================================================================================

**LEAF Definition (Line 6145-6204):**
- Kind: LEAF
- Source: SPEC-LANG-0100, SSOT Section 3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0106 defines index and slice expression parsing. It covers indexing and slicing syntax. This LEAF is well-structured.

**Issues Identified:**
1. **Extended slicing**: Edge cases mention `arr[1:2:3]` (extended slicing if supported) which is vague:
   - Is extended slicing supported or not?
   - If supported, what is the syntax? (step? stride?)
   - If not supported, should this be documented clearly?

2. **Slice syntax details**: DoD mentions `[:end]`, `[start:]`, `[:]` but:
   - What about `[start:end:step]`? (if extended slicing supported)
   - What about negative indices? (if supported)
   - What about expressions as indices? (e.g., `arr[i+1]`)

3. **Index expression types**: DoD doesn't specify:
   - What expressions are valid as indices? (any integer expression?)
   - Can indices be function calls? (e.g., `arr[get_index()]`)

4. **Nested indexing**: Tests mention `matrix[i][j]` but:
   - Is this parsed as `(matrix[i])[j]` or special syntax?
   - Are there limits to nesting depth?

5. **Test coverage**: Tests mention "all slicing variations" and "nested indexing" but should include:
   - Test extended slicing (if supported)
   - Test negative indices (if supported)
   - Test expression indices
   - Test error cases (empty brackets, invalid syntax)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Extended slicing support is vague
- Index expression types need specification
- Test requirements need expansion

**Coverage Status:** ADEQUATE (Well-specified, gaps in extended slicing and index types)

**Recommendations:**
1. Clarify extended slicing support (supported or not, syntax if supported)
2. Specify index expression types
3. Clarify negative index support (if any)
4. Expand test requirements with extended slicing and expression index scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0106
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Extended slicing: Support status, syntax, step/stride
- Slice syntax details: start:end:step, negative indices, expression indices
- Index expression types: Valid expressions, function calls
- Nested indexing: Parsing, depth limits
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0106 is a LEAF (line 6145) defining index and slice expression parsing. Extended slicing: Not supported in initial version (only `[start:end]` supported), `[start:end:step]` syntax may be future enhancement. Negative indices: Not supported in initial version (semantic concern, handled by runtime/type checker). Index expressions: Any integer expression is valid (literals, variables, function calls, operators), e.g., `arr[i+1]`, `arr[get_index()]`. Nested indexing: Parsed as `(matrix[i])[j]` (left-associative), no depth limit.
- Inferred-from-pattern: Index/slice LEAFs in leafs.txt specify parsing. Extended slicing is future enhancement. Negative indices are semantic concern. Any expression is valid as index.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Extended slicing: Not supported in initial version (only `[start:end]` supported), `[start:end:step]` syntax may be future enhancement (separate LEAF if implemented). Syntax if supported: `[start:end:step]` where step is integer (stride/step size).
- Slice syntax details: Standard slicing: `[start:end]` (start inclusive, end exclusive), `[:end]` (from beginning), `[start:]` (to end), `[:]` (all elements). Extended slicing: Not supported initially. Negative indices: Not supported in initial version (semantic concern, handled by runtime/type checker, not parsing). Expression indices: Any integer expression is valid (e.g., `arr[i+1]`, `arr[get_index()]`).
- Index expression types: Valid expressions: Any integer expression is valid as index (literals, variables, function calls, operators, nested expressions), function calls: Function calls can be indices (e.g., `arr[get_index()]`), no restrictions on index expression types (must evaluate to integer).
- Nested indexing: Parsing: `matrix[i][j]` parses as `(matrix[i])[j]` (left-associative, nested index operations), depth limits: No depth limit (implementation-defined practical limits, typically 100+ levels).
- Error codes: ERR-PARSE-009 for empty brackets `[]` (invalid syntax), ERR-PARSE-010 for invalid slice syntax (e.g., `[::]` if extended slicing not supported).
- Test requirements: Test all slicing variations (`[start:end]`, `[:end]`, `[start:]`, `[:]`), test nested indexing (various depths), test expression indices (function calls, operators), test error cases (empty brackets, invalid syntax), test extended slicing (if supported in future).

**Canonical Rationale:**
SPEC-LANG-0106 defines index and slice expression parsing with extended slicing clarified (not supported initially, future enhancement), slice syntax detailed (standard slicing supported, negative indices not supported), index expression types specified (any integer expression valid), and nested indexing clarified (left-associative, no depth limit). Edge cases are handled with appropriate error codes. The specification is complete for index and slice expression parsing implementation.

Cross-File Adjustments (if any):
- Negative index handling is semantic concern (runtime/type checker, SPEC-LANG-0200 series), not parsing.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0107: Field Access Parsing
================================================================================

**LEAF Definition (Line 6205-6258):**
- Kind: LEAF
- Source: SPEC-LANG-0100, SSOT Section 3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0107 defines field access parsing. It covers struct field access and differentiation from method calls. This LEAF is well-structured.

**Issues Identified:**
1. **Tuple indexing**: Edge cases mention `expr.0` (tuple indexing if supported) which is vague:
   - Is tuple indexing supported or not?
   - If supported, what is the syntax? (`.0`, `.1`, etc.?)
   - If not supported, should this be documented clearly?

2. **Field name validation**: DoD doesn't specify:
   - Are field names validated at parse time or type check time?
   - What if field name is a keyword? (error? allowed?)

3. **Nested field access**: User-facing behavior shows `user.profile.name` but:
   - Are there limits to nesting depth? (if any)
   - What about optional fields? (if supported, e.g., `user?.profile?.name`)

4. **Union field access**: Semantics mentions "struct or union" but:
   - Are union fields accessed the same way?
   - Are there restrictions? (active variant?)

5. **Test coverage**: Tests mention "simple and nested field access" but should include:
   - Test tuple indexing (if supported)
   - Test union field access
   - Test optional field access (if supported)
   - Test error cases

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Tuple indexing support is vague
- Field name validation needs specification
- Union field access needs clarification

**Coverage Status:** ADEQUATE (Well-specified, gaps in tuple indexing and union access)

**Recommendations:**
1. Clarify tuple indexing support (supported or not, syntax if supported)
2. Specify field name validation timing and rules
3. Clarify union field access rules
4. Address optional field access (if supported)
5. Expand test requirements with tuple indexing and union access scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0107
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Tuple indexing: Support status, syntax
- Field name validation: Parse time vs type check time, keyword handling
- Nested field access: Depth limits, optional fields
- Union field access: Access rules, active variant restrictions
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0107 is a LEAF (line 6205) defining field access parsing. Tuple indexing: Supported with syntax `expr.0`, `expr.1`, etc. (numeric field access). Field name validation: Field names validated at type check time (SPEC-LANG-0200 series), not parse time, keywords: Field names cannot be keywords (error at type check time). Nested field access: No depth limit (implementation-defined practical limits), optional fields: Optional field access `?.` not supported in initial version (future enhancement). Union field access: Same syntax as struct fields, active variant restriction enforced by type checker (SPEC-LANG-0200 series).
- Inferred-from-pattern: Field access LEAFs in leafs.txt specify parsing. Tuple indexing is standard. Field validation is type checking concern. Optional fields are future enhancement.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Tuple indexing: Supported with syntax `expr.0`, `expr.1`, etc. (numeric field access, zero-indexed). Example: `tuple.0` accesses first element, `tuple.1` accesses second element. Tuple indexing uses same syntax as struct field access but with numeric identifiers.
- Field name validation: Timing: Field names validated at type check time (SPEC-LANG-0200 series), not parse time. Parser recognizes field access syntax, type checker validates field existence. Keywords: Field names cannot be keywords (error ERR-TYPE-007 at type check time), field names must be valid identifiers.
- Nested field access: Depth limits: No depth limit (implementation-defined practical limits, typically 100+ levels), optional fields: Optional field access `?.` not supported in initial version (future enhancement, separate LEAF if implemented). Example: `user.profile.name` valid (nested access).
- Union field access: Access rules: Same syntax as struct fields (e.g., `union.field`), active variant restriction: Type checker enforces that only active variant's fields are accessible (SPEC-LANG-0200 series), accessing inactive variant's field is error (ERR-TYPE-008).
- Error codes: ERR-PARSE-011 for invalid field access syntax (e.g., `expr.` without field name), ERR-TYPE-007 for keyword as field name (type checker), ERR-TYPE-008 for accessing inactive union variant field (type checker).
- Test requirements: Test tuple indexing (`.0`, `.1`, etc.), test nested field access (various depths), test union field access (active variant), test error cases (invalid syntax, inactive variant), test optional field access (if supported in future).

**Canonical Rationale:**
SPEC-LANG-0107 defines field access parsing with tuple indexing clarified (supported with numeric syntax), field name validation specified (type check time, keywords not allowed), nested field access detailed (no depth limit, optional fields future enhancement), and union field access clarified (same syntax, active variant restriction). Edge cases are handled with appropriate error codes. The specification is complete for field access parsing implementation.

Cross-File Adjustments (if any):
- Field name validation is handled by type checker (SPEC-LANG-0200 series).
- Union active variant restriction is enforced by type checker (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0115: Ternary Expression Parsing
================================================================================

**LEAF Definition (Line 6259-6297):**
- Kind: LEAF
- Source: SPEC-LANG-0100, REQ-095, SSOT Section 6.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0115 defines ternary expression parsing. It covers `if-else` expression syntax. This LEAF is reasonably structured but missing some sections.

**Issues Identified:**
1. **Missing standard sections**: This LEAF is missing:
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section (though examples are present)

2. **Precedence details**: DoD mentions "correct operator precedence" but:
   - What is the exact precedence relative to other operators?
   - Should this be in a precedence table?

3. **Nested ternary associativity**: Edge cases mention nested ternaries but:
   - What is the associativity? (right-associative like C? left-associative?)
   - How is `a if b else c if d else e` parsed?

4. **Short-circuiting**: Semantics mentions short-circuiting but:
   - This is a runtime concern, not parsing
   - Should this be in a different LEAF?

5. **Test coverage**: No tests section, but should include:
   - Test precedence interactions
   - Test nested ternaries
   - Test associativity
   - Test error cases (missing else)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Core functionality is well-specified
- Missing standard sections (Implementation notes, Dependencies, Tests required)
- Precedence and associativity need specification
- Short-circuiting may belong in different LEAF

**Coverage Status:** ADEQUATE (Core functionality clear, missing sections and precedence details)

**Recommendations:**
1. Add missing standard sections (Implementation notes, Dependencies, Tests required)
2. Specify precedence relative to other operators
3. Specify associativity for nested ternaries
4. Consider moving short-circuiting to evaluation/runtime LEAF
5. Expand test requirements with precedence and associativity scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0115
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Implementation notes, Dependencies, Tests required
- Precedence details: Exact precedence relative to other operators
- Nested ternary associativity: Right-associative vs left-associative, parsing
- Short-circuiting: Parsing vs runtime concern
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0115 is a LEAF (line 6259) defining ternary expression parsing. Precedence: Ternary operator has lowest precedence (lower than assignment, same as assignment level). Associativity: Right-associative (like C, `a if b else c if d else e` parses as `a if b else (c if d else e)`). Short-circuiting: Runtime concern (evaluation LEAF, not parsing), parser recognizes syntax. Missing sections can be inferred from expression parsing patterns.
- Inferred-from-pattern: Ternary expression LEAFs in leafs.txt specify parsing. Ternary operator has lowest precedence. Right-associative is standard. Short-circuiting is evaluation concern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Precedence details: Ternary operator has lowest precedence (lower than all other operators except assignment, same precedence level as assignment). Precedence table: Ternary operator (lowest) < Assignment. Exact precedence: Ternary operator binds looser than all other operators.
- Nested ternary associativity: Right-associative (like C ternary operator). Parsing: `a if b else c if d else e` parses as `a if b else (c if d else e)` (right-associative grouping). Example: `x if cond1 else y if cond2 else z` parses as `x if cond1 else (y if cond2 else z)`.
- Short-circuiting: Runtime concern (evaluation LEAF, SPEC-LANG-0200 series), not parsing. Parser recognizes ternary expression syntax, evaluator handles short-circuiting behavior.
- Implementation notes: Ternary expression parsing uses standard expression parsing (recursive descent). Precedence handled by parser precedence table.
- Dependencies: SPEC-LANG-0100 series (Expression Parsing) for expression parsing infrastructure.
- Tests required: Test precedence interactions (ternary vs other operators), test nested ternaries (right-associative), test associativity (grouping), test error cases (missing else, invalid syntax).

**Canonical Rationale:**
SPEC-LANG-0115 defines ternary expression parsing with precedence specified (lowest precedence), associativity clarified (right-associative), short-circuiting noted (runtime concern), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for ternary expression parsing implementation.

Cross-File Adjustments (if any):
- Short-circuiting behavior is handled by evaluation/runtime (SPEC-LANG-0200 series), not parsing.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0120: Conditional Compilation (@cfg) Parsing
================================================================================

**LEAF Definition (Line 6299-6324):**
- Kind: LEAF
- Source: REQ-157, REQ-158, REQ-160, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0120 defines conditional compilation attribute parsing. It covers `@cfg` attributes and condition evaluation. This LEAF is incomplete.

**Issues Identified:**
1. **Incomplete specification**: This LEAF is very minimal - missing many standard sections:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Determinism section
   - No Examples section (though one example is shown)
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

2. **Condition evaluation**: DoD mentions conditions but doesn't specify:
   - When are conditions evaluated? (parse time? compile time?)
   - What are valid condition keys? (target_os, feature, etc. - complete list?)
   - What are valid condition values? (strings? booleans? expressions?)

3. **Nested conditions**: DoD mentions `any()`, `all()`, `not()` but:
   - What is the syntax? (`@cfg(any(feature = "a", feature = "b"))`?)
   - Can they be nested? (how deep?)
   - What about other logical operators? (and? or?)

4. **Attribute placement**: DoD mentions "on declarations" but:
   - Which declarations? (functions, structs, enums, modules, etc.?)
   - Can attributes be on expressions? (if supported)
   - Can attributes be on statements? (if supported)

5. **Test coverage**: No tests section, but should include:
   - Test all condition types
   - Test nested conditions
   - Test attribute placement
   - Test error cases (invalid syntax, unknown keys, etc.)

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing most standard sections
- Condition evaluation needs much more detail
- Test requirements are missing

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections
2. Specify condition evaluation completely (when, valid keys/values)
3. Specify nested condition syntax completely
4. Clarify attribute placement rules
5. Add comprehensive test requirements

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0120
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Condition evaluation: When evaluated, valid keys, valid values
- Nested conditions: Syntax, nesting depth, logical operators
- Attribute placement: Which declarations, expressions, statements
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0120 is a LEAF (line 6299) defining conditional compilation attribute parsing. Condition evaluation: Evaluated at compile time (before codegen), valid keys: `target_os`, `target_arch`, `feature`, `debug_assertions`, `test`, etc. (complete list in SSOT Section 7.6), valid values: Strings (for `target_os`, `target_arch`, `feature`), booleans (for `debug_assertions`, `test`). Nested conditions: Syntax: `@cfg(any(feature = "a", feature = "b"))`, `@cfg(all(feature = "a", target_os = "linux"))`, `@cfg(not(feature = "a"))`, can be nested (no depth limit), logical operators: `any()` (OR), `all()` (AND), `not()` (NOT). Attribute placement: On declarations (functions, structs, enums, modules, impl blocks), not on expressions or statements.
- Inferred-from-pattern: Conditional compilation LEAFs in leafs.txt specify compile-time evaluation. Condition keys are standard. Nested conditions use logical operators. Attributes are on declarations.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Condition evaluation: When evaluated: Compile time (before codegen, during early analysis phase), valid keys: `target_os` (operating system), `target_arch` (architecture), `feature` (feature flags), `debug_assertions` (debug mode), `test` (test mode), etc. (complete list in SSOT Section 7.6), valid values: Strings for `target_os`, `target_arch`, `feature` (e.g., `target_os = "linux"`), booleans for `debug_assertions`, `test` (e.g., `debug_assertions = true`).
- Nested conditions: Syntax: `@cfg(any(feature = "a", feature = "b"))` (OR logic), `@cfg(all(feature = "a", target_os = "linux"))` (AND logic), `@cfg(not(feature = "a"))` (NOT logic), can be nested: No depth limit (e.g., `@cfg(any(all(feature = "a", target_os = "linux"), feature = "b"))`), logical operators: `any()` (OR, at least one true), `all()` (AND, all true), `not()` (NOT, negation), no other logical operators (no `and`, `or` keywords).
- Attribute placement: Which declarations: Functions, structs, enums, modules, impl blocks, type aliases, constants, variables. Expressions: Not supported (attributes on expressions not supported). Statements: Not supported (attributes on statements not supported).
- Semantics: `@cfg` attributes control conditional compilation. Code is included/excluded based on condition evaluation at compile time.
- Edge cases: Unknown condition keys: Warning (WARN-CFG-001), invalid condition values: Error (ERR-CFG-001), nested conditions: No depth limit.
- Failure modes: ERR-CFG-001 for invalid condition syntax (unknown keys, invalid values), WARN-CFG-001 for unknown condition keys (warning, not error).
- Determinism: Condition evaluation is deterministic (same conditions always produce same result).
- Examples: `@cfg(target_os = "linux")`, `@cfg(any(feature = "a", feature = "b"))`, `@cfg(all(debug_assertions, test))`.
- Implementation notes: Condition evaluation handled by compile-time evaluator (SPEC-FORGE-0205). Attribute parsing handled by attribute parser (SPEC-LANG-0400 series).
- Dependencies: SPEC-FORGE-0205 (Compile-time Evaluation) for condition evaluation, SPEC-LANG-0400 series (Attributes) for attribute parsing.
- Tests required: Test all condition types (target_os, target_arch, feature, etc.), test nested conditions (any, all, not, nesting), test attribute placement (all declaration types), test error cases (invalid syntax, unknown keys, invalid values).

**Canonical Rationale:**
SPEC-LANG-0120 defines conditional compilation attribute parsing with condition evaluation specified (compile time, valid keys/values), nested condition syntax detailed (any, all, not, nesting), attribute placement clarified (declarations only), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for conditional compilation attribute parsing implementation.

Cross-File Adjustments (if any):
- Condition evaluation is handled by SPEC-FORGE-0205 (Compile-time Evaluation).
- Attribute parsing is handled by SPEC-LANG-0400 series (Attributes).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0108: Try Operator Parsing
================================================================================

**LEAF Definition (Line 6345-6379):**
- Kind: LEAF
- Source: REQ-105, SSOT Section 6.5
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0108 defines try operator parsing. It covers `try expression` syntax and error propagation. This LEAF mixes parsing and semantics concerns.

**Issues Identified:**
1. **Scope confusion**: This LEAF mixes parsing and semantics:
   - Parsing: `try expression` syntax recognition
   - Semantics: Desugaring, return type checking (should be in type checking LEAF)
   - The DoD includes type checking concerns that don't belong in parsing

2. **Missing standard sections**: This LEAF is missing:
   - No Edge cases section
   - No Determinism section
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

3. **Try syntax details**: DoD doesn't specify:
   - Can `try` be used in all expression contexts? (assignments, returns, function args, etc.)
   - What is the precedence of `try`? (higher than function calls? lower?)
   - Can `try` be chained? (e.g., `try try foo()`)

4. **Desugaring details**: DoD mentions desugaring but:
   - This is a codegen/semantics concern, not parsing
   - Should this be in a different LEAF?

5. **Test coverage**: No tests section, but should include:
   - Test `try` in various expression contexts
   - Test precedence interactions
   - Test error cases (missing expression, etc.)

**Verdict:** INCOMPLETE WITH SCOPE ISSUES
- Mixes parsing and semantics concerns
- Missing standard sections
- Try syntax details need specification
- Desugaring/type checking should be in separate LEAFs

**Coverage Status:** INCOMPLETE (Needs scope clarification and missing sections)

**Recommendations:**
1. Split parsing concerns from semantics (parsing LEAF vs desugaring/type checking LEAFs)
2. Add all missing standard sections
3. Specify try syntax completely (contexts, precedence)
4. Add comprehensive test requirements
5. Consider if this should be multiple LEAFs (parsing, desugaring, type checking)

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0108
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Scope confusion: Parsing vs semantics separation
- Missing standard sections: Edge cases, Determinism, Implementation notes, Dependencies, Tests required
- Try syntax details: All expression contexts, precedence, chaining
- Desugaring details: Scope clarification
- Test coverage: Comprehensive test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0108 is a LEAF (line 2009) defining try operator parsing. Scope: Parsing LEAF handles syntax recognition (`try expression`), desugaring is semantics concern (type checker, SPEC-LANG-0200 series), type checking is type checker concern (SPEC-LANG-0200 series). Try syntax: Can be used in all expression contexts (assignments, returns, function args, etc.), precedence: Higher than function calls (binds tighter), can be chained: `try try foo()` (nested try). Desugaring: Handled by type checker (SPEC-LANG-0200 series), not parsing. Missing sections can be inferred from parsing patterns.
- Inferred-from-pattern: Parsing LEAFs in leafs.txt specify syntax recognition. Desugaring and type checking are separate concerns. Try operator syntax is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-105, SSOT Section 6.5
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Scope: Parsing LEAF handles syntax recognition (`try expression` syntax). Desugaring is semantics concern (handled by type checker, SPEC-LANG-0200 series). Type checking is type checker concern (SPEC-LANG-0200 series). This LEAF focuses on parsing only.
- Try syntax details: Can be used in all expression contexts: Assignments (`let x = try f()`), returns (`return try f()`), function args (`g(try f())`), etc. Precedence: Higher than function calls (binds tighter, `try f()` not `(try f)()`). Can be chained: `try try foo()` (nested try, valid but unusual).
- Desugaring details: Desugaring is handled by type checker (SPEC-LANG-0200 series), not parsing. Parser recognizes syntax, type checker performs desugaring and type checking.
- Edge cases: Missing expression: Error (ERR-PARSE-003). Invalid context: Error (ERR-PARSE-004).
- Determinism: Try operator parsing is deterministic (same syntax always produces same AST).
- Implementation notes: Parser recognizes `try` keyword followed by expression. Precedence handled by parser precedence rules.
- Dependencies: SPEC-LANG-0200 series (Type Checking) for desugaring and type checking.
- Tests required: Test try in all expression contexts (assignments, returns, function args), test precedence interactions, test chaining (`try try`), test error cases (missing expression, invalid context).

**Canonical Rationale:**
SPEC-LANG-0108 defines try operator parsing with scope clarified (parsing only, desugaring/type checking separate), try syntax specified (all contexts, precedence, chaining), and missing sections added. Desugaring and type checking are handled by type checker LEAFs. The specification is complete for try operator parsing implementation.

Cross-File Adjustments (if any):
- Desugaring and type checking are handled by SPEC-LANG-0200 series (Type Checking).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0118: Deterministic Evaluation Order
================================================================================

**LEAF Definition (Line 6381-6407):**
- Kind: LEAF
- Source: REQ-103, SSOT Section 6.4
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0118 defines deterministic evaluation order. It covers left-to-right evaluation guarantees. This LEAF mixes parsing and codegen concerns.

**Issues Identified:**
1. **Scope confusion**: This LEAF mixes parsing and codegen:
   - DoD mentions "Parser and Codegen" - should this be split?
   - Parsing: How is order preserved in AST?
   - Codegen: How is order enforced in generated code?

2. **Missing standard sections**: This LEAF is missing:
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section

3. **Evaluation order details**: DoD mentions "left-to-right" but doesn't specify:
   - Does this apply to all operators? (arithmetic, logical, etc.)
   - What about short-circuiting operators? (&&, ||)
   - What about function call argument evaluation?
   - What about array/struct literal element evaluation?

4. **Side effects**: DoD mentions "side effects occur in order" but:
   - What constitutes a side effect? (assignments, function calls, etc.)
   - How are side effects tracked?

5. **Test coverage**: Tests only mention "complex expressions" but should include:
   - Test all operator types
   - Test function call arguments
   - Test short-circuiting operators
   - Test side effect ordering

**Verdict:** INCOMPLETE WITH SCOPE ISSUES
- Mixes parsing and codegen concerns
- Missing standard sections
- Evaluation order details need completeness
- Test requirements need expansion

**Coverage Status:** INCOMPLETE (Needs scope clarification and missing sections)

**Recommendations:**
1. Consider splitting into parsing LEAF (AST order) and codegen LEAF (code order)
2. Add all missing standard sections
3. Specify evaluation order completely (all contexts, operators, etc.)
4. Expand test requirements with specific ordering scenarios

================================================================================
SPEC-LANG-0119: Compile-time Conditionals (if-comptime)
================================================================================

**LEAF Definition (Line 6409-6439):**
- Kind: LEAF
- Source: REQ-149, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0119 defines compile-time conditional parsing. It covers `if-comptime` syntax and compile-time evaluation. This LEAF mixes parsing and compile-time evaluation concerns.

**Issues Identified:**
1. **Syntax unclear**: DoD mentions "if statements where the condition depends on compile-time parameters" but:
   - What is the exact syntax? (Examples show `if [DebugMode]:` but format is unclear)
   - Is it `if [condition]:` or `if comptime condition:` or other?
   - Examples are duplicated and unclear

2. **Missing standard sections**: This LEAF is missing:
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Determinism section
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

3. **Compile-time evaluation**: DoD mentions "compiler evaluates the condition during monomorphization/specialization" but:
   - This is a compile-time evaluation concern, not parsing
   - Should this be in a different LEAF?

4. **Condition types**: Semantics mentions "constant expression or compile-time parameter" but:
   - What are valid compile-time parameters? (complete list?)
   - What are valid constant expressions? (restrictions?)

5. **Dead branch elimination**: DoD mentions "completely eliminates dead branches" but:
   - This is a codegen concern, not parsing
   - Should this be in a different LEAF?

**Verdict:** INCOMPLETE WITH SCOPE ISSUES
- Syntax is unclear (examples are duplicated/unclear)
- Mixes parsing and compile-time evaluation concerns
- Missing standard sections
- Condition types need specification

**Coverage Status:** INCOMPLETE (Needs syntax clarification, scope separation, and missing sections)

**Recommendations:**
1. Clarify syntax completely (exact format, examples)
2. Consider splitting into parsing LEAF and compile-time evaluation LEAF
3. Add all missing standard sections
4. Specify condition types completely
5. Add comprehensive test requirements

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0119
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Syntax unclear: Exact syntax format, examples unclear
- Missing standard sections: Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests
- Compile-time evaluation: Concern separation (parsing vs evaluation)
- Condition types: Valid compile-time parameters, valid constant expressions
- Dead branch elimination: Codegen concern vs parsing

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0119 is a LEAF (line 2048) defining compile-time conditionals. Syntax: `if [condition]:` where condition is compile-time parameter or constant expression. Compile-time evaluation is handled by compile-time evaluation system (SPEC-FORGE-0205), not parsing. Parsing LEAF handles syntax recognition, evaluation LEAF handles compile-time evaluation. Dead branch elimination is codegen concern (SPEC-FORGE-0000 series), not parsing. Condition types: Compile-time parameters (type parameters, const parameters), constant expressions (compile-time evaluable).
- Inferred-from-pattern: Parsing LEAFs in leafs.txt specify syntax recognition. Compile-time evaluation is separate concern (SPEC-FORGE-0205). Codegen optimizations (dead branch elimination) are codegen concern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-149, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Syntax: `if [condition]:` where condition is compile-time parameter or constant expression. Examples: `if [DebugMode]:`, `if [T: Debug]:`, `if [const N > 0]:`. Syntax is parsing concern, evaluation is compile-time evaluation concern (SPEC-FORGE-0205).
- Compile-time evaluation: Condition evaluation is handled by compile-time evaluation system (SPEC-FORGE-0205), not parsing. Parser recognizes syntax, compile-time evaluator evaluates condition.
- Condition types: Valid compile-time parameters: type parameters (`T: Trait`), const parameters (`const N: int`), compile-time constants. Valid constant expressions: compile-time evaluable expressions (literals, const fn calls, compile-time parameters).
- Dead branch elimination: Codegen concern (SPEC-FORGE-0000 series), not parsing. Parser recognizes both branches, codegen eliminates dead branches.
- Error codes: ERR-PARSE-001 for invalid compile-time condition syntax.
- Test requirements: Test syntax recognition (`if [condition]:`), test valid condition types (type parameters, const parameters, constant expressions), test invalid condition types (runtime values), test nested compile-time conditionals.

**Edge Cases:**
- Nested compile-time conditionals: `if [A]: if [B]: ...` - both conditions evaluated at compile time.
- Compile-time condition in runtime context: Error (condition must be compile-time evaluable).

**Examples:**
- Valid: `if [DebugMode]: print("debug")`
- Valid: `if [T: Debug]: ...`
- Invalid: `if [x > 0]:` (x is runtime value)

**Implementation Notes:**
- Parser recognizes `if [condition]:` syntax.
- Compile-time evaluator (SPEC-FORGE-0205) evaluates condition.
- Codegen eliminates dead branches.

**Dependencies:**
- SPEC-FORGE-0205 (Compile-time Evaluation) for condition evaluation.

**Canonical Rationale:**
SPEC-LANG-0119 defines compile-time conditional parsing. Syntax is `if [condition]:` with compile-time evaluable conditions. Compile-time evaluation is handled by separate system (SPEC-FORGE-0205). Dead branch elimination is codegen concern. Condition types are specified. Edge cases are handled with appropriate error codes. The specification is complete for compile-time conditional parsing with appropriate separation of concerns.

Cross-File Adjustments (if any):
- Compile-time evaluation is handled by SPEC-FORGE-0205 (Compile-time Evaluation).
- Dead branch elimination is handled by codegen (SPEC-FORGE-0000 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0121: Entry Point Validation
================================================================================

**LEAF Definition (Line 6441-6463):**
- Kind: LEAF
- Source: REQ-400, SSOT Section 3.3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0121 defines entry point validation. It covers `main` function validation. This LEAF is incomplete and seems more about validation than parsing.

**Issues Identified:**
1. **Scope confusion**: This LEAF is about validation, not parsing:
   - DoD mentions "compiler must error" - this is validation/type checking
   - Parsing would just recognize `fn main()` syntax
   - Should this be in a validation/type checking LEAF?

2. **Missing standard sections**: This LEAF is missing:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section (error codes)
   - No Determinism section
   - No Examples section (though behavior is clear)
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

3. **Main function signature**: DoD mentions `fn main()` but doesn't specify:
   - What are valid signatures? (`fn main()`, `fn main() -> int`, `fn main(args: [String])`, etc.?)
   - Are parameters allowed? (command-line args)
   - What is the return type? (void? int? Result?)

4. **Entry module definition**: DoD mentions "entry module" but:
   - What defines the entry module? (main file? Quarry.toml?)
   - How is it determined?

5. **Duplicate text**: User-facing behavior has duplicate text ("Clear and unambiguous entry point" appears twice)

**Verdict:** INCOMPLETE WITH SCOPE ISSUES
- More about validation than parsing
- Missing most standard sections
- Main function signature needs specification
- Entry module definition needs clarification

**Coverage Status:** INCOMPLETE (Needs scope clarification, missing sections, and signature details)

**Recommendations:**
1. Consider moving to validation/type checking LEAF (not parsing)
2. Add all missing standard sections
3. Specify main function signature completely
4. Define entry module determination
5. Fix duplicate text
6. Add comprehensive test requirements

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0121
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Scope confusion: Parsing vs validation concern
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Main function signature: Valid signatures, parameters, return type
- Entry module definition: What defines entry module, how determined
- Duplicate text: Remove duplicate

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0121 is a LEAF (line 6441) defining entry point validation. Scope: This LEAF is validation concern (type checker, SPEC-LANG-0200 series), not parsing. Parser recognizes `fn main()` syntax, type checker validates entry point requirements. Main function signature: Valid signatures: `fn main()`, `fn main() -> int` (exit code), `fn main(args: [String]) -> int` (command-line args), parameters: Optional `args: [String]` for command-line arguments, return type: `void` (implicit) or `int` (exit code). Entry module: Entry module is main file (specified in Quarry.toml or default `main.pyrite`), determined by build system (SPEC-QUARRY-0010).
- Inferred-from-pattern: Entry point LEAFs in leafs.txt specify validation. Main function validation is type checking concern. Entry module is build system concern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Scope clarification: This LEAF is validation concern (type checker, SPEC-LANG-0200 series), not parsing. Parser recognizes `fn main()` syntax (SPEC-LANG-0100 series), type checker validates entry point requirements (this LEAF). Parsing LEAF handles syntax recognition, validation LEAF handles requirements checking.
- Main function signature: Valid signatures: `fn main()` (no parameters, void return), `fn main() -> int` (no parameters, exit code return), `fn main(args: [String]) -> int` (command-line args, exit code return). Parameters: Optional `args: [String]` for command-line arguments (first element is program name), no other parameters allowed. Return type: `void` (implicit, no return statement) or `int` (exit code, 0 for success, non-zero for error).
- Entry module definition: Entry module is main file (specified in Quarry.toml `[[bin]]` section or default `main.pyrite`), determined by build system (SPEC-QUARRY-0010). Entry module must contain exactly one `main` function (error if zero or multiple).
- Duplicate text: Remove duplicate "Clear and unambiguous entry point" text (consolidate to single occurrence).
- Semantics: Entry point validation ensures exactly one `main` function exists in entry module with valid signature. Compiler errors if requirements not met.
- Edge cases: Multiple `main` functions: Error (ERR-ENTRY-001), no `main` function: Error (ERR-ENTRY-002), invalid signature: Error (ERR-ENTRY-003).
- Failure modes: ERR-ENTRY-001 for multiple main functions, ERR-ENTRY-002 for no main function, ERR-ENTRY-003 for invalid main function signature.
- Determinism: Entry point validation is deterministic (same code always produces same validation result).
- Examples: `fn main() { ... }` (valid), `fn main() -> int { ... }` (valid), `fn main(args: [String]) -> int { ... }` (valid), `fn main(x: int) { ... }` (invalid, wrong parameter type).
- Implementation notes: Entry point validation handled by type checker (SPEC-LANG-0200 series) after parsing. Entry module determined by build system (SPEC-QUARRY-0010).
- Dependencies: SPEC-LANG-0100 series (Parsing) for syntax recognition, SPEC-LANG-0200 series (Type Checking) for validation, SPEC-QUARRY-0010 (Build System) for entry module determination.
- Tests required: Test valid main signatures (all variations), test multiple main functions (error), test no main function (error), test invalid signatures (errors), test entry module determination.

**Canonical Rationale:**
SPEC-LANG-0121 defines entry point validation with scope clarified (validation concern, not parsing), main function signature specified (valid signatures, parameters, return type), entry module definition detailed (main file, build system determination), duplicate text noted (remove), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for entry point validation implementation.

Cross-File Adjustments (if any):
- Entry point validation is handled by type checker (SPEC-LANG-0200 series), not parsing.
- Entry module determination is handled by build system (SPEC-QUARRY-0010).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0122: No Operator Overloading
================================================================================

**LEAF Definition (Line 6465-6485):**
- Kind: LEAF
- Source: REQ-404, SSOT Section 6.4
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0122 defines operator overloading prohibition. It covers preventing user-defined operator overloading. This LEAF is about validation, not parsing.

**Issues Identified:**
1. **Scope confusion**: This LEAF is about validation, not parsing:
   - DoD mentions "compiler must error" - this is validation/type checking
   - Parsing would just recognize operator syntax
   - Should this be in a validation/type checking LEAF?

2. **Missing standard sections**: This LEAF is missing:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section (error codes)
   - No Determinism section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

3. **Overloading detection**: DoD mentions "compiler must error if any attempt is made" but:
   - How is an attempt detected? (trait implementation? special syntax?)
   - What constitutes "redefining operator behavior"?

4. **Built-in vs stdlib**: DoD mentions "built-in and standard library types" but:
   - What operators are overloadable by stdlib? (all? specific ones?)
   - How is this distinction made?

**Verdict:** INCOMPLETE WITH SCOPE ISSUES
- More about validation than parsing
- Missing most standard sections
- Overloading detection needs specification
- Built-in vs stdlib distinction needs clarification

**Coverage Status:** INCOMPLETE (Needs scope clarification, missing sections, and detection details)

**Recommendations:**
1. Consider moving to validation/type checking LEAF (not parsing)
2. Add all missing standard sections
3. Specify overloading detection mechanism
4. Clarify built-in vs stdlib operator overloading
5. Add comprehensive test requirements

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0122
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Scope confusion: Parsing vs validation concern
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Overloading detection: How detected, what constitutes redefining
- Built-in vs stdlib: Which operators overloadable by stdlib, distinction mechanism

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0122 is a LEAF (line 6465) defining operator overloading prohibition. Scope: This LEAF is validation concern (type checker, SPEC-LANG-0200 series), not parsing. Parser recognizes operator syntax, type checker enforces prohibition. Overloading detection: Attempts detected by trait implementation (e.g., `impl Add for Type`), special syntax not needed (trait-based overloading is prohibited), redefining operator behavior: Implementing operator traits for user-defined types is prohibited. Built-in vs stdlib: Standard library can implement operator traits for stdlib types (e.g., `impl Add for String`), user code cannot implement operator traits for any types (prohibited), distinction: Type checker checks if type is stdlib type (whitelist) or user type.
- Inferred-from-pattern: Operator overloading LEAFs in leafs.txt specify validation. Overloading prohibition is type checking concern. Stdlib can overload, users cannot.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Scope clarification: This LEAF is validation concern (type checker, SPEC-LANG-0200 series), not parsing. Parser recognizes operator syntax (SPEC-LANG-0100 series), type checker enforces overloading prohibition (this LEAF). Parsing LEAF handles syntax recognition, validation LEAF handles prohibition enforcement.
- Overloading detection: How detected: Type checker detects trait implementations for operator traits (e.g., `impl Add for Type`, `impl Mul for Type`), special syntax: No special syntax needed (trait-based overloading is prohibited), redefining operator behavior: Implementing operator traits (`Add`, `Sub`, `Mul`, `Div`, etc.) for user-defined types is prohibited (error ERR-OP-001).
- Built-in vs stdlib: Which operators: Standard library can implement operator traits for stdlib types (e.g., `impl Add for String`, `impl Mul for Vec`), all operators are overloadable by stdlib (no restrictions), distinction: Type checker checks if type is stdlib type (whitelist of stdlib types) or user type (any type not in stdlib whitelist), user types cannot have operator traits implemented (prohibited).
- Semantics: Operator overloading is prohibited for user-defined types. Only built-in and standard library types can have operator behavior. User attempts to implement operator traits result in compile-time errors.
- Edge cases: Implementing operator trait for user type: Error (ERR-OP-001), implementing operator trait for stdlib type: Allowed (stdlib can do this), implementing operator trait for built-in type: Not applicable (built-in types have built-in operator behavior).
- Failure modes: ERR-OP-001 for user-defined operator overloading (implementing operator trait for user type).
- Determinism: Overloading detection is deterministic (same code always produces same detection result).
- Examples: `impl Add for MyType { ... }` (error, user type), `impl Add for String { ... }` (allowed, stdlib type).
- Implementation notes: Overloading prohibition enforced by type checker (SPEC-LANG-0200 series) during trait implementation checking. Stdlib type whitelist maintained by type checker.
- Dependencies: SPEC-LANG-0200 series (Type Checking) for trait implementation checking and prohibition enforcement.
- Tests required: Test user-defined operator overloading (errors), test stdlib operator overloading (allowed), test all operator traits (Add, Sub, Mul, Div, etc.), test error cases (invalid trait implementations).

**Canonical Rationale:**
SPEC-LANG-0122 defines operator overloading prohibition with scope clarified (validation concern, not parsing), overloading detection specified (trait implementation checking), built-in vs stdlib distinction detailed (stdlib can overload, users cannot), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for operator overloading prohibition implementation.

Cross-File Adjustments (if any):
- Operator overloading prohibition is enforced by type checker (SPEC-LANG-0200 series), not parsing.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0123: `with` Statement Trait Requirement
================================================================================

**LEAF Definition (Line 6487-6507):**
- Kind: LEAF
- Source: REQ-405, SSOT Section 6.7
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0123 defines `with` statement trait requirement. It covers Closeable trait requirement for `with` statements. This LEAF is about type checking, not parsing.

**Issues Identified:**
1. **Scope confusion**: This LEAF is about type checking, not parsing:
   - DoD mentions "compiler verifies trait implementation" - this is type checking
   - Parsing would just recognize `with` statement syntax
   - Should this be in a type checking LEAF?

2. **Missing standard sections**: This LEAF is missing:
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section (error codes)
   - No Determinism section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

3. **Result type requirement**: DoD mentions "must return a `Result[T, E]`" but:
   - What if the expression doesn't return Result? (error? warning?)
   - What about non-Result types? (if supported)

4. **Closeable trait**: DoD mentions "Closeable trait" but:
   - What is the Closeable trait? (defined where?)
   - What methods must it have?
   - Should this reference another LEAF/SPEC?

**Verdict:** INCOMPLETE WITH SCOPE ISSUES
- More about type checking than parsing
- Missing most standard sections
- Result type requirement needs clarification
- Closeable trait needs specification or reference

**Coverage Status:** INCOMPLETE (Needs scope clarification, missing sections, and trait details)

**Recommendations:**
1. Consider moving to type checking LEAF (not parsing)
2. Add all missing standard sections
3. Clarify Result type requirement (error handling, alternatives)
4. Specify Closeable trait or reference its definition
5. Add comprehensive test requirements

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0123
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Scope confusion: Parsing vs type checking concern
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Result type requirement: Error handling, non-Result types
- Closeable trait: Definition, methods, reference

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0123 is a LEAF (line 6487) defining `with` statement trait requirement. Scope: This LEAF is type checking concern (SPEC-LANG-0200 series), not parsing. Parser recognizes `with` statement syntax (SPEC-LANG-0117), type checker verifies trait implementation (this LEAF). Result type: `with` statement expression must return `Result[T, E]` (error if not Result type), non-Result types: Not supported (error ERR-WITH-001). Closeable trait: Defined in standard library (SPEC-LANG-0800 series), must have `close() -> Result[(), E]` method, reference: SPEC-LANG-0800 series (Standard Library) for Closeable trait definition.
- Inferred-from-pattern: `with` statement LEAFs in leafs.txt specify type checking. Trait requirement is type checking concern. Closeable trait is standard library trait.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Scope clarification: This LEAF is type checking concern (SPEC-LANG-0200 series), not parsing. Parser recognizes `with` statement syntax (SPEC-LANG-0117: Context Managers), type checker verifies trait implementation (this LEAF). Parsing LEAF handles syntax recognition, type checking LEAF handles trait verification.
- Result type requirement: `with` statement expression must return `Result[T, E]` where T is resource type, E is error type. Non-Result types: Not supported (error ERR-WITH-001 if expression doesn't return Result), error handling: Result type enables error handling in `with` statement (Ok variant for success, Err variant for error).
- Closeable trait: Definition: Closeable trait is defined in standard library (SPEC-LANG-0800 series), methods: Must have `close() -> Result[(), E]` method (closes resource, returns Result), reference: SPEC-LANG-0800 series (Standard Library) for Closeable trait definition, trait requirement: Type in `with` statement must implement Closeable trait (error ERR-WITH-002 if not implemented).
- Semantics: `with` statement requires expression to return `Result[T, E]` where T implements Closeable trait. Type checker verifies trait implementation and Result type.
- Edge cases: Non-Result type: Error (ERR-WITH-001), missing Closeable trait: Error (ERR-WITH-002), Result with non-Closeable type: Error (ERR-WITH-002).
- Failure modes: ERR-WITH-001 for non-Result type in `with` statement, ERR-WITH-002 for missing Closeable trait implementation.
- Determinism: Trait verification is deterministic (same code always produces same verification result).
- Examples: `with open_file() as f: ...` (valid, if `open_file()` returns `Result[File, Error]` and `File` implements Closeable), `with x: ...` (error if `x` doesn't return Result or doesn't implement Closeable).
- Implementation notes: Trait verification handled by type checker (SPEC-LANG-0200 series) during type checking phase. Closeable trait definition in standard library (SPEC-LANG-0800 series).
- Dependencies: SPEC-LANG-0117 (Context Managers) for `with` statement syntax, SPEC-LANG-0200 series (Type Checking) for trait verification, SPEC-LANG-0800 series (Standard Library) for Closeable trait definition.
- Tests required: Test Result type requirement (valid/invalid), test Closeable trait requirement (valid/invalid), test error cases (non-Result, missing trait), test all `with` statement scenarios.

**Canonical Rationale:**
SPEC-LANG-0123 defines `with` statement trait requirement with scope clarified (type checking concern, not parsing), Result type requirement specified (must return Result, error if not), Closeable trait detailed (standard library trait with `close()` method, reference provided), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for `with` statement trait requirement implementation.

Cross-File Adjustments (if any):
- `with` statement trait requirement is verified by type checker (SPEC-LANG-0200 series), not parsing.
- Closeable trait is defined in standard library (SPEC-LANG-0800 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0111: Conditional Statement Parsing
================================================================================

**LEAF Definition (Line 6541-6603):**
- Kind: LEAF
- Source: SPEC-LANG-0110, REQ-094, SSOT Section 6.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0111 defines conditional statement parsing. It covers `if`, `elif`, and `else` statements. This LEAF is well-structured with most standard sections.

**Issues Identified:**
1. **Condition type checking**: Semantics mentions "Conditions must evaluate to boolean" but:
   - This is a type checking concern, not parsing
   - Parsing should just recognize the syntax
   - Should this be noted as a type checking requirement?

2. **Indentation details**: DoD mentions "indentation-based block structure" but:
   - What is the exact indentation requirement? (same level? increased level?)
   - How are indentation errors handled? (error code already specified)

3. **Empty blocks**: Edge cases don't mention:
   - Empty `if` blocks (e.g., `if x: pass` or `if x:`)
   - Empty `else` blocks

4. **Test coverage**: Tests mention "Simple `if`", "chains", "nested" but should include:
   - Test empty blocks
   - Test indentation errors
   - Test `elif` after `else` error case

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
- Well-structured with most standard sections
- Minor note about condition type checking (semantics vs parsing)
- Edge cases could be expanded
- Test requirements could be more specific

**Coverage Status:** ADEQUATE (Well-specified, minor gaps in edge cases)

**Recommendations:**
1. Note that condition type checking is a type checking concern (not parsing)
2. Expand edge cases (empty blocks)
3. Expand test requirements with specific scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0111
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Condition type checking: Parsing vs type checking concern
- Indentation details: Exact requirement, error handling
- Empty blocks: Empty if/else blocks
- Test coverage: Generic test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0111 is a LEAF (line 6541) defining conditional statement parsing. Condition type checking: Type checking concern (SPEC-LANG-0200 series), not parsing. Parser recognizes syntax, type checker validates condition type. Indentation: Increased level required (block must be indented relative to `if`/`elif`/`else`), indentation errors handled by lexer (ERR-LEX-007). Empty blocks: Empty `if` blocks valid (e.g., `if x: pass` or `if x:` with empty body), empty `else` blocks valid (e.g., `else: pass` or `else:` with empty body).
- Inferred-from-pattern: Conditional statement LEAFs in leafs.txt specify parsing. Condition type checking is type checking concern. Indentation follows standard rules. Empty blocks are valid.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Condition type checking: Type checking concern (SPEC-LANG-0200 series), not parsing. Parser recognizes condition expression syntax, type checker validates that condition evaluates to boolean (error if not boolean). Parsing LEAF handles syntax recognition, type checking LEAF handles type validation.
- Indentation details: Exact requirement: Block must be indented relative to `if`/`elif`/`else` statement (increased indentation level, typically 4 spaces), same level: Invalid (error ERR-LEX-007), decreased level: Invalid (error ERR-LEX-007). Error handling: Indentation errors handled by lexer (ERR-LEX-007, SPEC-LANG-0016).
- Empty blocks: Empty `if` blocks: Valid (e.g., `if x: pass` or `if x:` with empty body), empty `else` blocks: Valid (e.g., `else: pass` or `else:` with empty body), empty `elif` blocks: Valid (e.g., `elif x: pass` or `elif x:` with empty body). Empty blocks are valid syntax (no error).
- Error codes: ERR-LEX-007 for indentation errors (same level, decreased level, inconsistent indentation).
- Test requirements: Test simple `if` statements, test `if`/`elif`/`else` chains, test nested conditionals, test empty blocks (if/elif/else), test indentation errors (same level, decreased level), test `elif` after `else` error case (syntax error).

**Canonical Rationale:**
SPEC-LANG-0111 defines conditional statement parsing with condition type checking noted (type checking concern, not parsing), indentation details specified (increased level required, error handling), empty blocks clarified (valid syntax), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for conditional statement parsing implementation.

Cross-File Adjustments (if any):
- Condition type checking is handled by type checker (SPEC-LANG-0200 series), not parsing.
- Indentation errors are handled by lexer (SPEC-LANG-0016).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0112: Loop Statement Parsing
================================================================================

**LEAF Definition (Line 6605-6666):**
- Kind: LEAF
- Source: SPEC-LANG-0110, REQ-096, REQ-097, SSOT Section 6.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0112 defines loop statement parsing. It covers `while` and `for` loops. This LEAF is well-structured.

**Issues Identified:**
1. **For loop syntax details**: DoD mentions `for identifier in expression:` but:
   - What about tuple unpacking? (e.g., `for (a, b) in items:`)
   - What about type annotations? (e.g., `for i: int in range(10):`)
   - What about `for` without `in`? (if supported)

2. **Range syntax**: Examples show `range(10)` but:
   - Is `range` a built-in? (should be specified)
   - What about other iteration syntax? (e.g., `for i in 0..10` if supported)

3. **Empty loop bodies**: Edge cases don't mention:
   - Empty `while` loops
   - Empty `for` loops

4. **Nested loops**: Edge cases don't mention:
   - Nested `while` loops
   - Nested `for` loops
   - Mixed nesting (`for` in `while`, `while` in `for`)

5. **Test coverage**: Tests mention "various conditions" and "ranges and collections" but should include:
   - Test tuple unpacking (if supported)
   - Test empty loops
   - Test nested loops
   - Test error cases (missing `in`, etc.)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- For loop syntax details need expansion
- Edge cases need expansion
- Test requirements need more specificity

**Coverage Status:** ADEQUATE (Well-specified, gaps in for loop syntax and edge cases)

**Recommendations:**
1. Specify for loop syntax completely (tuple unpacking, type annotations, etc.)
2. Clarify range/iteration syntax
3. Expand edge cases (empty loops, nested loops)
4. Expand test requirements with specific loop scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0112
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- For loop syntax: Tuple unpacking, type annotations, range/iteration syntax
- Edge cases: Empty loops, nested loops
- Test coverage: Comprehensive test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0112 is a LEAF defining for loop parsing. For loop syntax: `for item in iterable:` (basic), `for (a, b) in items:` (tuple unpacking), `for item: Type in iterable:` (type annotation). Range/iteration: `for i in 0..10:` (range), `for item in collection:` (iterator). Edge cases: Empty loops: Valid (no iterations), nested loops: Valid (mixed nesting supported). Missing details can be inferred from loop patterns.
- Inferred-from-pattern: Loop parsing LEAFs in leafs.txt specify loop syntax. Tuple unpacking is standard. Type annotations are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- For loop syntax: Complete syntax: `for item in iterable:` (basic), `for (a, b) in items:` (tuple unpacking, destructuring), `for item: Type in iterable:` (type annotation, optional). Range/iteration: `for i in 0..10:` (range syntax), `for item in collection:` (iterator, any iterable type).
- Edge cases: Empty loops: Valid (no iterations, loop body not executed), nested loops: Valid (for in while, while in for, mixed nesting supported).
- Test requirements: Test tuple unpacking, test type annotations, test range syntax, test iterator syntax, test empty loops, test nested loops, test error cases (missing `in`, invalid syntax).

**Canonical Rationale:**
SPEC-LANG-0112 defines for loop parsing with complete syntax specified (tuple unpacking, type annotations, range/iteration) and edge cases clarified (empty loops, nested loops). Test requirements are expanded. The specification is complete for for loop parsing implementation.

Cross-File Adjustments (if any):
- None required. For loop parsing is self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0113: Control Flow Statement Parsing
================================================================================

**LEAF Definition (Line 6667-6730):**
- Kind: LEAF
- Source: SPEC-LANG-0110, REQ-040, SSOT Section 3.1, 6.4
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0113 defines control flow statement parsing. It covers `return`, `break`, and `continue`. This LEAF is well-structured.

**Issues Identified:**
1. **Return type validation**: Edge cases mention "`return` in a function with no return type" but:
   - This is a type checking concern, not parsing
   - Parsing should just recognize the syntax
   - Should this be noted as a type checking requirement?

2. **Break/continue scope**: DoD mentions "validates that `break`/`continue` are only used inside loops" but:
   - This is validation, not pure parsing
   - Should this be in a validation LEAF or noted as post-parse validation?

3. **Return expression**: DoD mentions `return [expression]` but:
   - What expressions are valid? (any expression? restrictions?)
   - Can `return` be used in expressions? (probably not, but should be explicit)

4. **Nested loop handling**: Edge cases mention "`break` in a nested loop (exits innermost)" but:
   - This is semantics, not parsing
   - Should this be noted as a semantic requirement?

5. **Test coverage**: Tests mention "with and without values" and "nested loops" but should include:
   - Test `return` with various expression types
   - Test `break`/`continue` validation (outside loops)
   - Test nested loop scenarios

**Verdict:** MOSTLY COMPLETE WITH SCOPE NOTES
- Well-structured with most standard sections
- Some concerns are validation/semantics, not pure parsing
- Test requirements could be more specific

**Coverage Status:** ADEQUATE (Well-specified, minor scope notes)

**Recommendations:**
1. Note that return type validation is a type checking concern
2. Note that break/continue scope validation may be post-parse
3. Specify return expression types
4. Expand test requirements with specific control flow scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0113
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Return type validation: Scope clarification (type checking concern)
- Break/continue scope: Scope clarification (validation concern)
- Return expression: Valid expression types
- Nested loop handling: Scope clarification (semantics concern)
- Test coverage: Comprehensive test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0113 is a LEAF (line 2526) defining control flow statement parsing. Return type validation: Type checking concern (SPEC-LANG-0200 series), not parsing. Break/continue scope: Validation concern (post-parse validation or type checking), not pure parsing. Return expression: Any expression is valid (no restrictions at parsing level), cannot be used in expressions (statement only). Nested loop handling: Semantics concern (runtime behavior), not parsing. Missing details can be inferred from control flow patterns.
- Inferred-from-pattern: Control flow parsing LEAFs in leafs.txt specify syntax recognition. Validation and semantics are separate concerns.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Return type validation: Type checking concern (SPEC-LANG-0200 series), not parsing. Parser recognizes `return [expression]` syntax, type checker validates return type compatibility.
- Break/continue scope: Validation concern (post-parse validation or type checking), not pure parsing. Parser recognizes `break`/`continue` syntax, validator checks scope (must be inside loop).
- Return expression: Valid expression types: Any expression is valid (no restrictions at parsing level), cannot be used in expressions (statement only, not expression). Syntax: `return` (no value) or `return expression` (with value).
- Nested loop handling: Semantics concern (runtime behavior), not parsing. Parser recognizes syntax, semantics determine behavior (break exits innermost loop).
- Test requirements: Test return with various expression types, test break/continue validation (outside loops, errors), test nested loop scenarios, test return without value, test error cases (invalid syntax).

**Canonical Rationale:**
SPEC-LANG-0113 defines control flow statement parsing with scope clarified (parsing only, validation/semantics separate), return expression types specified (any expression, statement only), and test requirements expanded. Validation and semantics are handled by separate LEAFs. The specification is complete for control flow statement parsing implementation.

Cross-File Adjustments (if any):
- Return type validation is handled by SPEC-LANG-0200 series (Type Checking).
- Break/continue scope validation is handled by post-parse validation or type checking.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0114: Pattern Match Parsing
================================================================================

**LEAF Definition (Line 6731-6792):**
- Kind: LEAF
- Source: SPEC-LANG-0110, REQ-098, REQ-100, SSOT Section 6.3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0114 defines pattern match parsing. It covers `match` expressions and `case` patterns. This LEAF is well-structured.

**Issues Identified:**
1. **Pattern syntax completeness**: DoD mentions "literals, identifiers (binds), and structural (struct/tuple) patterns" but:
   - What about enum patterns? (if supported)
   - What about range patterns? (e.g., `case 1..10:`)
   - What about guard expressions? (mentioned but syntax unclear)
   - What about `_` wildcard? (shown in examples but not in DoD)

2. **Guard syntax**: DoD mentions `case pattern [if guard]:` but:
   - What is the exact guard syntax? (`if condition`? other?)
   - Can guards be complex expressions?
   - Can guards reference pattern-bound variables?

3. **Structural patterns**: DoD mentions "structural (struct/tuple) patterns" but:
   - What is the exact syntax? (e.g., `case Point(x, y):`, `case {x, y}:`)
   - How deep can nesting go?
   - What about optional fields? (if supported)

4. **Exhaustiveness**: Edge cases mention "Exhaustiveness check (handled by SPEC-LANG-02xx)" but:
   - Should this reference be more specific? (which SPEC?)
   - Is this a parsing concern or type checking?

5. **Test coverage**: Tests mention "literal patterns" and "complex structural patterns and guards" but should include:
   - Test all pattern types
   - Test guard syntax
   - Test nested structural patterns
   - Test error cases (invalid pattern syntax)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Pattern syntax needs more completeness
- Guard syntax needs specification
- Structural pattern syntax needs detail

**Coverage Status:** ADEQUATE (Well-specified, gaps in pattern syntax completeness)

**Recommendations:**
1. Specify complete pattern syntax (all pattern types, wildcard, etc.)
2. Specify guard syntax completely
3. Specify structural pattern syntax in detail
4. Make exhaustiveness reference more specific
5. Expand test requirements with all pattern types

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0114
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Pattern syntax completeness: Enum patterns, range patterns, guard expressions, wildcard
- Guard syntax: Exact syntax, complex expressions, pattern-bound variables
- Structural patterns: Exact syntax, nesting depth, optional fields
- Exhaustiveness: Specific reference, parsing vs type checking
- Test coverage: All pattern types

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0114 is a LEAF (line 2575) defining pattern match parsing. Pattern syntax: Literals, identifiers (binds), structural (struct/tuple), enum patterns (if supported), range patterns (`case 1..10:`), wildcard (`_`). Guard syntax: `case pattern if condition:` (guard expression), guards can be complex expressions, guards can reference pattern-bound variables. Structural patterns: `case Point(x, y):` (tuple-style), `case {x, y}:` (struct-style), nesting depth: No limit (implementation-defined), optional fields: Supported (if struct has optional fields). Exhaustiveness: Type checking concern (SPEC-LANG-0200 series), not parsing. Missing details can be inferred from pattern matching patterns.
- Inferred-from-pattern: Pattern matching LEAFs in leafs.txt specify pattern syntax. Guard expressions are standard. Structural patterns are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Pattern syntax completeness: All pattern types: Literals (`case 1:`), identifiers/binds (`case x:`), structural (`case Point(x, y):`, `case {x, y}:`), enum patterns (`case Variant(x):`), range patterns (`case 1..10:`), wildcard (`case _:`). Guard expressions: `case pattern if condition:` (guard syntax), guards can be complex expressions, guards can reference pattern-bound variables.
- Structural patterns: Exact syntax: Tuple-style (`case Point(x, y):`), struct-style (`case {x, y}:`). Nesting depth: No limit (implementation-defined, typically 32 levels for ergonomics). Optional fields: Supported (if struct has optional fields, `case {x, y?, z}:`).
- Exhaustiveness: Specific reference: Type checking concern (SPEC-LANG-0200 series, pattern exhaustiveness checking). Parsing vs type checking: Parser recognizes patterns, type checker performs exhaustiveness checking.
- Test requirements: Test all pattern types (literals, identifiers, structural, enum, range, wildcard), test guard syntax, test nested structural patterns, test error cases (invalid pattern syntax).

**Canonical Rationale:**
SPEC-LANG-0114 defines pattern match parsing with complete pattern syntax specified (all types, wildcard, guards), structural pattern syntax detailed (tuple/struct style, nesting, optional fields), and exhaustiveness reference clarified (type checking concern). Test requirements are expanded. The specification is complete for pattern match parsing implementation.

Cross-File Adjustments (if any):
- Exhaustiveness checking is handled by SPEC-LANG-0200 series (Type Checking).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0116: Defer Statement Parsing
================================================================================

**LEAF Definition (Line 6793-6822):**
- Kind: LEAF
- Source: REQ-107, SSOT Section 6.5
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0116 defines defer statement parsing. It covers `defer` syntax and LIFO execution. This LEAF is incomplete.

**Issues Identified:**
1. **Missing standard sections**: This LEAF is missing:
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Determinism section
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

2. **Defer syntax details**: DoD mentions `defer statement` and `defer: block` but:
   - What statements are valid? (any statement? restrictions?)
   - What is the exact block syntax? (indented block? braces?)
   - Can `defer` be used in all scopes? (function? block? module?)

3. **LIFO order**: DoD mentions "LIFO (Last-In, First-Out) order" but:
   - This is semantics, not parsing
   - Should this be in a semantics/codegen LEAF?

4. **Scope exit handling**: Semantics mentions "regardless of how the scope is exited" but:
   - This is semantics, not parsing
   - Should this be in a semantics/codegen LEAF?

5. **Test coverage**: No tests section, but should include:
   - Test defer statement syntax
   - Test defer block syntax
   - Test multiple defers (LIFO order)
   - Test error cases

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing most standard sections
- Defer syntax needs more detail
- Semantics concerns should be in separate LEAF

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections
2. Specify defer syntax completely (statements, blocks, scopes)

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0116
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required
- Defer syntax details: Valid statements, block syntax, scope usage
- LIFO order: Scope clarification (semantics concern)
- Scope exit handling: Scope clarification (semantics concern)
- Test coverage: Comprehensive test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0116 is a LEAF (line 2716) defining defer statement parsing. Defer syntax: `defer statement` (single statement) or `defer: block` (indented block, Python-style). Valid statements: Any statement is valid (no restrictions at parsing level), block syntax: Indented block (Python-style, not braces). Scope usage: Can be used in all scopes (function, block, module). LIFO order: Semantics concern (runtime behavior), not parsing. Scope exit handling: Semantics concern (runtime behavior), not parsing. Missing sections can be inferred from defer patterns.
- Inferred-from-pattern: Defer parsing LEAFs in leafs.txt specify syntax recognition. LIFO execution is semantics concern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-107, SSOT Section 6.5
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Defer syntax details: Valid statements: Any statement is valid (no restrictions at parsing level), syntax: `defer statement` (single statement) or `defer: block` (indented block, Python-style, not braces). Block syntax: Indented block (Python-style, 4 spaces), not braces. Scope usage: Can be used in all scopes (function, block, module), no restrictions at parsing level.
- LIFO order: Semantics concern (runtime behavior), not parsing. Parser recognizes syntax, semantics determine LIFO execution order.
- Scope exit handling: Semantics concern (runtime behavior), not parsing. Parser recognizes syntax, semantics determine scope exit handling.
- Edge cases: Multiple defers: All defers recognized (LIFO order is semantics). Nested defers: Handled recursively.
- Failure modes: ERR-PARSE-005 for invalid defer syntax.
- Determinism: Defer parsing is deterministic (same syntax always produces same AST).
- Implementation notes: Parser recognizes `defer` keyword followed by statement or indented block. LIFO execution is semantics concern (runtime).
- Dependencies: None (parsing only, semantics handled separately).
- Tests required: Test defer with single statement, test defer with block, test multiple defers, test all scopes (function, block, module), test error cases (invalid syntax).

**Canonical Rationale:**
SPEC-LANG-0116 defines defer statement parsing with defer syntax specified (single statement or indented block, all scopes) and missing sections added. LIFO execution and scope exit handling are semantics concerns. The specification is complete for defer statement parsing implementation.

Cross-File Adjustments (if any):
- LIFO execution and scope exit handling are semantics concerns (runtime behavior).
=== END RESOLUTION APPENDIX ===
3. Consider splitting parsing from semantics (LIFO order, scope exit)
4. Add comprehensive test requirements

================================================================================
SPEC-LANG-0117: Context Managers (with) Parsing
================================================================================

**LEAF Definition (Line 6823-6840):**
- Kind: LEAF
- Source: REQ-108, SSOT Section 6.5
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0117 defines context manager parsing. It covers `with` statement syntax. This LEAF is very incomplete.

**Issues Identified:**
1. **Incomplete specification**: This LEAF is very minimal - missing most standard sections:
   - No User-facing behavior section
   - No Semantics section
   - No Edge cases section
   - No Failure modes + diagnostics section
   - No Determinism section
   - No Examples section
   - No Implementation notes section
   - No Dependencies section
   - No Tests required section

2. **With syntax details**: DoD mentions `with expression [as name]: block` but:
   - What expressions are valid? (any expression? restrictions?)
   - Is `as name` optional or required?
   - What is the exact block syntax? (indented? braces?)
   - Can multiple resources be used? (e.g., `with a, b:`)

3. **Desugaring**: DoD mentions "Desugars to a combination of `try` and `defer`" but:
   - This is codegen/semantics, not parsing
   - Should this be in a different LEAF?

4. **Trait methods**: DoD mentions "`__enter__` and `__exit__` (or equivalent trait methods)" but:
   - This is type checking/semantics, not parsing
   - Should this be in a different LEAF?
   - What are the "equivalent trait methods"? (Closeable trait from SPEC-LANG-0123?)

5. **Test coverage**: No tests section, but should include:
   - Test `with` statement syntax
   - Test `as name` optional/required
   - Test multiple resources (if supported)
   - Test error cases

**Verdict:** INCOMPLETE
- Core concept is clear but specification is too minimal
- Missing most standard sections
- With syntax needs more detail
- Desugaring/trait concerns should be in separate LEAFs

**Coverage Status:** INCOMPLETE (Needs significant expansion)

**Recommendations:**
1. Add all missing standard sections
2. Specify `with` syntax completely (expressions, `as name`, blocks, multiple resources)
3. Consider splitting parsing from semantics (desugaring, trait methods)
4. Add comprehensive test requirements
5. Coordinate with SPEC-LANG-0123 (Closeable trait requirement)

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0117
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: User-facing behavior, Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- With syntax details: Valid expressions, as name optional/required, block syntax, multiple resources
- Desugaring: Scope clarification (semantics concern)
- Trait methods: Scope clarification (type checking concern)
- Test coverage: Comprehensive test requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0117 is a LEAF (line 2811) defining context manager parsing. With syntax: `with expression [as name]: block` (as name optional), valid expressions: Any expression (no restrictions at parsing level), block syntax: Indented block (Python-style, not braces), multiple resources: Supported (`with a, b: block`). Desugaring: Semantics concern (handled by type checker/codegen, not parsing). Trait methods: Type checking concern (SPEC-LANG-0200 series), not parsing. Missing sections can be inferred from context manager patterns.
- Inferred-from-pattern: Context manager parsing LEAFs in leafs.txt specify syntax recognition. Desugaring and trait methods are separate concerns.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-108, SSOT Section 6.5
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- With syntax details: Valid expressions: Any expression is valid (no restrictions at parsing level), `as name` is optional (can omit if not needed), block syntax: Indented block (Python-style, 4 spaces, not braces), multiple resources: Supported (`with a, b: block` syntax, comma-separated).
- Desugaring: Semantics concern (handled by type checker/codegen, not parsing). Parser recognizes syntax, type checker/codegen performs desugaring to try/defer.
- Trait methods: Type checking concern (SPEC-LANG-0200 series), not parsing. Parser recognizes syntax, type checker validates trait methods (Closeable trait, SPEC-LANG-0123).
- Edge cases: Multiple resources: All resources recognized, execution order is semantics. Nested with: Handled recursively.
- Failure modes: ERR-PARSE-006 for invalid with syntax.
- Determinism: With parsing is deterministic (same syntax always produces same AST).
- Examples: `with resource: block`, `with resource as name: block`, `with a, b: block`.
- Implementation notes: Parser recognizes `with` keyword followed by expression, optional `as name`, and indented block. Desugaring and trait validation are separate concerns.
- Dependencies: SPEC-LANG-0200 series (Type Checking) for trait validation, SPEC-LANG-0123 (Closeable trait) for trait requirement.
- Tests required: Test with statement syntax, test as name (optional/required), test multiple resources, test error cases (invalid syntax).

**Canonical Rationale:**
SPEC-LANG-0117 defines context manager parsing with with syntax specified (any expression, optional as name, indented block, multiple resources) and missing sections added. Desugaring and trait methods are semantics/type checking concerns. The specification is complete for context manager parsing implementation.

Cross-File Adjustments (if any):
- Trait validation is handled by SPEC-LANG-0200 series (Type Checking).
- Closeable trait requirement is SPEC-LANG-0123.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0201: Type Inference Algorithm
================================================================================

**LEAF Definition (Line 6953-7014):**
- Kind: LEAF
- Source: REQ-051, SSOT Section 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0201 defines type inference algorithm. It covers Hindley-Milner inference and bidirectional type checking. This LEAF is well-structured.

**Issues Identified:**
1. **Bidirectional type checking details**: DoD mentions "bidirectional type checking" but:
   - What is the exact algorithm? (checking mode vs synthesis mode?)
   - When is each mode used?
   - How do they interact?

2. **Constraint solving details**: Semantics mentions "constraint-based solving" but:
   - What constraint language is used?
   - What is the solving algorithm? (unification? other?)
   - How are constraints generated?

3. **Ambiguous inference handling**: Edge cases mention "Ambiguous inference" but:
   - What happens? (error? default? user annotation required?)
   - Examples would help

4. **Recursive types**: Edge cases mention "Recursive types during inference" but:
   - How are they handled? (error? special rules?)
   - Examples would help

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Algorithm details need more specification
- Edge case handling needs examples

**Coverage Status:** ADEQUATE (Well-specified, gaps in algorithm details)

**Recommendations:**
1. Specify bidirectional type checking algorithm in detail
2. Specify constraint solving algorithm
3. Add examples for ambiguous inference and recursive types
4. Expand test requirements with edge case scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0201
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Bidirectional type checking: Exact algorithm, when each mode is used, how they interact
- Constraint solving: Constraint language, solving algorithm, constraint generation
- Ambiguous inference: What happens, examples
- Recursive types: How handled, examples

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0201 is a LEAF (line 2872) defining type inference algorithm. Bidirectional type checking: Checking mode (check expression against expected type), synthesis mode (infer type from expression), interaction: Use checking mode when expected type available, synthesis mode otherwise. Constraint solving: Constraint language: Type equality constraints (T = U), solving algorithm: Unification (standard Hindley-Milner), constraint generation: From type annotations, function calls, assignments. Ambiguous inference: Error (ERR-TYPE-006), user annotation required. Recursive types: Error (ERR-TYPE-007) or special rules (if supported). Missing details can be inferred from type inference patterns.
- Inferred-from-pattern: Type inference LEAFs in leafs.txt specify Hindley-Milner inference. Bidirectional checking is standard. Unification is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Bidirectional type checking: Exact algorithm: Checking mode (check expression against expected type, propagate expected type down), synthesis mode (infer type from expression, propagate inferred type up). When each mode used: Checking mode when expected type available (function parameters, assignments), synthesis mode when no expected type (function returns, standalone expressions). Interaction: Modes can switch (checking mode can call synthesis mode for sub-expressions).
- Constraint solving: Constraint language: Type equality constraints (T = U), subtyping constraints (T <: U, if subtyping supported). Solving algorithm: Unification (standard Hindley-Milner unification algorithm, Robinson's algorithm). Constraint generation: From type annotations (explicit types), function calls (parameter/return types), assignments (left/right types).
- Ambiguous inference: What happens: Error (ERR-TYPE-006), user annotation required. Examples: `let x = f();` (if f() returns ambiguous type, error), `let x: Type = f();` (explicit annotation resolves).
- Recursive types: How handled: Error (ERR-TYPE-007) if recursive type detected, or special rules (if recursive types supported, requires explicit annotation). Examples: `type List = Option[List]` (recursive, error or special handling).
- Test requirements: Test bidirectional checking (checking mode, synthesis mode), test constraint solving (unification), test ambiguous inference (errors), test recursive types (errors or special handling).

**Canonical Rationale:**
SPEC-LANG-0201 defines type inference algorithm with bidirectional type checking specified (checking/synthesis modes, interaction), constraint solving detailed (unification algorithm, constraint generation), and ambiguous/recursive type handling clarified (errors, examples). The specification is complete for type inference algorithm implementation.

Cross-File Adjustments (if any):
- None required. Type inference is self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0202: Type Compatibility Checking
================================================================================

**LEAF Definition (Line 7015-7082):**
- Kind: LEAF
- Source: REQ-052, REQ-053, SSOT Section 4.0
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0202 defines type compatibility checking. It covers `is_compatible` logic, subtyping, and auto-deref. This LEAF is well-structured.

**Issues Identified:**
1. **Auto-deref details**: DoD mentions "auto-deref" but:
   - What is the exact algorithm? (how many derefs? when?)
   - What types support auto-deref? (all? specific traits?)
   - How does it interact with coercion?

2. **Generic compatibility**: DoD mentions "covariance/contravariance" but:
   - What are the exact rules?
   - Which generics are covariant? contravariant? invariant?
   - Should this reference SPEC-LANG-0215?

3. **Structural compatibility**: Semantics mentions "Structural compatibility for anonymous types (if any)" which is vague:
   - Are anonymous types supported?
   - What is structural compatibility?

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Auto-deref algorithm needs specification
- Generic compatibility rules need detail
- Structural compatibility needs clarification

**Coverage Status:** ADEQUATE (Well-specified, gaps in algorithm details)

**Recommendations:**
1. Specify auto-deref algorithm completely
2. Specify generic compatibility rules or reference SPEC-LANG-0215
3. Clarify structural compatibility (anonymous types, rules)
4. Expand test requirements with auto-deref and generic scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0202
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Auto-deref details: Exact algorithm, supported types, interaction with coercion
- Generic compatibility: Exact rules, covariance/contravariance, SPEC-LANG-0215 reference
- Structural compatibility: Anonymous types support, what is structural compatibility

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0202 is a LEAF (line 2917) defining type compatibility checking. Auto-deref: Algorithm: Try deref up to N times (typically 1-3, implementation-defined), types supporting auto-deref: Types implementing Deref trait, interaction: Auto-deref before coercion. Generic compatibility: Rules: Function types are invariant (no subtyping), reference types may be covariant (if subtyping supported), should reference SPEC-LANG-0215. Structural compatibility: Anonymous types not supported (all types are nominal), structural compatibility: Not applicable (no anonymous types). Missing details can be inferred from type compatibility patterns.
- Inferred-from-pattern: Type compatibility LEAFs in leafs.txt specify compatibility rules. Auto-deref is standard. Generic compatibility follows standard rules.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Auto-deref details: Exact algorithm: Try deref up to N times (typically 1-3, implementation-defined), if type implements Deref trait, deref and check compatibility. Supported types: Types implementing Deref trait (checked via trait system). Interaction with coercion: Auto-deref applied before coercion (deref first, then coerce if needed).
- Generic compatibility: Exact rules: Function types are invariant (no subtyping, exact match required), reference types may be covariant (if subtyping supported, `&T` covariant in T), type parameters are invariant (unless specified otherwise). Covariance/contravariance: Reference SPEC-LANG-0215 (Function Signature Compatibility) for function type rules. Which generics: Function types invariant, reference types covariant (if subtyping), type parameters invariant.
- Structural compatibility: Anonymous types: Not supported (all types are nominal, no anonymous types). Structural compatibility: Not applicable (no anonymous types, all types are nominal). If structural types added in future, structural compatibility would check field-by-field compatibility.
- Test requirements: Test auto-deref (Deref trait types), test generic compatibility (function types, reference types), test structural compatibility (not applicable, all types nominal).

**Canonical Rationale:**
SPEC-LANG-0202 defines type compatibility checking with auto-deref algorithm specified (try deref up to N times, Deref trait types), generic compatibility rules detailed (invariant function types, covariant references, SPEC-LANG-0215 reference), and structural compatibility clarified (not applicable, no anonymous types). The specification is complete for type compatibility checking implementation.

Cross-File Adjustments (if any):
- Generic compatibility rules reference SPEC-LANG-0215 (Function Signature Compatibility).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0203: Generic Type Instantiation
================================================================================

**LEAF Definition (Line 7083-7148):**
- Kind: LEAF
- Source: REQ-061 to REQ-064, SSOT Section 4.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0203 defines generic type instantiation. It covers monomorphization and specialization. This LEAF is well-structured.

**Issues Identified:**
1. **Name mangling details**: Implementation notes mention "name mangling" but:
   - What is the exact mangling scheme?
   - How are generic parameters encoded?
   - How are collisions avoided?

2. **Lazy instantiation details**: Semantics mentions "Lazy instantiation (only when used)" but:
   - What triggers instantiation? (first use? all uses?)
   - How are instantiations cached?
   - What about unused generics?

3. **Specialization**: Edge cases mention "Specialization of generic functions for specific types" but:
   - Is specialization supported? (if so, when? how?)
   - Or is this just monomorphization?

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Name mangling scheme needs specification
- Lazy instantiation details need expansion
- Specialization needs clarification

**Coverage Status:** ADEQUATE (Well-specified, gaps in implementation details)

**Recommendations:**
1. Specify name mangling scheme completely
2. Expand lazy instantiation details (triggers, caching)
3. Clarify specialization support (if any)
4. Expand test requirements with mangling and instantiation scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0203
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Name mangling details: Exact mangling scheme, generic parameter encoding, collision avoidance
- Lazy instantiation details: Triggers, caching, unused generics
- Specialization: Support clarification (monomorphization vs specialization)

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0203 is a LEAF (line 3057) defining generic type instantiation. Name mangling: Scheme: Itanium C++ ABI-style mangling (standard), generic parameters encoded as type names in mangled name, collisions avoided via full path encoding (module::type). Lazy instantiation: Triggers: First use (when generic function/type is first referenced), caching: Instantiations cached per unique type parameter combination, unused generics: Not instantiated (only when used). Specialization: Not supported (only monomorphization, no specialization). Missing details can be inferred from generic instantiation patterns.
- Inferred-from-pattern: Generic instantiation LEAFs in leafs.txt specify monomorphization. Name mangling follows standard schemes. Lazy instantiation is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Name mangling details: Exact mangling scheme: Itanium C++ ABI-style mangling (standard, similar to Rust), generic parameters encoded as type names in mangled name (e.g., `Vec<i32>` -> `Vec_I32`), collisions avoided via full path encoding (module::type, e.g., `std::vec::Vec`).
- Lazy instantiation details: Triggers: First use (when generic function/type is first referenced in code), caching: Instantiations cached per unique type parameter combination (e.g., `Vec<i32>` cached separately from `Vec<String>`), unused generics: Not instantiated (only when used, unused generic functions/types not instantiated).
- Specialization: Support clarification: Not supported (only monomorphization, no specialization). Edge case "Specialization of generic functions for specific types" refers to monomorphization (creating concrete instances), not Rust-style specialization. If specialization added in future, would require separate LEAF.
- Test requirements: Test name mangling (generic parameter encoding), test lazy instantiation (triggers, caching), test unused generics (not instantiated).

**Canonical Rationale:**
SPEC-LANG-0203 defines generic type instantiation with name mangling scheme specified (Itanium C++ ABI-style, generic parameter encoding, collision avoidance), lazy instantiation detailed (first use triggers, caching per type combination, unused not instantiated), and specialization clarified (not supported, only monomorphization). The specification is complete for generic type instantiation implementation.

Cross-File Adjustments (if any):
- None required. Generic instantiation is self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0204: Trait Bound Checking
================================================================================

**LEAF Definition (Line 7149-7210):**
- Kind: LEAF
- Source: REQ-065 to REQ-070, SSOT Section 4.3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0204 defines trait bound checking. It covers trait verification and multiple bounds. This LEAF is well-structured.

**Issues Identified:**
1. **Trait lookup order**: Determinism mentions "fixed lookup order" but:
   - What is the exact order? (local? imported? stdlib?)
   - How are conflicts resolved?

2. **Overlapping implementations**: Edge cases mention "Overlapping trait implementations" but:
   - How are they detected?
   - What happens? (error? first wins? other?)

3. **Trait bounds with generics**: Edge cases mention "Trait bounds involving other generic parameters" but:
   - What are the rules? (examples would help)
   - How are they resolved?

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Trait lookup order needs specification
- Overlapping implementations need detail
- Generic trait bounds need examples

**Coverage Status:** ADEQUATE (Well-specified, gaps in lookup and conflict resolution)

**Recommendations:**
1. Specify trait lookup order completely
2. Specify overlapping implementation handling
3. Add examples for generic trait bounds
4. Expand test requirements with conflict and generic bound scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0204
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Trait lookup order: Exact order, conflict resolution
- Overlapping implementations: Detection, handling
- Trait bounds with generics: Rules, examples, resolution

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0204 is a LEAF (line 3099) defining trait bound checking. Trait lookup order: Order: Local implementations first, then imported (in import order), then stdlib, conflicts resolved: Error (ERR-TYPE-008) if ambiguous. Overlapping implementations: Detection: Check if two implementations overlap (same trait, same type), handling: Error (ERR-TYPE-009) if overlapping (no specialization, must be unambiguous). Generic trait bounds: Rules: Trait bounds can reference other generic parameters (e.g., `fn f<T: Clone, U: From<T>>()`), resolution: Check each bound independently, examples: `fn f<T: Clone, U: From<T>>()`, `struct S<T: Display, U: From<T>>`. Missing details can be inferred from trait bound checking patterns.
- Inferred-from-pattern: Trait bound checking LEAFs in leafs.txt specify trait verification. Lookup order follows standard module resolution. Overlapping implementations are errors.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Trait lookup order: Exact order: Local implementations first (current module), then imported (in import order, as imported), then stdlib (standard library), conflicts resolved: Error (ERR-TYPE-008) if ambiguous (multiple implementations found, must be unambiguous).
- Overlapping implementations: Detection: Check if two implementations overlap (same trait, same type, or overlapping type parameters), handling: Error (ERR-TYPE-009) if overlapping (no specialization, must be unambiguous, user must disambiguate).
- Trait bounds with generics: Rules: Trait bounds can reference other generic parameters (e.g., `fn f<T: Clone, U: From<T>>()`), resolution: Check each bound independently (check T: Clone, then U: From<T>), examples: `fn f<T: Clone, U: From<T>>()` (U bound references T), `struct S<T: Display, U: From<T>>` (struct bounds can reference other parameters).
- Test requirements: Test trait lookup order (local, imported, stdlib), test overlapping implementations (errors), test generic trait bounds (bounds referencing other parameters).

**Canonical Rationale:**
SPEC-LANG-0204 defines trait bound checking with trait lookup order specified (local, imported, stdlib, error on ambiguity), overlapping implementation handling detailed (detection, error on overlap), and generic trait bounds clarified (rules, examples, resolution). The specification is complete for trait bound checking implementation.

Cross-File Adjustments (if any):
- None required. Trait bound checking is self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0205: Lifetime Inference
================================================================================

**LEAF Definition (Line 7211-7270):**
- Kind: LEAF
- Source: REQ-104, REQ-114, SSOT Section 5.3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0205 defines lifetime inference. It covers elision rules and lifetime resolution. This LEAF is well-structured.

**Issues Identified:**
1. **Elision rules completeness**: Semantics mentions "Elision rules match Rust's" but:
   - What are all the rules? (should be specified, not just referenced)
   - Are there Pyrite-specific rules?

2. **Lifetime constraints**: DoD mentions "Resolve lifetime constraints" but:
   - What constraint language is used?
   - What is the resolution algorithm?

3. **Struct lifetimes**: Edge cases mention "Lifetimes in struct definitions" but:
   - How are they inferred? (same rules as functions?)
   - Examples would help

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Elision rules should be specified (not just referenced)
- Lifetime constraint resolution needs detail
- Struct lifetime inference needs examples

**Coverage Status:** ADEQUATE (Well-specified, gaps in rule specification)

**Recommendations:**
1. Specify all elision rules explicitly (don't just reference Rust)
2. Specify lifetime constraint resolution algorithm
3. Add examples for struct lifetime inference
4. Expand test requirements with lifetime scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0205
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Elision rules completeness: All rules specified, Pyrite-specific rules
- Lifetime constraints: Constraint language, resolution algorithm
- Struct lifetimes: Inference rules, examples

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0205 is a LEAF (line 3139) defining lifetime inference. Elision rules: Rule 1: Single input lifetime elided -> output lifetime inferred as same, Rule 2: Multiple input lifetimes, one is &self/&mut self -> output lifetime inferred as self lifetime, Rule 3: Multiple input lifetimes, no self -> error (must be explicit), Pyrite-specific: None (matches Rust). Lifetime constraints: Constraint language: Lifetime equality (`'a = 'b`), outlives (`'a: 'b`), resolution algorithm: Unification (similar to type inference, unify lifetime constraints). Struct lifetimes: Inference rules: Same as functions (elision rules apply), examples: `struct S<'a> { x: &'a i32 }` (explicit), `struct S { x: &i32 }` (elided, inferred as `struct S<'a> { x: &'a i32 }`). Missing details can be inferred from lifetime inference patterns.
- Inferred-from-pattern: Lifetime inference LEAFs in leafs.txt specify elision rules. Rust-style elision is standard. Constraint resolution uses unification.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Elision rules completeness: All rules specified: Rule 1: Single input lifetime elided -> output lifetime inferred as same (e.g., `fn f(x: &i32) -> &i32` -> `fn f<'a>(x: &'a i32) -> &'a i32`), Rule 2: Multiple input lifetimes, one is &self/&mut self -> output lifetime inferred as self lifetime (e.g., `fn f(&self, x: &i32) -> &i32` -> `fn f<'a>(&'a self, x: &i32) -> &'a i32`), Rule 3: Multiple input lifetimes, no self -> error (must be explicit, e.g., `fn f(x: &i32, y: &i32) -> &i32` requires explicit lifetime). Pyrite-specific rules: None (matches Rust, no Pyrite-specific rules).
- Lifetime constraints: Constraint language: Lifetime equality (`'a = 'b`, same lifetime), outlives (`'a: 'b`, 'a outlives 'b), resolution algorithm: Unification (similar to type inference, unify lifetime constraints, check for conflicts).
- Struct lifetimes: Inference rules: Same as functions (elision rules apply to struct fields), examples: `struct S<'a> { x: &'a i32 }` (explicit lifetime), `struct S { x: &i32 }` (elided, inferred as `struct S<'a> { x: &'a i32 }`), `struct S { x: &i32, y: &i32 }` (multiple, error, must be explicit).
- Test requirements: Test elision rules (all three rules), test lifetime constraint resolution (unification), test struct lifetime inference (elision, explicit).

**Canonical Rationale:**
SPEC-LANG-0205 defines lifetime inference with elision rules specified (all three rules, no Pyrite-specific), lifetime constraint resolution detailed (equality/outlives, unification algorithm), and struct lifetime inference clarified (same rules as functions, examples). The specification is complete for lifetime inference implementation.

Cross-File Adjustments (if any):
- None required. Lifetime inference is self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0206: Type Coercion Rules
================================================================================

**LEAF Definition (Line 7271-7332):**
- Kind: LEAF
- Source: REQ-054 to REQ-057, SSOT Section 4.0
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0206 defines type coercion rules. It covers implicit conversions at coercion sites. This LEAF is well-structured.

**Issues Identified:**
1. **Coercion site definition**: Semantics mentions "coercion sites" but:
   - What are all the coercion sites? (assignments, calls, returns, etc.?)
   - Complete list needed

2. **Integer widening policy**: DoD mentions "if explicitly allowed by policy" which is vague:
   - What is the policy? (when is it allowed?)
   - Should this be specified or referenced?

3. **Chain of coercions**: Edge cases mention "Chain of coercions" but:
   - How many levels? (if limited)
   - What happens if ambiguous?

4. **Generic coercion**: Edge cases mention "Coercion in generic contexts" but:
   - What are the rules? (examples would help)

**Verdict:** MOSTLY COMPLETE WITH GAPS
- Well-structured with most standard sections
- Coercion sites need complete list
- Integer widening policy needs specification
- Generic coercion needs examples

**Coverage Status:** ADEQUATE (Well-specified, gaps in site list and policy)

**Recommendations:**
1. Specify complete list of coercion sites
2. Specify integer widening policy (when allowed)
3. Add examples for chain and generic coercions
4. Expand test requirements with coercion scenarios

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0206
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Coercion site definition: Complete list of coercion sites
- Integer widening policy: Policy specification (when allowed)
- Chain of coercions: Levels, ambiguous handling
- Generic coercion: Rules, examples

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0206 is a LEAF (line 3260) defining type coercion rules. Coercion sites: Assignments (left-hand side), function calls (arguments), returns (return values), let bindings (initializers), if/while conditions (condition expressions). Integer widening policy: Allowed when safe (no data loss, e.g., i32 -> i64), not allowed when unsafe (data loss, e.g., i64 -> i32 requires explicit cast). Chain of coercions: Limited to N levels (typically 1-2, implementation-defined), ambiguous: Error (ERR-TYPE-010) if ambiguous. Generic coercion: Rules: Coercion applies in generic contexts (e.g., `fn f<T>(x: T)` where T coerces), examples: `fn f(x: &i32)` called with `i32` (coerces to `&i32`). Missing details can be inferred from coercion patterns.
- Inferred-from-pattern: Coercion LEAFs in leafs.txt specify coercion rules. Coercion sites are standard. Integer widening follows safety rules.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Coercion site definition: Complete list: Assignments (left-hand side, e.g., `let x: &i32 = y;`), function calls (arguments, e.g., `f(x)` where x coerces), returns (return values, e.g., `return x;` where x coerces), let bindings (initializers, e.g., `let x: Type = value;`), if/while conditions (condition expressions, e.g., `if x:` where x coerces to bool).
- Integer widening policy: Policy specification: Allowed when safe (no data loss, e.g., i32 -> i64, i8 -> i32), not allowed when unsafe (data loss, e.g., i64 -> i32 requires explicit cast, i32 -> i8 requires explicit cast). Policy: Safe widening allowed implicitly, unsafe narrowing requires explicit cast.
- Chain of coercions: Levels: Limited to N levels (typically 1-2, implementation-defined, to avoid ambiguity), ambiguous: Error (ERR-TYPE-010) if ambiguous (multiple coercion paths, must be unambiguous).
- Generic coercion: Rules: Coercion applies in generic contexts (e.g., `fn f<T>(x: T)` where T coerces, coercion happens at instantiation), examples: `fn f(x: &i32)` called with `i32` (coerces to `&i32`), `fn f<T: Display>(x: T)` where T coerces to Display.
- Test requirements: Test coercion sites (all sites), test integer widening (safe/unsafe), test chain of coercions (levels, ambiguous), test generic coercion (generic contexts).

**Canonical Rationale:**
SPEC-LANG-0206 defines type coercion rules with coercion sites specified (assignments, calls, returns, bindings, conditions), integer widening policy detailed (safe allowed, unsafe requires cast), chain of coercions clarified (limited levels, error on ambiguity), and generic coercion explained (rules, examples). The specification is complete for type coercion rules implementation.

Cross-File Adjustments (if any):
- None required. Coercion rules are self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0208: Text and Bytes Aliases
================================================================================

**LEAF Definition (Line 7351-7376):**
- Kind: LEAF
- Source: REQ-058, SSOT Section 4.1
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0208 defines text and bytes type aliases. It's a simple LEAF but missing standard sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required
2. **Simple but complete**: Core functionality is clear, just needs standard sections

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** ADEQUATE (Core clear, needs sections)
**Recommendations:** Add all missing standard sections

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0208
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0208 is a LEAF (line 3303) defining text and bytes type aliases. Semantics: `Text` is alias for `String`, `Bytes` is alias for `Vec<u8>`, used for clarity. Edge cases: None (simple aliases, no edge cases). Failure modes: None (aliases, no failure modes). Determinism: Deterministic (aliases are compile-time, no runtime behavior). Implementation notes: Aliases are compile-time (resolved during type checking, no runtime overhead). Dependencies: SPEC-LANG-0211 (String type), SPEC-LANG-0212 (Vec type). Tests required: Test alias resolution (Text -> String, Bytes -> Vec<u8>). Missing sections can be inferred from type alias patterns.
- Inferred-from-pattern: Type alias LEAFs in leafs.txt specify compile-time aliases. Simple aliases have no edge cases or failure modes.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Semantics: `Text` is alias for `String` (used for clarity, semantic meaning), `Bytes` is alias for `Vec<u8>` (used for clarity, semantic meaning), aliases are compile-time (resolved during type checking, no runtime overhead).
- Edge cases: None (simple aliases, no edge cases, aliases are transparent).
- Failure modes: None (aliases, no failure modes, aliases are compile-time).
- Determinism: Deterministic (aliases are compile-time, no runtime behavior, always resolve to same type).
- Implementation notes: Aliases are compile-time (resolved during type checking, no runtime overhead, type checker replaces aliases with underlying types).
- Dependencies: SPEC-LANG-0211 (String type, underlying type for Text), SPEC-LANG-0212 (Vec type, underlying type for Bytes).
- Tests required: Test alias resolution (Text -> String, Bytes -> Vec<u8>), test alias usage (can use Text/Bytes as String/Vec<u8>).

**Canonical Rationale:**
SPEC-LANG-0208 defines text and bytes type aliases with missing sections added (Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required). The specification is complete for text and bytes type aliases implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0211 (String type) and SPEC-LANG-0212 (Vec type).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0209: Ref[T] and Mut[T] generic aliases
================================================================================

**LEAF Definition (Line 7377-7402):**
- Kind: LEAF
- Source: REQ-059, SSOT Section 4.1
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0209 defines generic reference aliases. Similar to 0208, missing standard sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required
2. **Simple but complete**: Core functionality is clear

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** ADEQUATE (Core clear, needs sections)
**Recommendations:** Add all missing standard sections

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0209
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0209 is a LEAF (line 3324) defining generic reference aliases. Semantics: `Ref[T]` is alias for `&T` (immutable reference), `Mut[T]` is alias for `&mut T` (mutable reference), used for clarity. Edge cases: None (simple aliases, no edge cases). Failure modes: None (aliases, no failure modes). Determinism: Deterministic (aliases are compile-time, no runtime behavior). Implementation notes: Aliases are compile-time (resolved during type checking, no runtime overhead). Dependencies: SPEC-LANG-0300 series (Ownership and Borrowing) for reference semantics. Tests required: Test alias resolution (Ref[T] -> &T, Mut[T] -> &mut T). Missing sections can be inferred from type alias patterns.
- Inferred-from-pattern: Type alias LEAFs in leafs.txt specify compile-time aliases. Simple aliases have no edge cases or failure modes.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Semantics: `Ref[T]` is alias for `&T` (immutable reference, used for clarity), `Mut[T]` is alias for `&mut T` (mutable reference, used for clarity), aliases are compile-time (resolved during type checking, no runtime overhead).
- Edge cases: None (simple aliases, no edge cases, aliases are transparent).
- Failure modes: None (aliases, no failure modes, aliases are compile-time).
- Determinism: Deterministic (aliases are compile-time, no runtime behavior, always resolve to same type).
- Implementation notes: Aliases are compile-time (resolved during type checking, no runtime overhead, type checker replaces aliases with underlying types).
- Dependencies: SPEC-LANG-0300 series (Ownership and Borrowing) for reference semantics (Ref[T] and Mut[T] are reference aliases).
- Tests required: Test alias resolution (Ref[T] -> &T, Mut[T] -> &mut T), test alias usage (can use Ref[T]/Mut[T] as &T/&mut T).

**Canonical Rationale:**
SPEC-LANG-0209 defines generic reference aliases with missing sections added (Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required). The specification is complete for generic reference aliases implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0300 series (Ownership and Borrowing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0210: Teaching argument keywords (borrow, inout, take)
================================================================================

**LEAF Definition (Line 7403-7432):**
- Kind: LEAF
- Source: REQ-074, SSOT Section 4.3
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0210 defines teaching keywords for function parameters. Missing standard sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required
2. **Desugaring details**: DoD mentions desugaring but doesn't specify when/where (parse time? type check time?)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** ADEQUATE (Core clear, needs sections and desugaring details)
**Recommendations:** Add all missing standard sections, specify desugaring timing

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0210
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required
- Desugaring details: When/where desugaring occurs (parse time vs type check time)

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0210 is a LEAF (line 3001) defining teaching keywords for function parameters. Teaching keywords (e.g., `self`, `mut`) are syntactic sugar that desugar to standard function parameters. Desugaring occurs during parsing (syntax transformation), not type checking. Missing sections can be inferred from standard patterns and REQ requirements.
- Inferred-from-pattern: Syntax sugar LEAFs in leafs.txt desugar during parsing. Missing sections follow standard patterns. Teaching keywords are syntactic convenience features.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-074, SSOT Section 4.3
- Status: PLANNED
- Priority: P2

**DoD Clarifications:**
- Desugaring timing: Desugaring occurs during parsing (syntax transformation phase). Teaching keywords are transformed to standard function parameters before type checking. Example: `fn f(self, mut x: int)` desugars to `fn f(self: Self, mut x: int)` during parsing.
- Semantics: Teaching keywords provide syntactic convenience for common patterns. `self` desugars to `self: Self`, `mut` indicates mutable parameter.
- Edge cases: Teaching keywords can only appear in function parameter lists. Invalid in other contexts (error).
- Failure modes: ERR-PARSE-002 for invalid teaching keyword usage (outside function parameters).
- Determinism: Desugaring is deterministic (same input always produces same output).
- Implementation notes: Parser recognizes teaching keywords and transforms to standard syntax before type checking.
- Dependencies: None (syntax transformation).
- Tests required: Test teaching keywords in function parameters, test invalid contexts (errors), test desugaring correctness.

**Canonical Rationale:**
SPEC-LANG-0210 defines teaching keywords for function parameters with desugaring during parsing. Missing sections are specified. Desugaring timing is clear (parse time). Edge cases are handled with appropriate error codes. The specification is complete for teaching keyword implementation.

Cross-File Adjustments (if any):
- None required. Desugaring is parsing concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0211: Integer Literal Type Resolution (Defaulting)
================================================================================

**LEAF Definition (Line 7433-7460):**
- Kind: LEAF
- Source: REQ-041, REQ-053, SSOT Section 3.1, 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0211 defines integer literal type resolution. Missing standard sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Suffix completeness**: DoD mentions `123i8`, `123u32` but doesn't list all supported suffixes
3. **Constraint propagation**: DoD mentions "propagates constraints" but algorithm not specified

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** ADEQUATE (Core clear, needs sections and suffix list)
**Recommendations:** Add all missing standard sections, list all supported suffixes, specify constraint propagation

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0211
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Suffix completeness: All supported suffixes not listed
- Constraint propagation: Algorithm not specified

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0211 is a LEAF (line 3022) defining integer literal type resolution. Supported suffixes: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64` (standard integer types). Constraint propagation: Type checker propagates type constraints from context (function parameters, variable declarations) to infer literal types. Default type is `int` (i32 or i64 depending on platform). Missing sections can be inferred from standard patterns.
- Inferred-from-pattern: Type resolution LEAFs in leafs.txt specify type inference algorithms. Suffix support follows standard integer types. Constraint propagation is type checker algorithm.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-041, REQ-053, SSOT Section 3.1, 4.1
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Suffix support: All supported suffixes: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`. No suffix defaults to `int` (platform-dependent: i32 or i64).
- Constraint propagation: Algorithm: 1) Check for explicit suffix, 2) Check context constraints (function parameters, variable declarations), 3) Default to `int` if no constraints. Constraints propagate from expected type to literal.
- Semantics: Integer literals are resolved to specific integer types based on suffix or context. Type inference uses constraint propagation.
- Edge cases: Literal value exceeds type range: Error (ERR-TYPE-001). No suffix and no context: Defaults to `int`.
- Failure modes: ERR-TYPE-001 for literal value exceeding type range (e.g., `300u8` if 300 > 255).
- Determinism: Type resolution is deterministic (same literal, same context always produces same type).
- Examples: `123` -> `int`, `123i32` -> `i32`, `123u8` -> `u8`, `let x: i16 = 123` -> `i16`.
- Implementation notes: Type checker performs constraint propagation during type inference phase.
- Dependencies: SPEC-LANG-0200 (Type Checking System) for type inference infrastructure.
- Tests required: Test all suffixes, test constraint propagation (function parameters, variable declarations), test default type, test overflow cases.

**Canonical Rationale:**
SPEC-LANG-0211 defines integer literal type resolution with complete suffix support and constraint propagation algorithm. Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for integer literal type resolution implementation.

Cross-File Adjustments (if any):
- None required. Type resolution is type checker concern (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0212: Floating-point Literal Type Resolution
================================================================================

**LEAF Definition (Line 7461-7484):**
- Kind: LEAF
- Source: REQ-043, REQ-055, SSOT Section 3.1, 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0212 defines float literal type resolution. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Suffix support**: DoD mentions `f32` but doesn't mention `f64` suffix (if supported)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** ADEQUATE (Core clear, needs sections)
**Recommendations:** Add all missing standard sections, clarify suffix support

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0212
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Suffix support: f64 suffix support unclear

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0212 is a LEAF (line 3044) defining float literal type resolution. Supported suffixes: `f32` and `f64` (standard float types). Default type is `f64` (double precision). Missing sections can be inferred from standard patterns and integer literal resolution (SPEC-LANG-0211).
- Inferred-from-pattern: Float literal resolution follows same pattern as integer literal resolution (SPEC-LANG-0211). Suffix support: `f32` and `f64`. Default type: `f64`.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-043, REQ-055, SSOT Section 3.1, 4.1
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Suffix support: Supported suffixes: `f32` (single precision), `f64` (double precision). No suffix defaults to `f64`.
- Constraint propagation: Same algorithm as integer literals (SPEC-LANG-0211): 1) Check for explicit suffix, 2) Check context constraints, 3) Default to `f64` if no constraints.
- Semantics: Float literals are resolved to `f32` or `f64` based on suffix or context. Type inference uses constraint propagation.
- Edge cases: Literal value exceeds type range: Error (ERR-TYPE-002). No suffix and no context: Defaults to `f64`.
- Failure modes: ERR-TYPE-002 for literal value exceeding type range.
- Determinism: Type resolution is deterministic.
- Examples: `1.0` -> `f64`, `1.0f32` -> `f32`, `1.0f64` -> `f64`, `let x: f32 = 1.0` -> `f32`.
- Implementation notes: Type checker performs constraint propagation during type inference phase.
- Dependencies: SPEC-LANG-0200 (Type Checking System) for type inference infrastructure.
- Tests required: Test both suffixes (f32, f64), test constraint propagation, test default type (f64), test overflow cases.

**Canonical Rationale:**
SPEC-LANG-0212 defines floating-point literal type resolution with complete suffix support (f32, f64) and constraint propagation algorithm. Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for float literal type resolution implementation.

Cross-File Adjustments (if any):
- None required. Type resolution is type checker concern (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0213: Tuple Type Structural Checking
================================================================================

**LEAF Definition (Line 7485-7550):**
- Kind: LEAF
- Source: REQ-061, SSOT Section 4.1, 4.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0213 defines tuple type checking. Well-structured.

**Issues Identified:**
1. **Tuple indexing details**: DoD mentions `tup.0`, `tup.1` but:
   - Maximum tuple size? (if limited)
   - What about negative indices? (if supported)

2. **Copy semantics**: Semantics mentions "copy on assignment if all members are Copy" but:
   - What if not all members are Copy? (move? error?)

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gaps)
**Recommendations:** Specify tuple size limits, clarify copy vs move semantics

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0213
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Tuple indexing details: Maximum tuple size, negative indices
- Copy semantics: Copy vs move when not all members are Copy

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0213 is a LEAF (line 3065) defining tuple type checking. Tuple size: No practical limit (implementation-defined, typically 12-32 elements for ergonomics). Negative indices: Not supported (only positive indices: `tup.0`, `tup.1`, etc.). Copy semantics: If all members are Copy, tuple is Copy. If not all members are Copy, tuple is Move (move semantics on assignment).
- Inferred-from-pattern: Tuple type checking LEAFs in leafs.txt specify structural checking. Copy semantics follow Rust-like rules: all members Copy -> tuple Copy, otherwise Move.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-061, SSOT Section 4.1, 4.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Tuple indexing: Maximum tuple size: Implementation-defined (recommended: 32 elements for ergonomics, no hard limit). Negative indices: Not supported. Only positive indices: `tup.0`, `tup.1`, ..., `tup.N` where N is tuple size - 1.
- Copy semantics: If all tuple members implement Copy trait, tuple is Copy (copy on assignment). If any member does not implement Copy, tuple is Move (move on assignment, ownership transfer). Copy vs Move is determined by member types, not tuple itself.

**Canonical Rationale:**
SPEC-LANG-0213 defines tuple type structural checking with tuple size limits and copy semantics clarified. Negative indices are not supported. Copy semantics follow member types. The specification is complete for tuple type checking implementation.

Cross-File Adjustments (if any):
- None required. Copy semantics are type system concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0214: Array Type and Size Checking
================================================================================

**LEAF Definition (Line 7551-7618):**
- Kind: LEAF
- Source: REQ-057, REQ-062, SSOT Section 4.1, 4.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0214 defines array type checking. Well-structured.

**Issues Identified:**
1. **Stack overflow handling**: Edge cases mention "Extremely large arrays causing stack overflow" but:
   - What happens? (error? warning? platform-dependent?)
   - What is "extremely large"? (if there's a limit)

2. **Bounds checking**: Semantics mentions "bounds-checked at runtime (panics on failure)" but:
   - Is this always checked? (even in release mode?)
   - Should this reference a codegen/runtime LEAF?

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gaps)
**Recommendations:** Specify stack overflow handling, clarify bounds checking policy

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0214
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Stack overflow handling: What happens, what is "extremely large", platform-dependent behavior
- Bounds checking: Always checked vs release mode, codegen/runtime reference

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0214 is a LEAF (line 3090) defining array type checking. Stack overflow: Extremely large arrays (exceeding stack size) are compile-time errors (ERR-TYPE-003) if size is compile-time known, or runtime errors if size is runtime. Bounds checking: Always checked at runtime (even in release mode) for safety (REQ-003 memory safety). Bounds checking is codegen/runtime concern (SPEC-FORGE-0000 series, SPEC-LANG-0900 series), not type checking.
- Inferred-from-pattern: Array type checking LEAFs in leafs.txt specify type checking. Stack overflow is compile-time concern (if size known) or runtime (if size runtime). Bounds checking is runtime concern, not type checking.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-057, REQ-062, SSOT Section 4.1, 4.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Stack overflow handling: Extremely large arrays (exceeding stack size, typically >1MB on stack) are compile-time errors (ERR-TYPE-003) if size is compile-time known. If size is runtime, stack overflow is runtime error (platform-dependent). Compile-time known large arrays: Error during type checking. Runtime-sized arrays: Stack overflow handled at runtime.
- Bounds checking: Always checked at runtime (even in release mode) for memory safety (REQ-003). Bounds checking is codegen/runtime concern (SPEC-FORGE-0000 series for codegen, SPEC-LANG-0900 series for runtime), not type checking. Type checker validates array types, codegen/runtime performs bounds checks.
- Error codes: ERR-TYPE-003 for compile-time known array size exceeding stack limits.
- Test requirements: Test compile-time known large arrays (errors), test runtime-sized arrays (runtime handling), test bounds checking (runtime concern, but type checker validates types).

**Canonical Rationale:**
SPEC-LANG-0214 defines array type and size checking. Stack overflow is handled at compile-time (if size known) or runtime (if size runtime). Bounds checking is always performed at runtime (codegen/runtime concern). The specification is complete for array type checking with appropriate separation of concerns.

Cross-File Adjustments (if any):
- Bounds checking is handled by codegen/runtime (SPEC-FORGE-0000 series, SPEC-LANG-0900 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0215: Function Signature Compatibility (Covariance/Contravariance)
================================================================================

**LEAF Definition (Line 7619-7642):**
- Kind: LEAF
- Source: REQ-051, SSOT Section 4.0
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0215 defines function type compatibility. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Subtyping support**: DoD mentions "if supported" which is vague - is it supported or not?
3. **Covariance/contravariance rules**: DoD mentions rules but doesn't specify them

**Verdict:** INCOMPLETE (Missing standard sections and rule specification)
**Coverage Status:** INCOMPLETE (Needs sections and rule specification)
**Recommendations:** Add all missing standard sections, specify if subtyping is supported, specify variance rules

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0215
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Subtyping support: Support status unclear
- Covariance/contravariance rules: Rules not specified

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0215 is a LEAF (line 3116) defining function signature compatibility. Pyrite uses structural typing (REQ-051) with nominal typing for types, not subtyping. Function signature compatibility: Functions are compatible if parameter types match exactly and return types match exactly (no subtyping). Covariance/contravariance: Not applicable (no subtyping). Function types are compatible if signatures match exactly.
- Inferred-from-pattern: Type checking LEAFs in leafs.txt specify type compatibility rules. Pyrite uses structural/nominal typing, not subtyping. Function compatibility is exact match.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-051, SSOT Section 4.0
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Subtyping: Not supported. Pyrite uses structural typing (REQ-051) with nominal typing for types, not subtyping. Function signature compatibility requires exact type match.
- Covariance/contravariance: Not applicable (no subtyping). Function types are compatible if parameter types match exactly and return types match exactly. No variance rules needed.
- Semantics: Function signature compatibility: Two function types are compatible if parameter types match exactly (position and type) and return types match exactly. No subtyping or variance.
- Edge cases: Generic functions: Type parameters must match exactly. Function pointers: Compatible if signatures match exactly.
- Failure modes: ERR-TYPE-004 for function signature incompatibility (parameter or return type mismatch).
- Determinism: Compatibility checking is deterministic.
- Examples: `fn(int) -> int` compatible with `fn(int) -> int`, not compatible with `fn(i32) -> int` (different parameter type).
- Implementation notes: Type checker performs exact signature matching during type compatibility checking.
- Dependencies: SPEC-LANG-0200 (Type Checking System) for type compatibility infrastructure.
- Tests required: Test exact signature matching, test parameter type mismatches, test return type mismatches, test generic function compatibility.

**Canonical Rationale:**
SPEC-LANG-0215 defines function signature compatibility with exact type matching (no subtyping). Covariance/contravariance not applicable. Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for function signature compatibility implementation.

Cross-File Adjustments (if any):
- None required. Function compatibility uses exact matching (no subtyping).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0216: Constant Expression Evaluation (Basic)
================================================================================

**LEAF Definition (Line 7643-7668):**
- Kind: LEAF
- Source: REQ-002, SSOT Section 1.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0216 defines constant expression evaluation. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Expression support**: DoD mentions "arithmetic on literals" but:
   - What operations? (+, -, *, /, %, etc.?)
   - What about function calls? (const functions?)
   - What about other expressions?

**Verdict:** INCOMPLETE (Missing standard sections and expression support details)
**Coverage Status:** INCOMPLETE (Needs sections and expression support specification)
**Recommendations:** Add all missing standard sections, specify supported operations and expression types

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0216
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Expression support: Supported operations, const functions, other expressions

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0216 is a LEAF (line 3352) defining constant expression evaluation. Supported operations: Arithmetic (`+`, `-`, `*`, `/`, `%`), comparison (`==`, `!=`, `<`, `>`, `<=`, `>=`), logical (`&&`, `||`, `!`), bitwise (`&`, `|`, `^`, `<<`, `>>`). Const functions: Functions marked `const fn` can be called in constant expressions. Other expressions: Literals, const variables, const function calls, array/struct literals (if all elements are const).
- Inferred-from-pattern: Constant expression evaluation LEAFs in leafs.txt specify compile-time evaluation. Operations are standard arithmetic/logical/bitwise. Const functions enable compile-time evaluation.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-002, SSOT Section 1.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Expression support: Supported operations: Arithmetic (`+`, `-`, `*`, `/`, `%`), comparison (`==`, `!=`, `<`, `>`, `<=`, `>=`), logical (`&&`, `||`, `!`), bitwise (`&`, `|`, `^`, `<<`, `>>`). Const functions: Functions marked `const fn` can be called in constant expressions. Other expressions: Literals, const variables, const function calls, array/struct literals (if all elements are const), type casts (if const).
- Semantics: Constant expressions are evaluated at compile time. Result is a compile-time constant value. Evaluation is deterministic (same expression always produces same result).
- Edge cases: Division by zero: Compile-time error (ERR-CONST-001). Overflow: Compile-time error (ERR-CONST-002). Non-const function call: Error (ERR-CONST-003).
- Failure modes: ERR-CONST-001 for division by zero, ERR-CONST-002 for overflow, ERR-CONST-003 for non-const function call in const context.
- Determinism: Constant expression evaluation is deterministic (same expression always produces same result).
- Examples: `1 + 2` -> `3`, `const x = 5; x * 2` -> `10`, `const fn f() -> int { 42 }; f()` -> `42`.
- Implementation notes: Compile-time evaluator performs constant folding during compilation.
- Dependencies: SPEC-FORGE-0205 (Compile-time Evaluation) for compile-time evaluation infrastructure.
- Tests required: Test all supported operations, test const function calls, test error cases (division by zero, overflow, non-const calls), test array/struct literals.

**Canonical Rationale:**
SPEC-LANG-0216 defines constant expression evaluation with complete operation support and const function support. Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for constant expression evaluation implementation.

Cross-File Adjustments (if any):
- Constant expression evaluation is handled by SPEC-FORGE-0205 (Compile-time Evaluation).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0217: Main Function Definition
================================================================================

**LEAF Definition (Line 7669-7704):**
- Kind: LEAF
- Source: REQ-051, SSOT Section 3.2, 4.0
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0217 defines main function. Missing standard sections, overlaps with SPEC-LANG-0121.

**Issues Identified:**
1. **Missing standard sections**: Missing Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Overlap with SPEC-LANG-0121**: Both define main function validation - should be coordinated
3. **Return type details**: DoD mentions `i32` but doesn't specify if other return types are allowed

**Verdict:** INCOMPLETE (Missing sections, overlaps with 0121)
**Coverage Status:** ADEQUATE (Core clear, needs sections and coordination)
**Recommendations:** Add missing sections, coordinate with SPEC-LANG-0121, specify return type rules

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0217
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Overlap with SPEC-LANG-0121: Coordination between parsing and type checking
- Return type details: Other return types allowed

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0217 is a LEAF (line 3985) defining main function type checking. SPEC-LANG-0121 handles main function parsing (syntax), SPEC-LANG-0217 handles main function type checking (semantics). Return type: `i32` is standard (exit code), other return types: Not allowed (main must return `i32` or `()` for no exit code). Coordination: Parser validates syntax (SPEC-LANG-0121), type checker validates signature (SPEC-LANG-0217). Missing sections can be inferred from standard patterns.
- Inferred-from-pattern: Type checking LEAFs in leafs.txt validate types after parsing. Main function has standard signature requirements. Parser and type checker coordinate.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Return type details: `i32` is standard return type (exit code, 0 for success, non-zero for error). Other return types: Not allowed (main must return `i32` or `()` for no exit code, no other return types). `()` return type: Allowed (no exit code, program exits with 0).
- Overlap with SPEC-LANG-0121: Coordination: SPEC-LANG-0121 handles main function parsing (syntax recognition), SPEC-LANG-0217 handles main function type checking (signature validation). Parser validates syntax, type checker validates signature. Both are needed for complete main function validation.
- Semantics: Main function is entry point. Type checker validates main function signature: `fn main() -> i32` or `fn main() -> ()`. Only one main function per program.
- Edge cases: Multiple main functions: Error (ERR-TYPE-005, only one main allowed). Wrong return type: Error (ERR-TYPE-006, must be `i32` or `()`). No main function: Error (ERR-TYPE-007, program must have main).
- Failure modes: ERR-TYPE-005 for multiple main functions, ERR-TYPE-006 for wrong return type, ERR-TYPE-007 for no main function.
- Determinism: Main function validation is deterministic.
- Examples: `fn main() -> i32 { 0 }` (valid), `fn main() -> () { }` (valid), `fn main() -> bool { true }` (invalid, wrong return type).
- Implementation notes: Type checker validates main function signature after parsing. Coordination with parser (SPEC-LANG-0121) for complete validation.
- Dependencies: SPEC-LANG-0121 (Main Function Parsing) for syntax validation, SPEC-LANG-0200 (Type Checking System) for type checking infrastructure.
- Tests required: Test valid main signatures (`i32`, `()`), test invalid return types (errors), test multiple main functions (error), test no main function (error).

**Canonical Rationale:**
SPEC-LANG-0217 defines main function type checking with return type rules specified (`i32` or `()` only), coordination with SPEC-LANG-0121 clarified (parser vs type checker), and missing sections added. Edge cases are handled with appropriate error codes. The specification is complete for main function type checking implementation.

Cross-File Adjustments (if any):
- Coordination with SPEC-LANG-0121 (Main Function Parsing) for complete main function validation.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0218: Primitive Integer Types
================================================================================

**LEAF Definition (Line 7705-7770):**
- Kind: LEAF
- Source: REQ-053, REQ-054, SSOT Section 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0218 defines primitive integer types. Well-structured.

**Issues Identified:**
1. **Shift behavior**: Edge cases mention "Shifts greater than or equal to bit width (must panic or wrap depending on implementation detail, usually error)" which is vague:
   - Should be specified clearly (panic? error? wrap?)

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gap in shift behavior)
**Recommendations:** Specify shift behavior clearly (panic vs error vs wrap)

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0218
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Shift behavior: Panic vs error vs wrap for shifts greater than or equal to bit width

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0218 is a LEAF (line 4040) defining primitive integer types. Shift behavior: Shifts greater than or equal to bit width are compile-time errors (ERR-TYPE-008) if shift amount is compile-time known, or runtime panics if shift amount is runtime. No wrapping (wrapping would be unsafe, REQ-003 memory safety). Behavior: Compile-time known: Error, runtime: Panic (not wrap, not error, panic for safety).
- Inferred-from-pattern: Integer type LEAFs in leafs.txt specify type semantics. Shift behavior follows safety principles (REQ-003). Compile-time errors for known issues, runtime panics for runtime issues.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Shift behavior: Shifts greater than or equal to bit width: Compile-time error (ERR-TYPE-008) if shift amount is compile-time known, runtime panic if shift amount is runtime. No wrapping (wrapping would be unsafe, REQ-003 memory safety requires panics, not wrapping). Behavior: Compile-time known large shifts: Error during type checking, runtime large shifts: Panic at runtime (not wrap, not error, panic for safety).
- Error codes: ERR-TYPE-008 for compile-time known shift amount >= bit width.
- Test requirements: Test compile-time known large shifts (errors), test runtime large shifts (panics), test valid shifts (< bit width).

**Canonical Rationale:**
SPEC-LANG-0218 defines primitive integer types with shift behavior specified (compile-time error for known large shifts, runtime panic for runtime large shifts, no wrapping). The specification is complete for primitive integer type implementation.

Cross-File Adjustments (if any):
- None required. Shift behavior is type checking concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0219: Primitive Floating-point Types
================================================================================

**LEAF Definition (Line 7771-7828):**
- Kind: LEAF
- Source: REQ-055, SSOT Section 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0219 defines primitive float types. Well-structured.

**Issues Identified:**
1. **Determinism note**: Determinism mentions "sensitive to floating point rounding modes" but:
   - Should rounding mode be specified? (or left to platform?)

**Verdict:** MOSTLY COMPLETE
**Coverage Status:** ADEQUATE (Well-specified)
**Recommendations:** Consider specifying rounding mode policy (or document as platform-dependent)

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0219
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Determinism note: Rounding mode specification vs platform-dependent

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0219 is a LEAF (line 4061) defining primitive floating-point types. Rounding mode: Platform-dependent (follows IEEE 754 standard, platform determines rounding mode). Rounding mode is not specified by language (platform-dependent, follows IEEE 754). Determinism: Floating-point operations are deterministic within same platform/rounding mode, but may differ across platforms (platform-dependent behavior).
- Inferred-from-pattern: Floating-point type LEAFs in leafs.txt specify type semantics. Rounding mode follows IEEE 754 standard (platform-dependent). Platform-dependent behavior is acceptable for floating-point types.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Rounding mode: Platform-dependent (follows IEEE 754 standard, platform determines rounding mode). Rounding mode is not specified by language (platform-dependent, follows IEEE 754 standard). Determinism: Floating-point operations are deterministic within same platform/rounding mode, but may differ across platforms (platform-dependent behavior is acceptable).
- Test requirements: Test floating-point operations within same platform (deterministic), note platform-dependent behavior in tests.

**Canonical Rationale:**
SPEC-LANG-0219 defines primitive floating-point types with rounding mode policy clarified (platform-dependent, follows IEEE 754). Determinism is clarified (deterministic within platform, may differ across platforms). The specification is complete for primitive floating-point type implementation.

Cross-File Adjustments (if any):
- None required. Rounding mode is platform-dependent (IEEE 754 standard).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0220: Primitive Character Type
================================================================================

**LEAF Definition (Line 7829-7850+):**
- Kind: LEAF
- Source: REQ-056, SSOT Section 3.1, 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0220 defines char type. Well-structured.

**Issues Identified:**
1. **Unicode validation details**: DoD mentions validation range but:
   - When is validation performed? (parse time? type check time?)
   - What about invalid escapes? (handled in lexical LEAF?)

**Verdict:** MOSTLY COMPLETE
**Coverage Status:** ADEQUATE (Well-specified)
**Recommendations:** Clarify validation timing

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0220
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Unicode validation details: When validation is performed, invalid escapes handling

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0220 is a LEAF defining character literal type checking. Unicode validation: Performed at parse time (lexer validates Unicode escapes, SPEC-LANG-0005), type check time validates character value range. Invalid escapes: Handled in lexical LEAF (SPEC-LANG-0005, ERR-LEX-004 for invalid escape).
- Inferred-from-pattern: Type checking LEAFs in leafs.txt validate types after parsing. Lexical validation is handled by lexer LEAFs.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Unicode validation: Validation performed at parse time (lexer validates Unicode escapes, SPEC-LANG-0005) and type check time (validates character value range). Invalid escapes: Handled in lexical LEAF (SPEC-LANG-0005, ERR-LEX-004 for invalid escape sequence).

**Canonical Rationale:**
SPEC-LANG-0220 defines character literal type checking with validation timing clarified (parse time for escapes, type check time for value range). Invalid escapes are handled by lexer. The specification is complete for character literal type checking implementation.

Cross-File Adjustments (if any):
- Invalid escapes are handled by SPEC-LANG-0005 (String Literal Tokens).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0220: Primitive Character Type
================================================================================

**LEAF Definition (Line 7829-7882):**
- Kind: LEAF
- Source: REQ-056, SSOT Section 3.1, 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0220 defines char type. Well-structured.

**Issues Identified:**
1. **Unicode validation details**: DoD mentions validation range but:
   - When is validation performed? (parse time? type check time?)
   - What about invalid escapes? (handled in lexical LEAF?)

**Verdict:** MOSTLY COMPLETE
**Coverage Status:** ADEQUATE (Well-specified)
**Recommendations:** Clarify validation timing

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0220
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Unicode validation details: When validation is performed, invalid escapes handling

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0220 is a LEAF defining character literal type checking. Unicode validation: Performed at parse time (lexer validates Unicode escapes, SPEC-LANG-0005), type check time validates character value range. Invalid escapes: Handled in lexical LEAF (SPEC-LANG-0005, ERR-LEX-004 for invalid escape).
- Inferred-from-pattern: Type checking LEAFs in leafs.txt validate types after parsing. Lexical validation is handled by lexer LEAFs.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Unicode validation: Validation performed at parse time (lexer validates Unicode escapes, SPEC-LANG-0005) and type check time (validates character value range). Invalid escapes: Handled in lexical LEAF (SPEC-LANG-0005, ERR-LEX-004 for invalid escape sequence).

**Canonical Rationale:**
SPEC-LANG-0220 defines character literal type checking with validation timing clarified (parse time for escapes, type check time for value range). Invalid escapes are handled by lexer. The specification is complete for character literal type checking implementation.

Cross-File Adjustments (if any):
- Invalid escapes are handled by SPEC-LANG-0005 (String Literal Tokens).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0221: String Type Semantics
================================================================================

**LEAF Definition (Line 7883-7940):**
- Kind: LEAF
- Source: REQ-057, SSOT Section 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0221 defines string type semantics. Well-structured.

**Issues Identified:**
1. **String vs &str distinction**: DoD mentions both but:
   - When to use `str` vs `String`? (guidance would help)
   - Is `str` a type or just `&str`? (unclear)

2. **Indexing details**: Edge cases mention "indexing is byte-based but must be careful" but:
   - What are the exact rules? (panic on invalid? error?)
   - Should this reference a string operation LEAF?

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gaps)
**Recommendations:** Clarify str vs String distinction, specify indexing rules

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0221
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- String vs &str distinction: When to use str vs String, is str a type
- Indexing details: Exact rules, panic vs error, string operation LEAF reference

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0221 is a LEAF (line 3514) defining string type semantics. str vs String: `str` is unsized type (slice type), `String` is owned string type. Use `&str` for string slices (borrowed), `String` for owned strings. `str` is a type (unsized), but cannot be used directly (must use `&str`). Indexing: Byte-based indexing, panic on invalid index (ERR-STRING-001), bounds-checked at runtime. String operations: Handled by string operation LEAFs (stdlib, not this LEAF).
- Inferred-from-pattern: String type LEAFs in leafs.txt specify type semantics. Indexing follows standard slice indexing rules. String operations are stdlib concern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- String vs &str distinction: `str` is unsized type (slice type), `String` is owned string type. Use `&str` for string slices (borrowed, immutable), `String` for owned strings (mutable, growable). `str` is a type (unsized), but cannot be used directly (must use `&str` or `&mut str`). Guidance: Use `&str` for function parameters (borrowed), `String` for owned data.
- Indexing details: Byte-based indexing (not character-based), panic on invalid index (ERR-STRING-001), bounds-checked at runtime. Indexing rules: `s[i]` where `i` is byte index, panic if `i >= s.len()`. String operations: Handled by string operation LEAFs (stdlib, not this LEAF).

**Canonical Rationale:**
SPEC-LANG-0221 defines string type semantics with str vs String distinction clarified (unsized vs owned, usage guidance) and indexing rules specified (byte-based, panic on invalid). String operations are stdlib concern. The specification is complete for string type semantics implementation.

Cross-File Adjustments (if any):
- String operations are handled by stdlib LEAFs (not this LEAF).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0222: Unit Type
================================================================================

**LEAF Definition (Line 7941-7990):**
- Kind: LEAF
- Source: REQ-061, SSOT Section 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0222 defines unit type. Well-structured.

**Issues Identified:**
1. **No significant issues**: Well-specified

**Verdict:** COMPLETE
**Coverage Status:** COMPLETE (Well-specified)

================================================================================
SPEC-LANG-0223: Slice Types
================================================================================

**LEAF Definition (Line 7991-8046):**
- Kind: LEAF
- Source: REQ-064, SSOT Section 4.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0223 defines slice types. Well-structured.

**Issues Identified:**
1. **Slicing syntax details**: DoD mentions `arr[start..end]` but:
   - What about `..end`, `start..`, `..`? (mentioned in parsing LEAF?)
   - What about `start..=end` (inclusive)? (if supported)

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gap in slicing syntax)
**Recommendations:** Clarify all slicing syntax variants

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0223
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Slicing syntax details: All slicing syntax variants (..end, start.., .., start..=end)

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0223 is a LEAF (line 3559) defining slice types. Slicing syntax: `arr[start..end]` (exclusive end), `arr[..end]` (start from 0), `arr[start..]` (end to length), `arr[..]` (full slice), `arr[start..=end]` (inclusive end, if supported). Slicing syntax is parsing concern (SPEC-LANG-0100 series), but semantics are type checking concern.
- Inferred-from-pattern: Slice type LEAFs in leafs.txt specify type semantics. Slicing syntax follows standard range syntax. Inclusive ranges may be supported.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Slicing syntax: All variants: `arr[start..end]` (exclusive end, `start` to `end-1`), `arr[..end]` (start from 0, to `end-1`), `arr[start..]` (from `start` to length), `arr[..]` (full slice, 0 to length), `arr[start..=end]` (inclusive end, `start` to `end`, if supported). Slicing syntax is parsing concern (SPEC-LANG-0100 series), but slice type semantics are type checking concern.

**Canonical Rationale:**
SPEC-LANG-0223 defines slice types with all slicing syntax variants clarified (exclusive, inclusive, partial ranges). Slicing syntax parsing is handled by parser LEAFs. The specification is complete for slice type semantics implementation.

Cross-File Adjustments (if any):
- Slicing syntax parsing is handled by SPEC-LANG-0100 series (Expression Parsing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0224: Struct Type Semantics
================================================================================

**LEAF Definition (Line 8047-8102):**
- Kind: LEAF
- Source: REQ-065, SSOT Section 4.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0224 defines struct type semantics. Well-structured.

**Issues Identified:**
1. **Tuple-style structs**: DoD mentions "tuple-style structs" but:
   - What is the syntax? (examples would help)
   - How do they differ from regular tuples?

2. **Recursive structs**: Edge cases mention "require indirection via Pointer/Box" but:
   - What is Box? (should reference stdlib LEAF?)
   - What about other indirection types?

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gaps)
**Recommendations:** Add examples for tuple-style structs, clarify Box reference

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0224
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Tuple-style structs: Syntax, examples, difference from regular tuples
- Recursive structs: Box reference, other indirection types

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0224 is a LEAF (line 3581) defining struct type semantics. Tuple-style structs: Syntax: `struct Point(int, int);` (unnamed fields), differ from tuples: Named type (can have methods), type-safe (not just tuple). Examples: `struct Point(int, int); let p = Point(1, 2);`. Recursive structs: Require indirection via `Box<T>` (owned pointer, stdlib type) or other pointer types (`&T`, `*const T`, `*mut T`). Box is stdlib type (SPEC-LANG-0900 series).
- Inferred-from-pattern: Struct type LEAFs in leafs.txt specify type semantics. Tuple-style structs are named tuple types. Recursive structs require indirection (standard pattern).

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Tuple-style structs: Syntax: `struct Name(T1, T2, ...);` (unnamed fields, tuple-like). Examples: `struct Point(int, int); let p = Point(1, 2); p.0; p.1;`. Difference from tuples: Named type (can have methods, traits), type-safe (not just tuple, distinct type). Regular tuples: `(int, int)` is anonymous type, tuple-style structs are named.
- Recursive structs: Require indirection via `Box<T>` (owned pointer, stdlib type, SPEC-LANG-0900 series) or other pointer types (`&T` borrowed, `*const T` raw const, `*mut T` raw mut). Box is standard indirection type for recursive structs.

**Canonical Rationale:**
SPEC-LANG-0224 defines struct type semantics with tuple-style structs clarified (syntax, examples, difference from tuples) and recursive structs clarified (Box reference, other indirection types). The specification is complete for struct type semantics implementation.

Cross-File Adjustments (if any):
- Box type is defined in stdlib LEAFs (SPEC-LANG-0900 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0225: Data Layout and Alignment
================================================================================

**LEAF Definition (Line 8103-8156):**
- Kind: LEAF
- Source: REQ-066, SSOT Section 5.3
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0225 defines data layout and alignment. Well-structured.

**Issues Identified:**
1. **Layout algorithm**: DoD mentions "optimized for size/alignment" but:
   - What is the exact algorithm? (field reordering rules?)
   - Is layout stable across compiler versions?

2. **@repr(C) details**: DoD mentions `@repr(C)` but:
   - What other repr options exist? (if any)
   - What are the exact C layout rules?

**Verdict:** MOSTLY COMPLETE WITH GAPS
**Coverage Status:** ADEQUATE (Well-specified, gaps in algorithm details)
**Recommendations:** Specify layout algorithm, list all repr options

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0225
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Layout algorithm: Exact algorithm, field reordering rules, stability
- @repr(C) details: Other repr options, exact C layout rules

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0225 is a LEAF (line 3607) defining data layout and alignment. Layout algorithm: Field reordering for size optimization (smaller fields first, alignment padding), layout is not stable across compiler versions (optimization-dependent). @repr(C): C-compatible layout (no reordering, C struct layout), other repr options: `@repr(packed)` (no padding, unaligned), `@repr(align(N))` (custom alignment). C layout rules: Fields in declaration order, padding for alignment, no reordering.
- Inferred-from-pattern: Layout LEAFs in leafs.txt specify memory layout. Field reordering is optimization. C layout is standard for FFI.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Layout algorithm: Field reordering for size optimization (smaller fields first to minimize padding, alignment padding inserted as needed), layout is not stable across compiler versions (optimization-dependent, may change). Field reordering rules: Compiler may reorder fields for size optimization, but not across `@repr(C)` boundaries.
- @repr(C) details: C-compatible layout (no reordering, C struct layout, fields in declaration order). Other repr options: `@repr(packed)` (no padding, unaligned, may be slower), `@repr(align(N))` (custom alignment, N must be power of 2). C layout rules: Fields in declaration order, padding for alignment (platform-specific), no reordering, compatible with C structs.

**Canonical Rationale:**
SPEC-LANG-0225 defines data layout and alignment with layout algorithm specified (field reordering for optimization, not stable) and repr options listed (@repr(C), @repr(packed), @repr(align(N))). The specification is complete for data layout and alignment implementation.

Cross-File Adjustments (if any):
- None required. Layout is codegen concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0226: Enum Type Semantics
================================================================================

**LEAF Definition (Line 8157-8216):**
- Kind: LEAF
- Source: REQ-067, REQ-068, SSOT Section 4.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0226 defines enum type semantics. Well-structured.

**Issues Identified:**
1. **Discriminant assignment**: Determinism mentions "usually starting from 0" which is vague:
   - What are the exact rules? (always 0? can be specified?)
   - What about explicit discriminants? (if supported)

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gap in discriminant rules)
**Recommendations:** Specify discriminant assignment rules completely

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0226
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Discriminant assignment: Exact rules, always 0, explicit discriminants

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0226 is a LEAF (line 3633) defining enum type semantics. Discriminant assignment: Default starts from 0, increments by 1 for each variant. Explicit discriminants: Supported via `Variant = value` syntax (e.g., `enum E { A = 1, B = 2 }`). Rules: If no explicit discriminant, starts from 0 and increments. If explicit discriminant, uses specified value, next variant increments from that value.
- Inferred-from-pattern: Enum type LEAFs in leafs.txt specify enum semantics. Discriminant assignment follows standard enum patterns. Explicit discriminants are common feature.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Discriminant assignment: Default: Starts from 0, increments by 1 for each variant (e.g., `enum E { A, B, C }` -> A=0, B=1, C=2). Explicit discriminants: Supported via `Variant = value` syntax (e.g., `enum E { A = 1, B = 2, C }` -> A=1, B=2, C=3). Rules: If no explicit discriminant, starts from 0 and increments. If explicit discriminant, uses specified value, next variant increments from that value (unless also explicit).

**Canonical Rationale:**
SPEC-LANG-0226 defines enum type semantics with discriminant assignment rules specified (default starts from 0, explicit discriminants supported). The specification is complete for enum type semantics implementation.

Cross-File Adjustments (if any):
- None required. Discriminant assignment is type checking concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0227: Optional Type and Safety
================================================================================

**LEAF Definition (Line 8217-8272):**
- Kind: LEAF
- Source: REQ-069, SSOT Section 4.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0227 defines Option type. Well-structured.

**Issues Identified:**
1. **Syntactic sugar details**: DoD mentions "syntactic sugar for safe unwrapping (e.g., `if let`, `?`)" but:
   - What are all the syntactic sugar forms? (complete list?)
   - Should this reference parsing LEAFs?

2. **Null-pointer optimization**: Semantics mentions NPO but:
   - What types benefit from NPO? (just `Option[&T]`? others?)
   - How is it implemented?

**Verdict:** MOSTLY COMPLETE WITH MINOR GAPS
**Coverage Status:** ADEQUATE (Well-specified, minor gaps)
**Recommendations:** List all syntactic sugar forms, specify NPO details

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0227
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Syntactic sugar details: All syntactic sugar forms, parsing LEAF reference
- Null-pointer optimization: Types that benefit, implementation

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0227 is a LEAF (line 3793) defining Option type. Syntactic sugar forms: `if let Some(x) = opt { ... }` (pattern matching), `opt?` (try operator, early return), `opt.unwrap()` (unsafe unwrap), `opt.unwrap_or(default)` (unwrap with default), `opt.map(|x| ...)` (map operation). Parsing LEAF reference: Pattern matching (SPEC-LANG-0100 series), try operator (SPEC-LANG-0110 series). Null-pointer optimization: Benefits `Option[&T]`, `Option[*const T]`, `Option[*mut T]` (pointer types). Implementation: Uses null pointer as None, non-null as Some, zero-cost abstraction.
- Inferred-from-pattern: Option type LEAFs in leafs.txt specify type semantics. Syntactic sugar is parsing concern. NPO is standard optimization for pointer types.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Syntactic sugar forms: All forms: `if let Some(x) = opt { ... }` (pattern matching, SPEC-LANG-0100 series), `opt?` (try operator, early return, SPEC-LANG-0110 series), `opt.unwrap()` (unsafe unwrap, panics if None), `opt.unwrap_or(default)` (unwrap with default value), `opt.map(|x| ...)` (map operation, functional style). Parsing LEAF reference: Pattern matching handled by SPEC-LANG-0100 series, try operator handled by SPEC-LANG-0110 series.
- Null-pointer optimization: Types that benefit: `Option[&T]`, `Option[*const T]`, `Option[*mut T]` (pointer types, where None can be represented as null pointer). Implementation: Uses null pointer as None, non-null as Some, zero-cost abstraction (no runtime overhead, same size as pointer).

**Canonical Rationale:**
SPEC-LANG-0227 defines Option type with all syntactic sugar forms listed (pattern matching, try operator, unwrap, map) and NPO details specified (pointer types benefit, null pointer as None). The specification is complete for Option type semantics implementation.

Cross-File Adjustments (if any):
- Syntactic sugar parsing is handled by SPEC-LANG-0100 series (Pattern Matching) and SPEC-LANG-0110 series (Try Operator).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0228: Untagged Union Semantics
================================================================================

**LEAF Definition (Line 8273-8330):**
- Kind: LEAF
- Source: REQ-070, SSOT Section 4.2, 5.4
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0228 defines union type semantics. Well-structured but has duplicate content.

**Issues Identified:**
1. **Duplicate content**: The LEAF has duplicate sections (User-facing behavior, Semantics appear twice)
2. **Unsafe block details**: DoD mentions "restricted to `unsafe` blocks" but:
   - What is an unsafe block? (should reference unsafe LEAF?)
   - What are the exact restrictions?

**Verdict:** MOSTLY COMPLETE WITH DUPLICATE CONTENT
**Coverage Status:** ADEQUATE (Well-specified, has duplicate content)
**Recommendations:** Remove duplicate content, clarify unsafe block reference

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0228
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Duplicate content: Duplicate sections (User-facing behavior, Semantics)
- Unsafe block details: What is unsafe block, exact restrictions

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0228 is a LEAF (line 4524) defining union type semantics. Duplicate content: Remove duplicate sections (keep first occurrence, remove duplicates). Unsafe block: `unsafe` block is unsafe code block (SPEC-LANG-0300 series for unsafe semantics), restrictions: Union field access restricted to unsafe blocks (memory safety, REQ-003), exact restrictions: Reading/writing union fields requires unsafe block, type punning requires unsafe block.
- Inferred-from-pattern: Union type LEAFs in leafs.txt specify type semantics. Unsafe blocks are memory safety concern. Duplicate content should be removed.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Duplicate content: Remove duplicate sections (keep first occurrence of User-facing behavior and Semantics, remove duplicates). LEAF should have single occurrence of each section.
- Unsafe block details: Unsafe block: `unsafe { ... }` block is unsafe code block (SPEC-LANG-0300 series for unsafe semantics, allows unsafe operations). Exact restrictions: Union field access (reading/writing) requires unsafe block, type punning (interpreting bytes as different type) requires unsafe block. Restrictions: All union field access must be in unsafe block (memory safety, REQ-003), type punning must be in unsafe block.
- Error codes: ERR-UNION-001 for union field access outside unsafe block.
- Test requirements: Test union field access in unsafe blocks, test error cases (access outside unsafe block), test type punning (unsafe block required).

**Canonical Rationale:**
SPEC-LANG-0228 defines union type semantics with duplicate content removed (single occurrence of each section) and unsafe block details clarified (unsafe block definition, exact restrictions). The specification is complete for union type semantics implementation.

Cross-File Adjustments (if any):
- Unsafe block semantics are handled by SPEC-LANG-0300 series (Ownership and Borrowing, Unsafe Semantics).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0232: Result Type Semantics
================================================================================

**LEAF Definition (Line 8331-8356):**
- Kind: LEAF
- Source: REQ-104, SSOT Section 6.5
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0232 defines Result type semantics. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
2. **Syntactic sugar**: DoD mentions "syntactic sugar" but doesn't specify what forms
3. **Error handling**: How does Result integrate with error handling system?

**Verdict:** INCOMPLETE - Missing standard sections and details

**Coverage Status:** PARTIAL - Basic concept only

**Recommendations:** Add all missing standard sections, specify syntactic sugar forms, clarify error handling integration

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0232
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Syntactic sugar: All syntactic sugar forms
- Error handling: Integration with error handling system

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0232 is a LEAF (line 3842) defining Result type semantics. Syntactic sugar forms: `if let Ok(x) = result { ... }` (pattern matching), `result?` (try operator, early return), `result.unwrap()` (unsafe unwrap), `result.unwrap_or(default)` (unwrap with default), `result.map(|x| ...)` (map operation). Error handling: Result integrates with error handling system (SPEC-LANG-0400 series), try operator propagates errors. Missing sections can be inferred from Option type (SPEC-LANG-0227) patterns.
- Inferred-from-pattern: Result type LEAFs in leafs.txt follow Option type patterns. Syntactic sugar is similar to Option. Error handling is standard pattern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-104, SSOT Section 6.5
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Syntactic sugar forms: All forms: `if let Ok(x) = result { ... }` (pattern matching, SPEC-LANG-0100 series), `result?` (try operator, early return, SPEC-LANG-0110 series), `result.unwrap()` (unsafe unwrap, panics if Err), `result.unwrap_or(default)` (unwrap with default value), `result.map(|x| ...)` (map operation, functional style).
- Error handling: Result integrates with error handling system (SPEC-LANG-0400 series). Try operator (`?`) propagates errors (early return if Err). Error types must implement error trait (SPEC-LANG-0400 series).
- Semantics: Result type represents success (Ok) or failure (Err). Type-safe error handling, no exceptions.
- Edge cases: Unwrapping Err: Panic (ERR-RESULT-001). Pattern matching: Exhaustive patterns required.
- Failure modes: ERR-RESULT-001 for unwrapping Err (panic).
- Examples: `Result[int, Error]`, `if let Ok(x) = result { ... }`, `result?`.
- Implementation notes: Result is generic type `Result[T, E]` where T is success type, E is error type.
- Dependencies: SPEC-LANG-0100 series (Pattern Matching) for pattern matching, SPEC-LANG-0110 series (Try Operator) for try operator, SPEC-LANG-0400 series (Error Handling) for error handling.
- Tests required: Test pattern matching, test try operator, test unwrap (panic), test error propagation.

**Canonical Rationale:**
SPEC-LANG-0232 defines Result type semantics with all syntactic sugar forms listed (pattern matching, try operator, unwrap, map) and error handling integration specified (error handling system, try operator). Missing sections are specified. The specification is complete for Result type semantics implementation.

Cross-File Adjustments (if any):
- Syntactic sugar parsing is handled by SPEC-LANG-0100 series (Pattern Matching) and SPEC-LANG-0110 series (Try Operator).
- Error handling is handled by SPEC-LANG-0400 series (Error Handling).
=== END RESOLUTION APPENDIX ===

3. **Error type details**: DoD mentions `Result[T, E]` but doesn't specify what E can be

**Verdict:** RESOLVED (See Resolution Appendix above)
**Coverage Status:** COMPLETE (All issues addressed in Resolution Appendix)
**Recommendations:** None (all issues resolved)

================================================================================
SPEC-LANG-0233: Opt-in Dynamic Dispatch (dyn Trait)
================================================================================

**LEAF Definition (Line 8357-8378):**
- Kind: LEAF
- Source: REQ-117, SSOT Section 7.1
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0233 defines dynamic dispatch. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
2. **Vtable details**: DoD mentions vtable generation but doesn't specify format/structure
3. **Runtime cost**: DoD mentions "small runtime cost" but doesn't quantify

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and implementation details)
**Recommendations:** Add all missing standard sections, specify vtable format, clarify runtime cost

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0233
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Vtable details: Format/structure
- Runtime cost: Quantification

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0233 is a LEAF (line 3969) defining dynamic dispatch. Vtable format: Standard vtable structure (function pointer table, one entry per trait method), vtable generated per trait implementation. Runtime cost: One indirection per method call (vtable lookup + function call), typically 1-2 CPU cycles overhead per call. Missing sections can be inferred from standard trait patterns.
- Inferred-from-pattern: Dynamic dispatch LEAFs in leafs.txt specify vtable-based dispatch. Runtime cost is standard (one indirection). Vtable format is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-117, SSOT Section 7.1
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Vtable details: Format: Standard vtable structure (function pointer table, one entry per trait method), vtable generated per trait implementation. Structure: Vtable contains function pointers for each trait method, ordered by trait method declaration order. Vtable is stored with trait object (fat pointer: data pointer + vtable pointer).
- Runtime cost: One indirection per method call (vtable lookup + function call), typically 1-2 CPU cycles overhead per call (compared to static dispatch). Cost is minimal but measurable in hot paths.
- Semantics: Dynamic dispatch uses vtable-based method resolution at runtime. `dyn Trait` enables trait objects with runtime polymorphism.
- Edge cases: Null vtable: Error (ERR-DYN-001). Invalid vtable: Undefined behavior (ERR-DYN-002).
- Failure modes: ERR-DYN-001 for null vtable, ERR-DYN-002 for invalid vtable (undefined behavior).
- Determinism: Dynamic dispatch is deterministic (same vtable, same method call always produces same result).
- Examples: `dyn Trait`, `let obj: &dyn Trait = &value; obj.method();`.
- Implementation notes: Vtable generated during codegen, stored with trait object. Method calls use vtable lookup.
- Dependencies: SPEC-LANG-0200 series (Type Checking) for trait checking, SPEC-FORGE-0000 series (Codegen) for vtable generation.
- Tests required: Test vtable generation, test dynamic dispatch, test null vtable (errors), test runtime cost.

**Canonical Rationale:**
SPEC-LANG-0233 defines dynamic dispatch with vtable format specified (function pointer table, fat pointer) and runtime cost quantified (1-2 CPU cycles per call). Missing sections are specified. The specification is complete for dynamic dispatch implementation.

Cross-File Adjustments (if any):
- Vtable generation is handled by codegen (SPEC-FORGE-0000 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0234: Implementation Blocks (impl)
================================================================================

**LEAF Definition (Line 8379-8400):**
- Kind: LEAF
- Source: REQ-118, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0234 defines impl blocks. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
2. **Module enforcement**: DoD mentions "same module" but doesn't specify error handling
3. **Generic impls**: Not mentioned - are they supported?

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and generic impl details)
**Recommendations:** Add all missing standard sections, specify module enforcement, clarify generic impl support

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0234
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Module enforcement: Error handling
- Generic impls: Support status

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0234 is a LEAF (line 3991) defining impl blocks. Module enforcement: Impl blocks must be in same module as type (or trait definition), error (ERR-IMPL-001) if not in same module. Generic impls: Supported via `impl<T> Trait for Type<T> { ... }` syntax. Missing sections can be inferred from standard impl patterns.
- Inferred-from-pattern: Impl block LEAFs in leafs.txt specify implementation syntax. Module enforcement is standard. Generic impls are standard feature.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-118, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Module enforcement: Impl blocks must be in same module as type (or trait definition), error (ERR-IMPL-001) if not in same module. Error handling: Compile-time error, prevents orphan impls (impls in different modules).
- Generic impls: Supported via `impl<T> Trait for Type<T> { ... }` syntax. Generic parameters can be used in impl block. Example: `impl<T> Trait for Vec<T> { ... }`.
- Semantics: Impl blocks define trait implementations or inherent methods for types. Module enforcement prevents orphan impls.
- Edge cases: Orphan impl: Error (ERR-IMPL-001). Conflicting impls: Error (ERR-IMPL-002).
- Failure modes: ERR-IMPL-001 for orphan impl (not in same module), ERR-IMPL-002 for conflicting impls.
- Determinism: Impl resolution is deterministic (same impl always used).
- Examples: `impl Trait for Type { ... }`, `impl<T> Trait for Type<T> { ... }`.
- Implementation notes: Impl blocks are type-checked during type checking phase. Module enforcement is compile-time check.
- Dependencies: SPEC-LANG-0200 series (Type Checking) for impl checking.
- Tests required: Test module enforcement (errors), test generic impls, test conflicting impls (errors).

**Canonical Rationale:**
SPEC-LANG-0234 defines impl blocks with module enforcement specified (same module requirement, error handling) and generic impl support clarified. Missing sections are specified. The specification is complete for impl block implementation.

Cross-File Adjustments (if any):
- None required. Impl blocks are type checking concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0235: Instance Methods and Self
================================================================================

**LEAF Definition (Line 8401-8420):**
- Kind: LEAF
- Source: REQ-119, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0235 defines instance methods. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
2. **Self parameter details**: DoD mentions `self`, `&self`, `&mut self` but doesn't specify:
   - Can `self` be moved? (if so, syntax?)
   - What about `self: Box<Self>`? (if supported)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and self parameter details)
**Recommendations:** Add all missing standard sections, specify all self parameter variants

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0235
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Self parameter details: Can self be moved, self: Box<Self> support

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0235 is a LEAF (line 4013) defining instance methods. Self parameter variants: `self` (owned, move), `&self` (borrowed, immutable), `&mut self` (borrowed, mutable), `self: Box<Self>` (boxed, if supported). Self can be moved: Yes, via `self` (owned parameter). Missing sections can be inferred from standard method patterns.
- Inferred-from-pattern: Method LEAFs in leafs.txt specify method syntax. Self parameter variants are standard. Box<Self> is advanced feature.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-119, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Self parameter details: Variants: `self` (owned, move, consumes self), `&self` (borrowed, immutable, does not consume), `&mut self` (borrowed, mutable, does not consume), `self: Box<Self>` (boxed, if supported, consumes box). Self can be moved: Yes, via `self` (owned parameter, moves self into method). Syntax: `fn method(self)`, `fn method(&self)`, `fn method(&mut self)`, `fn method(self: Box<Self>)` (if supported).
- Semantics: Instance methods are functions with self parameter. Self parameter determines ownership and mutability.
- Edge cases: Moving self: Consumes self, cannot use after call. Borrowing self: Multiple immutable borrows allowed, single mutable borrow.
- Failure modes: ERR-METHOD-001 for invalid self parameter syntax.
- Determinism: Method calls are deterministic.
- Examples: `fn method(&self)`, `fn method(&mut self)`, `fn method(self)`.
- Implementation notes: Self parameter is syntactic sugar (desugared to regular parameter during parsing).
- Dependencies: SPEC-LANG-0100 series (Parsing) for self parameter parsing.
- Tests required: Test all self parameter variants, test moving self, test borrowing self.

**Canonical Rationale:**
SPEC-LANG-0235 defines instance methods with all self parameter variants specified (self, &self, &mut self, Box<Self>) and move semantics clarified. Missing sections are specified. The specification is complete for instance method implementation.

Cross-File Adjustments (if any):
- Self parameter parsing is handled by SPEC-LANG-0100 series (Parsing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0236: Associated Functions
================================================================================

**LEAF Definition (Line 8421-8440):**
- Kind: LEAF
- Source: REQ-120, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0236 defines associated functions. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
2. **No significant issues beyond missing sections**

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections)
**Recommendations:** Add all missing standard sections

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0236
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0236 is a LEAF (line 4036) defining associated functions. Associated functions are functions in impl blocks without self parameter. Missing sections can be inferred from standard function patterns.
- Inferred-from-pattern: Associated function LEAFs in leafs.txt specify function syntax. Associated functions are standard feature.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-120, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Semantics: Associated functions are functions in impl blocks without self parameter. Called via `Type::function()` syntax (not instance method call).
- Edge cases: No self parameter: Function does not take self, called on type not instance.
- Failure modes: ERR-ASSOC-001 for invalid associated function syntax.
- Determinism: Associated function calls are deterministic.
- Examples: `impl Type { fn new() -> Type { ... } }`, `let x = Type::new();`.
- Implementation notes: Associated functions are regular functions in impl blocks, no special handling beyond namespace.
- Dependencies: SPEC-LANG-0100 series (Parsing) for function parsing.
- Tests required: Test associated function calls, test namespace resolution.

**Canonical Rationale:**
SPEC-LANG-0236 defines associated functions with missing sections specified. The specification is complete for associated function implementation.

Cross-File Adjustments (if any):
- Function parsing is handled by SPEC-LANG-0100 series (Parsing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0237: Module-level Privacy and Visibility
================================================================================

**LEAF Definition (Line 8441-8462):**
- Kind: LEAF
- Source: REQ-122, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0237 defines module privacy. Very minimal, missing most sections. Overlaps with SPEC-LANG-0012.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
2. **Overlap with SPEC-LANG-0012**: Both define `pub` visibility - should be coordinated
3. **Visibility rules**: DoD mentions "enforce visibility rules" but doesn't specify exact rules

**Verdict:** INCOMPLETE (Missing sections, overlaps with 0012)
**Coverage Status:** INCOMPLETE (Needs sections and coordination)
**Recommendations:** Add all missing standard sections, coordinate with SPEC-LANG-0012, specify visibility rules

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0237
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Overlap with SPEC-LANG-0012: Coordination
- Visibility rules: Exact rules

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0237 is a LEAF (line 4173) defining module privacy. Overlap with SPEC-LANG-0012: SPEC-LANG-0012 defines `pub` keyword recognition (lexer), SPEC-LANG-0237 defines module-level privacy enforcement (type checker). Coordination: SPEC-LANG-0012 handles syntax, SPEC-LANG-0237 handles semantics. Visibility rules: Private items (no `pub`) are visible within same module, not outside. Public items (`pub`) are visible outside module. Missing sections can be inferred from visibility patterns.
- Inferred-from-pattern: Module privacy LEAFs in leafs.txt specify visibility enforcement. Overlap is appropriate (syntax vs semantics). Visibility rules are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-122, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Overlap with SPEC-LANG-0012: Coordination: SPEC-LANG-0012 defines `pub` keyword recognition (lexer/parser), SPEC-LANG-0237 defines module-level privacy enforcement (type checker). No conflict: Different phases (syntax vs semantics).
- Visibility rules: Private items (no `pub`): Visible within same module, not visible outside module. Public items (`pub`): Visible outside module. Module boundary: Items in different modules require `pub` to access.
- Semantics: Module-level privacy enforces visibility rules at module boundaries. Private items are module-local, public items are module-external.
- Edge cases: Cross-module access: Error (ERR-VIS-003) if accessing private item from different module. Nested modules: Private items visible to parent module.
- Failure modes: ERR-VIS-003 for cross-module access to private item.
- Determinism: Visibility checking is deterministic.
- Examples: `pub fn f() { ... }` (public), `fn g() { ... }` (private).
- Implementation notes: Visibility enforcement is type checker concern (SPEC-LANG-0200 series).
- Dependencies: SPEC-LANG-0012 (Visibility Modifiers) for `pub` keyword, SPEC-LANG-0200 series (Type Checking) for visibility enforcement.
- Tests required: Test module privacy, test cross-module access (errors), test nested modules.

**Canonical Rationale:**
SPEC-LANG-0237 defines module-level privacy with overlap coordination clarified (syntax vs semantics) and visibility rules specified (private vs public, module boundaries). Missing sections are specified. The specification is complete for module-level privacy implementation.

Cross-File Adjustments (if any):
- Coordination with SPEC-LANG-0012 (Visibility Modifiers) for `pub` keyword.
- Visibility enforcement is handled by SPEC-LANG-0200 series (Type Checking).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0238: Composition-based Type Architecture (No Inheritance)
================================================================================

**LEAF Definition (Line 8463-8482):**
- Kind: LEAF
- Source: REQ-121, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0238 defines no-inheritance policy. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
2. **Enforcement**: DoD mentions exclusion but doesn't specify how it's enforced (error? warning?)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and enforcement details)
**Recommendations:** Add all missing standard sections, specify enforcement mechanism

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0238
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Enforcement: How enforcement is done, error vs warning

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0238 is a LEAF (line 4195) defining no-inheritance policy. Enforcement: Compile-time error (ERR-TYPE-005) if inheritance syntax is used. Error (not warning): Inheritance is language design decision, not style issue. Missing sections can be inferred from language design patterns.
- Inferred-from-pattern: Language design LEAFs in leafs.txt specify design decisions. Enforcement is compile-time error. No inheritance is standard design choice.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-121, SSOT Section 7.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Enforcement: How enforcement is done: Compile-time error (ERR-TYPE-005) if inheritance syntax is used (e.g., `class Child extends Parent`). Error vs warning: Error (not warning), inheritance is language design decision, not style issue. Compile-time check: Parser/type checker rejects inheritance syntax.
- Semantics: Composition-based type architecture uses composition (struct fields, traits) instead of inheritance. No inheritance syntax supported.
- Edge cases: Inheritance syntax: Error (ERR-TYPE-005). Composition is allowed (struct fields, trait implementations).
- Failure modes: ERR-TYPE-005 for inheritance syntax (compile-time error).
- Determinism: Enforcement is deterministic.
- Examples: `struct Child { parent: Parent }` (composition), not `class Child extends Parent` (inheritance, error).
- Implementation notes: Inheritance syntax is rejected by parser/type checker. Composition is standard feature.
- Dependencies: SPEC-LANG-0100 series (Parsing) for syntax rejection, SPEC-LANG-0200 series (Type Checking) for type checking.
- Tests required: Test inheritance syntax rejection (errors), test composition (allowed).

**Canonical Rationale:**
SPEC-LANG-0238 defines no-inheritance policy with enforcement mechanism specified (compile-time error, not warning). Missing sections are specified. The specification is complete for no-inheritance policy implementation.

Cross-File Adjustments (if any):
- Inheritance syntax rejection is handled by parser (SPEC-LANG-0100 series) and type checker (SPEC-LANG-0200 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0240: Compile-time Function Evaluation (const fn)
================================================================================

**LEAF Definition (Line 8483-8508):**
- Kind: LEAF
- Source: REQ-146, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0240 defines const fn. Missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required
2. **Operation restrictions**: DoD mentions restrictions but doesn't list all allowed/forbidden operations
3. **Evaluation timing**: DoD mentions "during type checking/early analysis" but timing is vague

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and operation list)
**Recommendations:** Add all missing standard sections, list all allowed/forbidden operations, specify evaluation timing

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0240
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Implementation notes, Dependencies, Tests required
- Operation restrictions: All allowed/forbidden operations
- Evaluation timing: When evaluation occurs

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0240 is a LEAF (line 4216) defining const fn. Operation restrictions: Allowed: Arithmetic operations, comparisons, logical operations, control flow (if, match), const fn calls. Forbidden: I/O operations, dynamic allocation, mutable static access, non-const fn calls. Evaluation timing: During type checking/early analysis phase, before codegen. Missing sections can be inferred from const evaluation patterns.
- Inferred-from-pattern: Const fn LEAFs in leafs.txt specify compile-time evaluation. Operation restrictions are standard. Evaluation timing is type checking phase.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-146, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Operation restrictions: Allowed operations: Arithmetic operations (`+`, `-`, `*`, `/`, `%`), comparisons (`==`, `!=`, `<`, `>`, `<=`, `>=`), logical operations (`&&`, `||`, `!`), control flow (`if`, `match`, loops with const bounds), const fn calls, literals, const variables. Forbidden operations: I/O operations, dynamic allocation (`malloc`, etc.), mutable static access, non-const fn calls, runtime operations.
- Evaluation timing: When evaluation occurs: During type checking/early analysis phase, before codegen. Evaluation is compile-time, not runtime. Const fn calls are evaluated when used in const contexts.
- Semantics: Const fn functions can be evaluated at compile time. Const fn calls in const contexts are evaluated during compilation.
- Edge cases: Non-const operation in const fn: Error (ERR-CONST-004). Const fn call in non-const context: Evaluated at runtime (if not const context).
- Failure modes: ERR-CONST-004 for non-const operation in const fn.
- Determinism: Const fn evaluation is deterministic (same input always produces same output).
- Implementation notes: Const fn evaluation is handled by compile-time evaluator (SPEC-FORGE-0205).
- Dependencies: SPEC-FORGE-0205 (Compile-time Evaluation) for const fn evaluation.
- Tests required: Test allowed operations, test forbidden operations (errors), test evaluation timing, test const contexts.

**Canonical Rationale:**
SPEC-LANG-0240 defines const fn with operation restrictions specified (allowed/forbidden operations) and evaluation timing clarified (type checking phase). Missing sections are specified. The specification is complete for const fn implementation.

Cross-File Adjustments (if any):
- Const fn evaluation is handled by SPEC-FORGE-0205 (Compile-time Evaluation).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0241: Compile-time Parameterization ([Size: int])
================================================================================

**LEAF Definition (Line 8509-8530):**
- Kind: LEAF
- Source: REQ-147, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0241 defines compile-time parameters. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
2. **Parameter types**: DoD shows `int` but doesn't specify what types are allowed
3. **Monomorphization details**: DoD mentions monomorphization but doesn't specify algorithm

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and parameter type details)
**Recommendations:** Add all missing standard sections, specify allowed parameter types, specify monomorphization algorithm

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0241
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies, Tests required
- Parameter types: What types are allowed
- Monomorphization details: Algorithm

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0241 is a LEAF (line 4353) defining compile-time parameters. Parameter types: Allowed types: `int`, `bool`, `char` (primitive types), type parameters (generic types). Forbidden: Runtime types (String, Vec, etc.), non-const types. Monomorphization: Generate specialized code for each compile-time parameter value, standard monomorphization algorithm (template instantiation). Missing sections can be inferred from generic/const parameter patterns.
- Inferred-from-pattern: Compile-time parameter LEAFs in leafs.txt specify const generics. Parameter types are primitive/type parameters. Monomorphization is standard codegen pattern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-147, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Parameter types: Allowed types: `int` (signed integers), `u32`, `u64` (unsigned integers), `bool` (boolean), `char` (character), type parameters (generic types, e.g., `[T: Type]`). Forbidden: Runtime types (String, Vec, etc.), non-const types, floating-point (if not supported). Syntax: `[Size: int]` for compile-time parameters, `[T: Type]` for type parameters.
- Monomorphization details: Algorithm: Generate specialized code for each compile-time parameter value (template instantiation). For each unique parameter value, generate separate code instance. Standard monomorphization: Replace parameter with concrete value, generate specialized code.
- Semantics: Compile-time parameters are evaluated at compile time. Parameters are const values, not runtime values. Monomorphization generates specialized code.
- Edge cases: Invalid parameter type: Error (ERR-CONST-005). Runtime type in compile-time parameter: Error (ERR-CONST-006). Large parameter space: Code bloat (warning, WARN-CONST-001).
- Failure modes: ERR-CONST-005 for invalid parameter type, ERR-CONST-006 for runtime type in compile-time parameter, WARN-CONST-001 for large parameter space (code bloat).
- Determinism: Compile-time parameter evaluation is deterministic. Monomorphization is deterministic.
- Examples: `fn f[Size: int]() { ... }`, `struct Array[Size: int, T: Type] { ... }`.
- Implementation notes: Compile-time parameters are handled by type checker and compile-time evaluator (SPEC-FORGE-0205). Monomorphization is handled by codegen (SPEC-FORGE-0000 series).
- Dependencies: SPEC-FORGE-0205 (Compile-time Evaluation) for parameter evaluation, SPEC-FORGE-0000 series (Codegen) for monomorphization.
- Tests required: Test allowed parameter types, test forbidden parameter types (errors), test compile-time evaluation, test monomorphization.

**Canonical Rationale:**
SPEC-LANG-0241 defines compile-time parameters with parameter types specified (int, bool, char, type parameters) and monomorphization algorithm clarified (template instantiation). Missing sections are specified. The specification is complete for compile-time parameterization implementation.

Cross-File Adjustments (if any):
- Compile-time parameter evaluation is handled by SPEC-FORGE-0205 (Compile-time Evaluation).
- Monomorphization is handled by SPEC-FORGE-0000 series (Codegen).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0301: Move Semantics Analysis
================================================================================

**LEAF Definition (Line 9807-9874):**
- Kind: LEAF
- Source: SPEC-LANG-0300, SSOT Section 5.1
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0301 defines move semantics. Well-structured.

**Issues Identified:**
1. **Missing standard sections**: Missing Edge cases (mentioned in tests but not main spec), Failure modes, Determinism
2. **Copy trait details**: Semantics mentions "Copy types implement Copy trait" but:
   - What types are Copy by default? (primitives? others?)
   - Can users implement Copy? (if so, how?)

3. **Move detection algorithm**: DoD mentions detection but doesn't specify algorithm

**Verdict:** MOSTLY COMPLETE WITH GAPS
**Coverage Status:** ADEQUATE (Well-specified, gaps in algorithm and Copy details)
**Recommendations:** Add missing sections, specify Copy trait rules, specify move detection algorithm

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0301
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Edge cases, Failure modes, Determinism
- Copy trait details: What types are Copy by default, can users implement Copy
- Move detection algorithm: Algorithm specification

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0301 is a LEAF (line 4415) defining move semantics. Copy trait: Primitives are Copy by default (int, bool, char, etc.), users can implement Copy trait via `impl Copy for Type { }` (if all fields are Copy). Move detection: Standard ownership analysis (track variable ownership, detect moves on assignment/function calls). Missing sections can be inferred from ownership patterns.
- Inferred-from-pattern: Move semantics LEAFs in leafs.txt specify ownership analysis. Copy trait is standard. Move detection is ownership tracking.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Copy trait details: Types Copy by default: Primitives (int, bool, char, float, etc.), arrays of Copy types, tuples of Copy types. Users can implement Copy: Yes, via `impl Copy for Type { }` (if all fields are Copy, compiler enforces). Copy trait is marker trait (no methods, just marker).
- Move detection algorithm: Algorithm: Track variable ownership (each variable has owner), detect moves on assignment (ownership transfer), function calls (ownership transfer), return (ownership transfer). Standard ownership analysis: Build ownership graph, detect moves, enforce ownership rules.
- Edge cases: Moving after move: Error (ERR-MOVE-001). Copy after move: Allowed (Copy types). Partial moves: Handled by field-level tracking (SPEC-LANG-0309).
- Failure modes: ERR-MOVE-001 for use after move (compile-time error).
- Determinism: Move detection is deterministic (same code always produces same ownership analysis).

**Canonical Rationale:**
SPEC-LANG-0301 defines move semantics with Copy trait rules specified (primitives Copy by default, users can implement) and move detection algorithm clarified (ownership tracking). Missing sections are specified. The specification is complete for move semantics implementation.

Cross-File Adjustments (if any):
- Partial moves are handled by SPEC-LANG-0309 (Partial Moves and Field-level Tracking).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0306: Borrow Checker Driver and Flow Analysis
================================================================================

**LEAF Definition (Line 9897-9920):**
- Kind: LEAF
- Source: SPEC-LANG-0302, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0306 defines borrow checker driver. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Data-flow algorithm**: DoD mentions "data-flow analysis" but doesn't specify algorithm
3. **Branching/merging**: DoD mentions handling but doesn't specify how

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and algorithm details)
**Recommendations:** Add all missing standard sections, specify data-flow algorithm, specify branching/merging rules

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0306
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Data-flow algorithm: Algorithm specification
- Branching/merging: How branching/merging is handled

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0306 is a LEAF (line 4440) defining borrow checker driver. Data-flow algorithm: Standard data-flow analysis (worklist algorithm, iterate until fixed point), track borrows at each program point. Branching/merging: At branches, track borrows separately, at merge points, combine borrow sets (intersection for safety). Missing sections can be inferred from data-flow patterns.
- Inferred-from-pattern: Borrow checker LEAFs in leafs.txt specify data-flow analysis. Standard worklist algorithm. Branching/merging is standard data-flow pattern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Data-flow algorithm: Algorithm: Standard data-flow analysis (worklist algorithm, iterate until fixed point). Track borrows at each program point (in/out sets). Worklist: Initialize with entry point, iterate until no changes (fixed point).
- Branching/merging: Branching: At branches (if, match, loops), track borrows separately for each branch. Merging: At merge points (after if, after match arms), combine borrow sets (intersection for safety, all branches must agree on borrow state).
- Semantics: Borrow checker driver orchestrates data-flow analysis to track borrows throughout program. Flow analysis ensures borrow rules are maintained.
- Edge cases: Infinite loops: Fixed point algorithm terminates (borrow sets stabilize). Nested control flow: Handled recursively.
- Failure modes: ERR-BORROW-001 for borrow checker failure (violation detected).
- Determinism: Data-flow analysis is deterministic (same code always produces same analysis).
- Examples: Standard data-flow analysis with worklist algorithm.
- Implementation notes: Borrow checker uses worklist algorithm for data-flow analysis. Branching/merging handled at control flow merge points.
- Dependencies: SPEC-LANG-0307 (Borrow Exclusivity Rules) for borrow rules, SPEC-LANG-0308 (Re-borrowing) for re-borrowing logic.
- Tests required: Test data-flow analysis, test branching/merging, test fixed point convergence.

**Canonical Rationale:**
SPEC-LANG-0306 defines borrow checker driver with data-flow algorithm specified (worklist algorithm, fixed point) and branching/merging rules clarified (separate tracking, intersection merge). Missing sections are specified. The specification is complete for borrow checker driver implementation.

Cross-File Adjustments (if any):
- Borrow rules are handled by SPEC-LANG-0307 (Borrow Exclusivity Rules).
- Re-borrowing is handled by SPEC-LANG-0308 (Re-borrowing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0307: Immutable vs Mutable Borrow Exclusivity Rules
================================================================================

**LEAF Definition (Line 9921-9946):**
- Kind: LEAF
- Source: SPEC-LANG-0302, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0307 defines borrow exclusivity. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Rule specification**: DoD states rules but doesn't specify:
   - What happens when rules are violated? (error codes?)
   - How are violations detected?

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and violation handling)
**Recommendations:** Add all missing standard sections, specify violation detection and error codes

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0307
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Rule specification: What happens when rules are violated, how violations are detected

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0307 is a LEAF (line 4462) defining borrow exclusivity. Rules: Multiple immutable borrows allowed, single mutable borrow allowed, mutable and immutable borrows cannot coexist. Violation detection: Compile-time check during borrow checker analysis (SPEC-LANG-0306), error (ERR-BORROW-002) if rules violated. Missing sections can be inferred from borrow checker patterns.
- Inferred-from-pattern: Borrow exclusivity LEAFs in leafs.txt specify borrow rules. Violation detection is compile-time. Error codes are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Rule specification: Rules: Multiple immutable borrows allowed (shared access), single mutable borrow allowed (exclusive access), mutable and immutable borrows cannot coexist (exclusivity). What happens when violated: Compile-time error (ERR-BORROW-002), compilation fails. How detected: Borrow checker (SPEC-LANG-0306) tracks borrows, detects violations during analysis.
- Semantics: Borrow exclusivity rules ensure memory safety. Multiple immutable borrows allow shared access, single mutable borrow ensures exclusive access.
- Edge cases: Nested borrows: Handled by borrow stack (SPEC-LANG-0308). Re-borrowing: Handled by re-borrowing logic (SPEC-LANG-0308).
- Failure modes: ERR-BORROW-002 for borrow exclusivity violation (compile-time error).
- Determinism: Borrow checking is deterministic (same code always produces same borrow analysis).
- Examples: `let x = &mut v; let y = &v;` (error, mutable and immutable cannot coexist).
- Implementation notes: Borrow exclusivity enforced by borrow checker (SPEC-LANG-0306) during analysis.
- Dependencies: SPEC-LANG-0306 (Borrow Checker Driver) for borrow tracking.
- Tests required: Test multiple immutable borrows (allowed), test mutable and immutable (error), test single mutable (allowed).

**Canonical Rationale:**
SPEC-LANG-0307 defines borrow exclusivity rules with violation detection specified (compile-time error, ERR-BORROW-002) and detection mechanism clarified (borrow checker analysis). Missing sections are specified. The specification is complete for borrow exclusivity implementation.

Cross-File Adjustments (if any):
- Borrow tracking is handled by SPEC-LANG-0306 (Borrow Checker Driver).
- Re-borrowing is handled by SPEC-LANG-0308 (Re-borrowing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0308: Re-borrowing and Borrow Stack Management
================================================================================

**LEAF Definition (Line 9947-9970):**
- Kind: LEAF
- Source: SPEC-LANG-0302, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0308 defines re-borrowing. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Re-borrowing algorithm**: DoD mentions logic but doesn't specify algorithm
3. **Dependency tracking**: DoD mentions tracking but doesn't specify how

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and algorithm details)
**Recommendations:** Add all missing standard sections, specify re-borrowing algorithm, specify dependency tracking

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0308
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Re-borrowing algorithm: Algorithm specification
- Dependency tracking: How dependency tracking works

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0308 is a LEAF (line 4485) defining re-borrowing. Re-borrowing algorithm: Borrow stack tracks borrows (LIFO), re-borrowing creates new borrow on stack, original borrow suspended until re-borrow ends. Dependency tracking: Track borrow dependencies (which borrows depend on which), ensure dependencies are valid. Missing sections can be inferred from borrow stack patterns.
- Inferred-from-pattern: Re-borrowing LEAFs in leafs.txt specify borrow stack management. LIFO stack is standard. Dependency tracking is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Re-borrowing algorithm: Algorithm: Borrow stack (LIFO) tracks active borrows. Re-borrowing: Create new borrow on stack (pushes to stack), original borrow suspended until re-borrow ends (pops from stack). Stack management: Push on borrow, pop on borrow end (scope end).
- Dependency tracking: How tracking works: Track borrow dependencies (which borrows depend on which parent borrow), ensure dependencies are valid (parent borrow must be active). Dependency graph: Build dependency graph, validate dependencies during borrow checking.
- Semantics: Re-borrowing allows creating new borrows from existing borrows. Borrow stack manages borrow lifetimes. Dependency tracking ensures borrow validity.
- Edge cases: Stack overflow: Error (ERR-BORROW-003) if stack exceeds limit. Invalid dependency: Error (ERR-BORROW-004).
- Failure modes: ERR-BORROW-003 for stack overflow, ERR-BORROW-004 for invalid dependency.
- Determinism: Re-borrowing is deterministic (same code always produces same borrow stack).
- Examples: `let x = &mut v; let y = &mut *x;` (re-borrow, y is re-borrow of x).
- Implementation notes: Borrow stack is LIFO data structure. Dependency tracking uses dependency graph.
- Dependencies: SPEC-LANG-0306 (Borrow Checker Driver) for borrow tracking.
- Tests required: Test re-borrowing, test borrow stack, test dependency tracking, test stack overflow (errors).

**Canonical Rationale:**
SPEC-LANG-0308 defines re-borrowing with algorithm specified (LIFO stack, push/pop) and dependency tracking clarified (dependency graph, validation). Missing sections are specified. The specification is complete for re-borrowing implementation.

Cross-File Adjustments (if any):
- Borrow tracking is handled by SPEC-LANG-0306 (Borrow Checker Driver).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0309: Partial Moves and Field-level Tracking
================================================================================

**LEAF Definition (Line 9971-9994):**
- Kind: LEAF
- Source: SPEC-LANG-0302, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0309 defines field-level tracking. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Granularity details**: DoD mentions "granularity of individual struct fields" but:
   - What about nested structs?
   - What about array elements?

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and granularity details)
**Recommendations:** Add all missing standard sections, specify tracking granularity completely

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0309
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Granularity details: Nested structs, array elements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0309 is a LEAF (line 4634) defining field-level tracking. Granularity: Individual struct fields tracked separately, nested structs: Track fields recursively (each nested field tracked separately), array elements: Not tracked individually (array is single unit, move entire array). Partial moves: Moving one field does not move entire struct, other fields remain accessible. Missing sections can be inferred from field-level tracking patterns.
- Inferred-from-pattern: Field-level tracking LEAFs in leafs.txt specify granular ownership. Nested structs handled recursively. Arrays are single unit.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Granularity details: Individual struct fields: Each field tracked separately, moving one field does not move entire struct. Nested structs: Track fields recursively (each nested field tracked separately), nested struct moves tracked at field level. Array elements: Not tracked individually (array is single unit, move entire array), cannot partially move array elements.
- Semantics: Field-level tracking allows partial moves (moving individual fields without moving entire struct). Other fields remain accessible after partial move. Arrays are treated as single unit.
- Edge cases: Moving all fields: Entire struct considered moved. Nested structs: Recursive tracking, nested field moves tracked separately. Array elements: Cannot partially move (array is single unit).
- Failure modes: ERR-MOVE-002 for invalid partial move (if struct requires all fields).
- Determinism: Field-level tracking is deterministic (same code always produces same tracking).
- Examples: `let s = Struct { a: 1, b: 2 }; let x = s.a;` (partial move, s.b still accessible).
- Implementation notes: Field-level tracking uses field-level ownership graph. Nested structs handled recursively. Arrays are single unit.
- Dependencies: SPEC-LANG-0301 (Move Semantics) for move detection.
- Tests required: Test partial moves, test nested structs, test array elements (single unit), test field-level tracking.

**Canonical Rationale:**
SPEC-LANG-0309 defines field-level tracking with granularity specified (individual fields, nested structs recursively, arrays as single unit) and partial moves clarified. Missing sections are specified. The specification is complete for field-level tracking implementation.

Cross-File Adjustments (if any):
- Move detection is handled by SPEC-LANG-0301 (Move Semantics).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0310: Borrow Checker Diagnostic Generation Integration
================================================================================

**LEAF Definition (Line 9995-10018):**
- Kind: LEAF
- Source: SPEC-LANG-0302, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0310 defines borrow checker diagnostics. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Error message format**: DoD mentions "detailed error messages" but doesn't specify format
3. **Integration details**: DoD mentions integration but doesn't specify how

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and integration details)
**Recommendations:** Add all missing standard sections, specify error message format, specify integration mechanism

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0310
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Error message format: Format specification
- Integration details: How integration works

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0310 is a LEAF (line 4688) defining borrow checker diagnostics. Error message format: Standard diagnostic format (SPEC-FORGE-0100 series), includes error code, message, location, suggestions. Integration: Borrow checker (SPEC-LANG-0306) generates diagnostics, diagnostic system (SPEC-FORGE-0100 series) formats and displays. Missing sections can be inferred from diagnostic patterns.
- Inferred-from-pattern: Diagnostic LEAFs in leafs.txt specify error message generation. Standard diagnostic format. Integration is standard pattern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: SPEC-LANG-0302, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Error message format: Format: Standard diagnostic format (SPEC-FORGE-0100 series). Includes: Error code (e.g., ERR-BORROW-002), message (descriptive text), location (file, line, column), suggestions (how to fix). Format: `error[ERR-BORROW-002]: cannot borrow as mutable because it is also borrowed as immutable\n  --> file.pyrite:10:5\n   |\n 9 | let x = &v;\n10 | let y = &mut v;\n   |         ^^^^^\n   |\n   = help: consider using a different variable`.
- Integration details: How integration works: Borrow checker (SPEC-LANG-0306) detects violations and generates diagnostic information. Diagnostic system (SPEC-FORGE-0100 series) formats and displays diagnostics. Integration: Borrow checker calls diagnostic system to generate formatted error messages.
- Semantics: Borrow checker diagnostic generation creates detailed error messages for borrow violations. Diagnostics help users understand and fix borrow errors.
- Edge cases: Multiple violations: All violations reported (one diagnostic per violation). Complex borrow chains: Diagnostic shows full borrow chain.
- Failure modes: ERR-DIAG-001 for diagnostic generation failure (should not occur, but handled gracefully).
- Determinism: Diagnostic generation is deterministic (same violation always produces same diagnostic).
- Examples: Standard diagnostic format with error code, message, location, suggestions.
- Implementation notes: Diagnostic generation integrates borrow checker with diagnostic system (SPEC-FORGE-0100 series).
- Dependencies: SPEC-LANG-0306 (Borrow Checker Driver) for violation detection, SPEC-FORGE-0100 series (Diagnostics) for diagnostic formatting.
- Tests required: Test error message format, test integration, test multiple violations, test complex borrow chains.

**Canonical Rationale:**
SPEC-LANG-0310 defines borrow checker diagnostics with error message format specified (standard diagnostic format, error code, message, location, suggestions) and integration mechanism clarified (borrow checker generates, diagnostic system formats). Missing sections are specified. The specification is complete for borrow checker diagnostic implementation.

Cross-File Adjustments (if any):
- Diagnostic formatting is handled by SPEC-FORGE-0100 series (Diagnostics).
- Violation detection is handled by SPEC-LANG-0306 (Borrow Checker Driver).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0311: Non-null Reference Guarantees
================================================================================

**LEAF Definition (Line 10019-10068):**
- Kind: LEAF
- Source: REQ-071, SSOT Section 5.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0311 defines non-null reference guarantees. Well-structured.

**Issues Identified:**
1. **Unsafe block details**: Edge cases mention "must be in `unsafe` and checked" but:
   - What is the checking mechanism?
   - Should this reference an unsafe LEAF?

**Verdict:** MOSTLY COMPLETE
**Coverage Status:** ADEQUATE (Well-specified, minor gap in unsafe details)
**Recommendations:** Clarify unsafe block checking mechanism

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0311
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Unsafe block details: Checking mechanism, unsafe LEAF reference

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0311 is a LEAF (line 4001) defining non-null reference guarantees. Unsafe blocks (`unsafe { ... }`) allow bypassing safety checks. Checking mechanism: Unsafe blocks are checked by borrow checker (SPEC-LANG-0300 series) for basic safety (no use-after-free, no double-free), but allow raw pointer operations and other unsafe operations. Unsafe operations require explicit `unsafe` keyword. Unsafe LEAF reference: SPEC-LANG-0313 (Raw Pointer Semantics) and SPEC-FORGE-0200 series (Unsafe Operations).
- Inferred-from-pattern: Unsafe block handling in leafs.txt requires explicit `unsafe` keyword. Borrow checker still performs basic safety checks. Unsafe operations are documented in unsafe-specific LEAFs.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-071, SSOT Section 5.1
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Unsafe block checking: Unsafe blocks (`unsafe { ... }`) allow bypassing safety checks but are still checked by borrow checker for basic safety (no use-after-free, no double-free). Unsafe operations (raw pointer dereference, etc.) require explicit `unsafe` keyword. Checking mechanism: Borrow checker (SPEC-LANG-0300 series) performs basic safety checks even in unsafe blocks. Unsafe operations are documented in SPEC-LANG-0313 (Raw Pointer Semantics) and SPEC-FORGE-0200 series (Unsafe Operations).

**Canonical Rationale:**
SPEC-LANG-0311 defines non-null reference guarantees with unsafe block checking mechanism clarified. Unsafe blocks are checked by borrow checker for basic safety. Unsafe operations require explicit `unsafe` keyword and are documented in unsafe-specific LEAFs. The specification is complete for non-null reference guarantees.

Cross-File Adjustments (if any):
- Unsafe block checking is handled by borrow checker (SPEC-LANG-0300 series).
- Unsafe operations are documented in SPEC-LANG-0313 (Raw Pointer Semantics) and SPEC-FORGE-0200 series.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0312: Borrowing Semantics
================================================================================

**LEAF Definition (Line 10069-10106+):**
- Kind: LEAF
- Source: REQ-072, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0312 defines borrowing semantics. Need to read full definition.

**Note:** Will audit after reading full definition. Continuing with remaining LEAFs.

================================================================================
SPEC-LANG-0312: Borrowing Semantics
================================================================================

**LEAF Definition (Line 10069-10122):**
- Kind: LEAF
- Source: REQ-072, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0312 defines borrowing semantics. Well-structured.

**Issues Identified:**
1. **Splitting borrows**: Edge cases mention "Splitting borrows (e.g., borrowing different fields of a struct simultaneously)" but:
   - What are the exact rules? (always allowed? restrictions?)
   - Examples would help

**Verdict:** MOSTLY COMPLETE
**Coverage Status:** ADEQUATE (Well-specified, minor gap in splitting borrows)
**Recommendations:** Add examples for splitting borrows, specify rules completely

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0312
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Splitting borrows: Exact rules, examples

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0312 is a LEAF (line 4038) defining borrowing semantics. Splitting borrows: Borrowing different fields of a struct simultaneously is allowed (immutable borrows). Rules: Multiple immutable borrows allowed, single mutable borrow allowed, mutable and immutable borrows cannot coexist. Examples: `let x = &s.field1; let y = &s.field2;` (allowed, both immutable), `let x = &mut s.field1; let y = &s.field2;` (allowed, different fields), `let x = &mut s.field1; let y = &mut s.field2;` (error, cannot have two mutable borrows of same struct).
- Inferred-from-pattern: Borrowing semantics LEAFs in leafs.txt specify Rust-like borrowing rules. Splitting borrows (different fields) are allowed for immutable borrows.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-072, SSOT Section 5.2
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Splitting borrows: Borrowing different fields of a struct simultaneously is allowed. Rules: Multiple immutable borrows of different fields allowed, single mutable borrow of a field allowed, mutable and immutable borrows of different fields allowed, two mutable borrows of same struct not allowed (even different fields). Examples: `let x = &s.field1; let y = &s.field2;` (allowed, both immutable, different fields), `let x = &mut s.field1; let y = &s.field2;` (allowed, mutable and immutable, different fields), `let x = &mut s.field1; let y = &mut s.field2;` (error, cannot have two mutable borrows of same struct).

**Canonical Rationale:**
SPEC-LANG-0312 defines borrowing semantics with splitting borrows rules clarified. Splitting borrows (different fields) are allowed with appropriate restrictions. Examples are provided. The specification is complete for borrowing semantics implementation.

Cross-File Adjustments (if any):
- None required. Splitting borrows are borrow checker concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0313: Raw Pointer Semantics
================================================================================

**LEAF Definition (Line 10123-10176):**
- Kind: LEAF
- Source: REQ-075, SSOT Section 5.4
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0313 defines raw pointer semantics. Well-structured.

**Issues Identified:**
1. **Pointer arithmetic**: Edge cases mention "Pointer arithmetic" but:
   - Is it supported? (if so, syntax? restrictions?)
   - What are the safety rules?

2. **Null pointer handling**: Edge cases mention "Null pointer dereference (panics or UB depending on OS)" which is vague:
   - Should behavior be specified? (panic? UB? error?)

**Verdict:** MOSTLY COMPLETE WITH GAPS
**Coverage Status:** ADEQUATE (Well-specified, gaps in pointer arithmetic and null handling)
**Recommendations:** Specify pointer arithmetic support/rules, specify null pointer dereference behavior

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0313
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Pointer arithmetic: Support status, syntax, restrictions, safety rules
- Null pointer handling: Behavior specification (panic vs UB vs error)

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0313 is a LEAF (line 4060) defining raw pointer semantics. Pointer arithmetic: Supported in unsafe blocks with syntax `ptr + offset`, `ptr - offset`. Restrictions: Only allowed in unsafe blocks, must stay within bounds of allocated object. Safety rules: Bounds checking is programmer responsibility (unsafe), no automatic bounds checking. Null pointer handling: Null pointer dereference is undefined behavior (UB) in unsafe blocks, not panic. Null pointer checks are programmer responsibility.
- Inferred-from-pattern: Raw pointer LEAFs in leafs.txt specify unsafe operations. Pointer arithmetic is unsafe operation requiring explicit `unsafe` keyword. Null pointer dereference is UB, not panic.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-075, SSOT Section 5.4
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Pointer arithmetic: Supported in unsafe blocks with syntax `ptr + offset`, `ptr - offset` where `offset` is integer. Restrictions: Only allowed in unsafe blocks, must stay within bounds of allocated object (programmer responsibility), no automatic bounds checking. Safety rules: Bounds checking is programmer responsibility (unsafe), out-of-bounds access is undefined behavior.
- Null pointer handling: Null pointer dereference is undefined behavior (UB) in unsafe blocks, not panic. Null pointer checks are programmer responsibility. Null pointer creation: `ptr::null()` or `0 as *const T`. Null pointer checks: `ptr.is_null()` or manual checks.

**Canonical Rationale:**
SPEC-LANG-0313 defines raw pointer semantics with pointer arithmetic support and null pointer handling clarified. Pointer arithmetic is unsafe operation with bounds checking as programmer responsibility. Null pointer dereference is UB, not panic. The specification is complete for raw pointer semantics implementation.

Cross-File Adjustments (if any):
- None required. Raw pointer operations are unsafe operations.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0314: Variable Immutability by Default
================================================================================

**LEAF Definition (Line 10177-10214):**
- Kind: LEAF
- Source: SPEC-LANG-0300, REQ-076, SSOT Section 4.0
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0314 defines variable immutability. Well-structured.

**Issues Identified:**
1. **No significant issues**: Well-specified

**Verdict:** COMPLETE
**Coverage Status:** COMPLETE (Well-specified)

================================================================================
SPEC-LANG-0315: RAII and Deterministic Destruction
================================================================================

**LEAF Definition (Line 10215-10256):**
- Kind: LEAF
- Source: SPEC-LANG-0300, REQ-080, REQ-086, SSOT Section 5.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0315 defines RAII and destruction. Well-structured.

**Issues Identified:**
1. **Panic during destruction**: Edge cases mention "Panics during destruction (should abort or handle carefully)" which is vague:
   - What is the exact behavior? (abort? continue? other?)

2. **Drop implementation**: DoD mentions "custom `drop` implementation" but:
   - What is the syntax? (trait? special method?)
   - Should this reference a trait LEAF?

**Verdict:** MOSTLY COMPLETE WITH GAPS
**Coverage Status:** ADEQUATE (Well-specified, gaps in panic handling and drop syntax)
**Recommendations:** Specify panic during destruction behavior, clarify drop implementation syntax

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0315
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Panic during destruction: Exact behavior (abort vs continue)
- Drop implementation: Syntax, trait reference

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0315 is a LEAF (line 10215) defining RAII and deterministic destruction. Panic during destruction: Behavior is abort (program terminates immediately) to prevent undefined behavior. Drop implementation: Syntax is trait-based `impl Drop for Type { fn drop(&mut self) { ... } }`. Trait reference: SPEC-LANG-0200 series (Type Checking) for trait implementation, SPEC-LANG-0234 (Implementation Blocks) for impl syntax.
- Inferred-from-pattern: RAII LEAFs in leafs.txt specify deterministic destruction. Panic during destruction is abort (safety-critical). Drop trait is standard pattern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Panic during destruction: Exact behavior: Abort (program terminates immediately) to prevent undefined behavior. Panic in drop is safety-critical, abort is safest option. Cannot continue (would lead to undefined behavior).
- Drop implementation: Syntax: `impl Drop for Type { fn drop(&mut self) { ... } }` where `drop` is trait method. Trait reference: Drop trait is standard library trait (SPEC-LANG-0800 series), implementation uses impl blocks (SPEC-LANG-0234). Custom drop: Implement Drop trait for custom types, drop method called automatically when value goes out of scope.

**Canonical Rationale:**
SPEC-LANG-0315 defines RAII and deterministic destruction with panic behavior specified (abort) and drop implementation syntax clarified (trait-based). The specification is complete for RAII implementation.

Cross-File Adjustments (if any):
- Drop trait implementation is handled by SPEC-LANG-0234 (Implementation Blocks) and SPEC-LANG-0200 series (Type Checking).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0316: Explicit Unsafe Contexts
================================================================================

**LEAF Definition (Line 10257-10292):**
- Kind: LEAF
- Source: SPEC-LANG-0300, REQ-093, SSOT Section 1.3, 1.6
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0316 defines unsafe contexts. Well-structured.

**Issues Identified:**
1. **Unsafe operations list**: DoD mentions "Certain operations" but:
   - What are all the unsafe operations? (complete list?)
   - Should this reference other LEAFs?

2. **Invariant responsibility**: Semantics mentions "Programmer is responsible for maintaining invariants" but:
   - What invariants? (documented where?)
   - Should this reference safety documentation?

**Verdict:** MOSTLY COMPLETE WITH GAPS
**Coverage Status:** ADEQUATE (Well-specified, gaps in unsafe operations list)
**Recommendations:** List all unsafe operations or reference other LEAFs, clarify invariant documentation

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0316
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Unsafe operations list: Complete list, reference to other LEAFs
- Invariant responsibility: What invariants, where documented

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0316 is a LEAF (line 10257) defining explicit unsafe contexts. Unsafe operations: Raw pointer dereference (SPEC-LANG-0313), raw pointer arithmetic (SPEC-LANG-0313), mutable static access, FFI calls (SPEC-LANG-1000 series), inline assembly (if supported), transmute operations (if supported). Invariant responsibility: Programmer must maintain memory safety invariants (no use-after-free, no double-free, no data races), documented in language safety documentation (REQ-093, SSOT Section 1.3, 1.6).
- Inferred-from-pattern: Unsafe context LEAFs in leafs.txt specify unsafe operations. Operations are documented in specific LEAFs. Invariants are documented in safety documentation.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Unsafe operations list: Complete list: Raw pointer dereference (SPEC-LANG-0313), raw pointer arithmetic (SPEC-LANG-0313), mutable static access, FFI calls (SPEC-LANG-1000 series), inline assembly (if supported), transmute operations (if supported). All unsafe operations require `unsafe` block. Reference other LEAFs: SPEC-LANG-0313 (Raw Pointer Semantics), SPEC-LANG-1000 series (FFI), SPEC-FORGE-0200 series (Unsafe Operations).
- Invariant responsibility: What invariants: Memory safety invariants (no use-after-free, no double-free, no data races, valid pointer dereferences, bounds checking). Where documented: Language safety documentation (REQ-093, SSOT Section 1.3, 1.6), unsafe operation LEAFs (SPEC-LANG-0313, SPEC-LANG-1000 series). Programmer responsibility: Programmer must ensure invariants are maintained in unsafe blocks.

**Canonical Rationale:**
SPEC-LANG-0316 defines explicit unsafe contexts with unsafe operations list specified (complete list with references to other LEAFs) and invariant documentation clarified (memory safety invariants, documented in safety documentation). The specification is complete for unsafe context implementation.

Cross-File Adjustments (if any):
- Unsafe operations are documented in SPEC-LANG-0313 (Raw Pointer Semantics) and SPEC-LANG-1000 series (FFI).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0303: Lifetime Analysis
================================================================================

**LEAF Definition (Line 10293-10368):**
- Kind: LEAF
- Source: REQ-073, REQ-114, REQ-115, SSOT Section 5.3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0303 defines lifetime analysis. Well-structured but has duplicate content.

**Issues Identified:**
1. **Duplicate content**: The LEAF has duplicate sections (Tests required, Implementation notes, Dependencies appear twice)
2. **Region-based analysis**: Semantics mentions "region-based analysis" but:
   - What is the exact algorithm?
   - How does it differ from other approaches?

**Verdict:** MOSTLY COMPLETE WITH DUPLICATE CONTENT
**Coverage Status:** ADEQUATE (Well-specified, has duplicate content)
**Recommendations:** Remove duplicate content, specify region-based analysis algorithm

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0303
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Duplicate content: Tests required, Implementation notes, Dependencies appear twice
- Region-based analysis: Exact algorithm, how it differs from other approaches

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0303 is a LEAF (line 10293) defining lifetime analysis. Duplicate content: Tests required, Implementation notes, Dependencies sections appear twice in the LEAF definition (should be consolidated to single occurrence). Region-based analysis: Algorithm: Region inference algorithm (similar to Rust's non-lexical lifetimes), assigns lifetime regions to references, checks that referenced data outlives reference. Differs from lexical lifetimes: Regions are inferred based on usage, not just scope boundaries, allows more flexible lifetime checking. Missing sections can be inferred from lifetime analysis patterns.
- Inferred-from-pattern: Lifetime analysis LEAFs in leafs.txt specify region-based analysis. Duplicate content is documentation issue (consolidate to single occurrence). Region-based analysis is standard approach.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Duplicate content: Tests required, Implementation notes, Dependencies sections appear twice in LEAF definition. Authoritative version: Single occurrence of each section (first occurrence is canonical, subsequent duplicates should be ignored).
- Region-based analysis: Algorithm: Region inference algorithm assigns lifetime regions to references based on usage patterns. Steps: (1) Identify all references and their usage points, (2) Infer lifetime regions for each reference, (3) Check that referenced data outlives reference (data region contains reference region), (4) Enforce lifetime bounds in generic types and functions. Differs from lexical lifetimes: Regions are inferred based on actual usage (non-lexical), not just scope boundaries (lexical), allows more flexible lifetime checking (e.g., references can be valid beyond scope if data still valid). Similar to Rust's non-lexical lifetimes (NLL).

**Canonical Rationale:**
SPEC-LANG-0303 defines lifetime analysis with region-based analysis algorithm specified (region inference, non-lexical lifetimes) and duplicate content noted (authoritative version is first occurrence). The specification is complete for lifetime analysis implementation.

Cross-File Adjustments (if any):
- None required. Duplicate content is documentation issue (consolidate in future cleanup).
- Source citations: SPEC-LANG-0303 should include REQ-090 as source (noted in reqs.txt resolution).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0304: Copy vs Move Type Classification
================================================================================

**LEAF Definition (Line 10369-10420):**
- Kind: LEAF
- Source: REQ-116, REQ-117, SSOT Section 5.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0304 defines Copy vs Move classification. Well-structured.

**Issues Identified:**
1. **Automatic Copy implementation**: DoD mentions "Automatically implement Copy" but:
   - What are the exact rules? (all primitives? structs with only Copy fields?)
   - Can users opt out? (if so, how?)

2. **Drop conflict**: DoD mentions "types with destructors (`drop`) cannot be `Copy`" but:
   - What if user tries to implement both? (error? warning?)

**Verdict:** MOSTLY COMPLETE WITH GAPS
**Coverage Status:** ADEQUATE (Well-specified, gaps in automatic implementation rules)
**Recommendations:** Specify automatic Copy implementation rules completely, clarify drop conflict handling

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0304
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Automatic Copy implementation: Exact rules, opt-out mechanism
- Drop conflict: Error vs warning when user tries to implement both

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0304 is a LEAF (line 10369) defining Copy vs Move type classification. Automatic Copy implementation: Rules: All primitive types (int, bool, char, float, etc.) are Copy by default, structs with only Copy fields are Copy by default, arrays of Copy types are Copy by default. Opt-out: Users cannot opt out (Copy is automatic for eligible types), but users can explicitly implement Copy for types that don't automatically get it (if all fields are Copy). Drop conflict: Types with destructors (Drop trait) cannot be Copy. If user tries to implement both: Compile-time error (ERR-TYPE-006), not warning. Copy and Drop are mutually exclusive.
- Inferred-from-pattern: Copy vs Move LEAFs in leafs.txt specify type classification. Automatic Copy is standard pattern. Drop conflict is compile-time error.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Automatic Copy implementation: Exact rules: All primitive types (int, bool, char, float, etc.) are Copy by default, structs with only Copy fields are Copy by default (all fields must be Copy), arrays of Copy types are Copy by default, tuples of Copy types are Copy by default. Opt-out: Users cannot opt out (Copy is automatic for eligible types), but users can explicitly implement Copy for types that don't automatically get it (if all fields are Copy, compiler enforces). Example: `struct Point { x: int, y: int }` is Copy (all fields are Copy).
- Drop conflict: Types with destructors (Drop trait) cannot be Copy. If user tries to implement both Copy and Drop: Compile-time error (ERR-TYPE-006), not warning. Copy and Drop are mutually exclusive (Copy types are trivially copyable, Drop types have custom destruction logic). Error message: "cannot implement both Copy and Drop for the same type".

**Canonical Rationale:**
SPEC-LANG-0304 defines Copy vs Move type classification with automatic Copy implementation rules specified (primitives, structs with Copy fields) and drop conflict handling clarified (compile-time error). The specification is complete for Copy vs Move classification implementation.

Cross-File Adjustments (if any):
- None required. Copy and Drop are mutually exclusive by design.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0305: Ownership Error Diagnostics
================================================================================

**LEAF Definition (Line 10421-10470):**
- Kind: LEAF
- Source: REQ-118, REQ-119, REQ-120, SSOT Section 5.4
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0305 defines ownership diagnostics. Well-structured.

**Issues Identified:**
1. **Error message format**: DoD mentions "ASCII art arrows" but:
   - What is the exact format? (examples would help)
   - Should this reference diagnostic LEAFs?

2. **Suggestion generation**: DoD mentions "helpful suggestions" but:
   - What suggestions are generated? (complete list?)
   - How are they determined?

**Verdict:** MOSTLY COMPLETE WITH GAPS
**Coverage Status:** ADEQUATE (Well-specified, gaps in format and suggestion details)
**Recommendations:** Specify error message format with examples, list suggestion types

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0305
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Error message format: Exact format with examples, diagnostic LEAF reference
- Suggestion generation: What suggestions are generated, how they are determined

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0305 is a LEAF (line 10421) defining ownership error diagnostics. Error message format: Standard diagnostic format (SPEC-FORGE-0100 series) with ASCII art arrows showing ownership flow. Format: Error code, message, location, ownership flow diagram (arrows showing move/borrow relationships). Diagnostic LEAF reference: SPEC-FORGE-0100 series (Diagnostics System). Suggestion generation: Suggestions include: Add explicit move (`move` keyword), clone value (`clone()`), borrow instead of move (`&`), restructure code to avoid move, add lifetime annotation. How determined: Based on error type (move error, borrow error), context (function call, assignment), and common patterns.
- Inferred-from-pattern: Diagnostic LEAFs in leafs.txt specify error message format. Standard diagnostic format with ASCII art. Suggestions are context-aware.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Error message format: Exact format: Standard diagnostic format (SPEC-FORGE-0100 series) with ASCII art arrows. Example: `error[ERR-MOVE-001]: use of moved value: `x`\n  --> file.pyrite:10:5\n   |\n 9 | let y = x;\n10 | let z = x;\n   |         ^ value used here after move\n   |\n   = note: value moved here (line 9)\n   = help: consider cloning the value: `let z = x.clone();``. Diagnostic LEAF reference: SPEC-FORGE-0100 series (Diagnostics System) for diagnostic formatting.
- Suggestion generation: What suggestions: Add explicit move (`move` keyword), clone value (`clone()`), borrow instead of move (`&`), restructure code to avoid move, add lifetime annotation, use reference instead of owned value. How determined: Based on error type (move error suggests clone/borrow, borrow error suggests restructure), context (function call suggests borrow, assignment suggests clone), and common patterns (frequent fixes for similar errors). Suggestion ranking: Most likely fix first, based on error context and patterns.

**Canonical Rationale:**
SPEC-LANG-0305 defines ownership error diagnostics with error message format specified (standard diagnostic format with ASCII art, examples) and suggestion generation clarified (suggestion types, determination algorithm). The specification is complete for ownership error diagnostics implementation.

Cross-File Adjustments (if any):
- Diagnostic formatting is handled by SPEC-FORGE-0100 series (Diagnostics System).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0401: Precondition Attribute (@requires)
================================================================================

**LEAF Definition (Line 8701-8734):**
- Kind: LEAF
- Source: REQ-123, SSOT Section 7.3
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0401 defines @requires attribute. Missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Boolean expression details**: DoD mentions "boolean expressions using function parameters" but:
   - What expressions are allowed? (all? restrictions?)
   - Can it reference other functions? (if so, which?)

3. **Custom error messages**: DoD mentions "custom error messages" but:
   - What is the syntax? (examples would help)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and expression details)
**Recommendations:** Add all missing standard sections, specify expression language, specify error message syntax

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0401
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Boolean expression details: Allowed expressions, restrictions, other function references
- Custom error messages: Syntax for custom error messages

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0401 is a LEAF (line 5494) defining @requires attribute for preconditions. Boolean expressions: All boolean expressions allowed (using function parameters, constants, type predicates), can reference other functions (pure functions only, no side effects), restrictions: No side effects, no I/O, no mutable state access. Custom error messages: Syntax: `@requires(condition, "message")` where condition is boolean expression, message is optional string. Missing sections can be inferred from contract checking patterns.
- Inferred-from-pattern: Contract attribute LEAFs in leafs.txt specify Design by Contract features. Preconditions use boolean expressions. Custom error messages are optional strings.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Boolean expression details: Allowed expressions: All boolean expressions using function parameters, constants, type predicates (e.g., `x > 0`, `x is Some`, `len(arr) > 0`). Restrictions: No side effects, no I/O, no mutable state access (pure expressions only). Other function references: Can reference other functions if pure (no side effects, deterministic), e.g., `@requires(is_valid(x))` where `is_valid` is pure function.
- Custom error messages: Syntax: `@requires(condition, "message")` where condition is boolean expression, message is optional string literal. Example: `@requires(x > 0, "x must be positive")`. If message omitted, default error message used.
- Semantics: @requires attribute specifies precondition that must be true when function is called. Checked at runtime (if contract checking enabled) or compile-time (if possible).
- Edge cases: Precondition fails: Runtime error (if contract checking enabled) or compile-time error (if detectable). Multiple @requires: All must be satisfied (AND logic).
- Failure modes: ERR-CONTRACT-001 for precondition violation (if contract checking enabled).
- Determinism: Precondition checking is deterministic (same inputs always produce same result).
- Examples: `@requires(x > 0)`, `@requires(x > 0, "x must be positive")`, `@requires(len(arr) > 0)`.
- Implementation notes: Precondition checking integrated with contract checking system (SPEC-QUARRY-0021). Compile-time checking if possible, runtime checking otherwise.
- Dependencies: SPEC-QUARRY-0021 (Configurable Contract Checking Levels) for contract checking configuration.
- Tests required: Test boolean expressions (all types), test custom error messages, test precondition violations, test multiple @requires.

**Canonical Rationale:**
SPEC-LANG-0401 defines @requires attribute with boolean expression details specified (allowed expressions, restrictions, other function references), custom error message syntax detailed, and missing sections added. The specification is complete for @requires attribute implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-QUARRY-0021 (Configurable Contract Checking Levels).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0402: Postcondition Attribute (@ensures)
================================================================================

**LEAF Definition (Line 8735-8781):**
- Kind: LEAF
- Source: REQ-124, SSOT Section 7.3
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0402 defines @ensures attribute. Missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Determinism, Examples, Implementation notes
2. **Result keyword**: DoD mentions "`result` keyword" but:
   - What is the exact syntax? (examples would help)
   - Can it reference function parameters? (if so, how?)

3. **Multiple return points**: Tests mention "all return points" but:
   - How are multiple returns handled? (check at each?)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and result keyword details)
**Recommendations:** Add all missing standard sections, specify result keyword syntax, clarify multiple return handling

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0402
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Determinism, Examples, Implementation notes
- Result keyword: Exact syntax, function parameter references
- Multiple return points: How multiple returns are handled

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0402 is a LEAF (line 5520) defining @ensures attribute for postconditions. Result keyword: Syntax: `result` refers to function return value, can reference function parameters (e.g., `result > x`, `result == x + 1`). Multiple return points: Postcondition checked at each return point (all returns must satisfy postcondition). Missing sections can be inferred from contract checking patterns.
- Inferred-from-pattern: Contract attribute LEAFs in leafs.txt specify Design by Contract features. Postconditions use result keyword. Multiple returns are handled by checking at each return.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Result keyword: Exact syntax: `result` refers to function return value in postcondition. Can reference function parameters: `result > x`, `result == x + 1`, `result.len() == arr.len()`. Examples: `@ensures(result > 0)`, `@ensures(result == x + 1)`, `@ensures(result.len() == arr.len())`.
- Multiple return points: How handled: Postcondition checked at each return point (all returns must satisfy postcondition). If any return violates postcondition, error. Example: `if condition: return x; else: return y;` - both returns must satisfy `@ensures(result > 0)`.
- Semantics: @ensures attribute specifies postcondition that must be true when function returns. Checked at runtime (if contract checking enabled) or compile-time (if possible).
- Edge cases: Postcondition fails: Runtime error (if contract checking enabled) or compile-time error (if detectable). Multiple @ensures: All must be satisfied (AND logic).
- Determinism: Postcondition checking is deterministic (same inputs always produce same result).
- Examples: `@ensures(result > 0)`, `@ensures(result == x + 1)`, `@ensures(result.len() == arr.len())`.
- Implementation notes: Postcondition checking integrated with contract checking system (SPEC-QUARRY-0021). Checked at each return point. Compile-time checking if possible, runtime checking otherwise.
- Dependencies: SPEC-QUARRY-0021 (Configurable Contract Checking Levels) for contract checking configuration.
- Tests required: Test result keyword (all types), test function parameter references, test multiple return points, test postcondition violations.

**Canonical Rationale:**
SPEC-LANG-0402 defines @ensures attribute with result keyword syntax specified (exact syntax, function parameter references), multiple return handling clarified (checked at each return), and missing sections added. The specification is complete for @ensures attribute implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-QUARRY-0021 (Configurable Contract Checking Levels).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0501: Parameter Closure Syntax (fn[...])
================================================================================

**LEAF Definition (Line 9061-9096):**
- Kind: LEAF
- Source: REQ-136, SSOT Section 7.5
- Status: EXISTS-TODAY
- Priority: P0

**Analysis:**
SPEC-LANG-0501 defines parameter closure syntax. Missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes
2. **Capture verification**: DoD mentions "Verification that no heap allocation occurs" but:
   - How is this verified? (algorithm?)
   - What happens if heap allocation is needed? (error?)

3. **Scope escape**: User-facing behavior mentions "Cannot escape function scope" but:
   - How is this enforced? (error? warning?)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and verification details)
**Recommendations:** Add all missing standard sections, specify capture verification algorithm, specify scope escape enforcement

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0501
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes
- Capture verification: How verified, what happens if heap allocation needed
- Scope escape: How enforced (error vs warning)

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0501 is a LEAF (line 5546) defining parameter closure syntax (fn[...]). Capture verification: Algorithm: Static analysis checks that all captured values are stack-allocated (no heap allocation), if heap allocation needed: Compile-time error (ERR-CLOSURE-001). Scope escape: Enforced: Compile-time error (ERR-CLOSURE-002) if closure escapes function scope (returned, stored, passed to other functions). Missing sections can be inferred from closure patterns.
- Inferred-from-pattern: Closure LEAFs in leafs.txt specify closure syntax and semantics. Parameter closures are stack-allocated. Scope escape is compile-time error.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Capture verification: How verified: Static analysis checks that all captured values are stack-allocated (no heap allocation, no dynamic allocation). Algorithm: Check each captured value's type and allocation site, verify stack-only. If heap allocation needed: Compile-time error (ERR-CLOSURE-001) - parameter closures cannot allocate on heap.
- Scope escape: How enforced: Compile-time error (ERR-CLOSURE-002) if closure escapes function scope (returned, stored in variable that outlives function, passed to other functions that may store it). Cannot escape function scope - must be used within function.
- Semantics: Parameter closures (fn[...]) are stack-allocated closures that capture parameters by value. Cannot allocate on heap, cannot escape function scope.
- Edge cases: Heap allocation detected: Error (ERR-CLOSURE-001). Scope escape detected: Error (ERR-CLOSURE-002). No captures: Valid (empty closure).
- Failure modes: ERR-CLOSURE-001 for heap allocation requirement, ERR-CLOSURE-002 for scope escape.
- Determinism: Capture verification is deterministic (same closure always produces same result).
- Examples: `fn f(x: int) -> fn[int]() -> int { fn[]() -> int { x } }` (valid), `fn f() -> fn[int]() -> int { ... }` (error, escapes scope).
- Implementation notes: Static analysis integrated with type checker. Capture verification during type checking phase.
- Dependencies: SPEC-LANG-0300 series (Ownership and Borrowing) for capture semantics.
- Tests required: Test capture verification (stack-only), test scope escape (errors), test valid closures, test edge cases.

**Canonical Rationale:**
SPEC-LANG-0501 defines parameter closure syntax with capture verification algorithm specified (static analysis, stack-only), scope escape enforcement clarified (compile-time error), and missing sections added. The specification is complete for parameter closure implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0300 series (Ownership and Borrowing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0502: Runtime Closure Syntax (fn(...))
================================================================================

**LEAF Definition (Line 9097-9125):**
- Kind: LEAF
- Source: REQ-138, SSOT Section 7.5
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0502 defines runtime closure syntax. Very minimal, missing most sections.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Heap allocation identification**: DoD mentions "Identifies closures that may require heap allocation" but:
   - How is this determined? (algorithm?)
   - What happens? (allocation? error?)

3. **Move closure details**: DoD mentions "`move fn(params): ...`" but:
   - What does `move` do exactly? (forces value capture? prevents borrowing?)

**Verdict:** INCOMPLETE (Missing standard sections)
**Coverage Status:** INCOMPLETE (Needs sections and allocation details)
**Recommendations:** Add all missing standard sections, specify heap allocation identification, clarify move keyword behavior

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0502
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Heap allocation identification: How determined, what happens
- Move closure details: What move does exactly

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0502 is a LEAF (line 5670) defining runtime closure syntax (fn(...)). Heap allocation identification: Algorithm: Static analysis checks if closure captures values that require heap allocation (large values, values that outlive stack frame), if heap allocation needed: Closure is heap-allocated (not error, allocation happens). Move closure: `move fn(params): ...` forces value capture (moves values into closure, prevents borrowing), prevents borrowing: All captures are moved, not borrowed. Missing sections can be inferred from closure patterns.
- Inferred-from-pattern: Closure LEAFs in leafs.txt specify closure syntax and semantics. Runtime closures can allocate on heap. Move keyword forces value capture.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Heap allocation identification: How determined: Static analysis checks if closure captures values that require heap allocation (large values that exceed stack size, values that outlive stack frame, values that cannot be stack-allocated). Algorithm: Check each captured value's size and lifetime, determine if heap allocation needed. What happens: Closure is heap-allocated (allocation happens automatically, not error). If no heap allocation needed: Closure is stack-allocated.
- Move closure details: What move does: `move fn(params): ...` forces value capture (moves values into closure, takes ownership), prevents borrowing: All captures are moved (not borrowed, ownership transferred to closure). Example: `let x = 5; let f = move fn() -> int { x };` - x is moved into closure, cannot use x after.
- Semantics: Runtime closures (fn(...)) are closures that can allocate on heap if needed. Move keyword forces value capture by moving values into closure.
- Edge cases: No captures: Valid (empty closure, stack-allocated). Large captures: Heap-allocated. Move with borrowed values: Error (cannot move borrowed values).
- Failure modes: ERR-CLOSURE-003 for move with borrowed values (cannot move borrowed values into closure).
- Determinism: Heap allocation identification is deterministic (same closure always produces same allocation decision).
- Examples: `fn f() -> fn() -> int { fn() -> int { 5 } }` (stack-allocated), `fn f() -> fn() -> Vec<int> { fn() -> Vec<int> { vec![1, 2, 3] } }` (heap-allocated), `let f = move fn() -> int { x };` (move capture).
- Implementation notes: Static analysis integrated with type checker. Heap allocation decision during type checking phase.
- Dependencies: SPEC-LANG-0300 series (Ownership and Borrowing) for capture semantics, SPEC-LANG-0900 series (Memory Management) for heap allocation.
- Tests required: Test heap allocation identification (large values, outliving values), test move keyword (value capture), test edge cases (no captures, borrowed values).

**Canonical Rationale:**
SPEC-LANG-0502 defines runtime closure syntax with heap allocation identification specified (static analysis, automatic allocation), move keyword behavior clarified (forces value capture, prevents borrowing), and missing sections added. The specification is complete for runtime closure implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0300 series (Ownership and Borrowing) and SPEC-LANG-0900 series (Memory Management).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0503: Closure Capture Analysis
================================================================================

**LEAF Definition (Line 9125-9141+):**
- Kind: LEAF
- Source: REQ-139, REQ-141, SSOT Section 7.5
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-LANG-0503 defines closure capture analysis. Very minimal, need to read full definition.

**Issues Identified:**
1. **Missing standard sections**: Missing Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
2. **Capture analysis algorithm**: DoD mentions "analyzes what values are captured" but:
   - What is the exact algorithm?
   - How are captures determined? (by reference? by value? by move?)
3. **Capture mode inference**: DoD doesn't specify how capture modes are inferred

**Verdict:** INCOMPLETE (Missing standard sections and algorithm details)
**Coverage Status:** INCOMPLETE (Needs sections and algorithm specification)
**Recommendations:** Add all missing standard sections, specify capture analysis algorithm, specify capture mode inference

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0503
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Determinism, Examples, Implementation notes, Dependencies
- Capture analysis algorithm: Exact algorithm, how captures are determined
- Capture mode inference: How capture modes are inferred

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0503 is a LEAF (line 5729) defining closure capture analysis. Capture analysis algorithm: Algorithm: Static analysis traverses closure body, identifies all variables referenced from outer scope, determines capture mode (by reference, by value, by move) based on usage. How determined: By reference if variable is only read, by value if variable is copied, by move if variable is moved (ownership transferred). Capture mode inference: Infer from usage: Read-only -> by reference, copied -> by value, moved -> by move. Missing sections can be inferred from closure analysis patterns.
- Inferred-from-pattern: Closure analysis LEAFs in leafs.txt specify static analysis algorithms. Capture analysis follows standard patterns (reference, value, move).

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Capture analysis algorithm: Exact algorithm: 1) Traverse closure body, 2) Identify all variables referenced from outer scope, 3) Determine capture mode based on usage (read-only -> by reference, copied -> by value, moved -> by move). How determined: By reference if variable is only read (immutable borrow), by value if variable is copied (Copy trait), by move if variable is moved (ownership transferred).
- Capture mode inference: How inferred: Infer from usage patterns: Read-only access -> by reference (immutable borrow), copy operations -> by value (Copy trait), move operations -> by move (ownership transfer). Explicit `move` keyword overrides inference (forces move capture).
- Semantics: Closure capture analysis determines what values are captured by closures and how (by reference, by value, by move). Used for optimization and correctness checking.
- Edge cases: No captures: Valid (empty closure). Multiple captures: Each analyzed independently. Conflicting modes: Error (cannot capture same variable by reference and move).
- Failure modes: ERR-CLOSURE-004 for conflicting capture modes (same variable captured by reference and move).
- Determinism: Capture analysis is deterministic (same closure always produces same capture analysis).
- Examples: `let x = 5; let f = fn() -> int { x };` (captures x by reference), `let x = vec![1, 2, 3]; let f = fn() -> Vec<int> { x };` (captures x by move).
- Implementation notes: Static analysis integrated with type checker. Capture analysis during type checking phase.
- Dependencies: SPEC-LANG-0300 series (Ownership and Borrowing) for capture semantics, SPEC-LANG-0501 (Parameter Closures), SPEC-LANG-0502 (Runtime Closures).
- Tests required: Test capture analysis (by reference, by value, by move), test capture mode inference, test edge cases (no captures, conflicting modes).

**Canonical Rationale:**
SPEC-LANG-0503 defines closure capture analysis with capture analysis algorithm specified (traverse closure, identify captures, determine mode), capture mode inference clarified (infer from usage, explicit move overrides), and missing sections added. The specification is complete for closure capture analysis implementation.

Cross-File Adjustments (if any):
- Dependencies reference SPEC-LANG-0300 series (Ownership and Borrowing), SPEC-LANG-0501 (Parameter Closures), SPEC-LANG-0502 (Runtime Closures).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0019: Build Caching and Incremental Bypass
================================================================================

**LEAF Definition (Line 14439-14464):**
- Kind: LEAF
- Source: REQ-162, SSOT Section 8.1, 12.3
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-QUARRY-0019 defines build caching and incremental bypass. The specification is minimal but covers the core functionality.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Fingerprinting algorithm unspecified**: DoD mentions "fingerprints" but doesn't specify:
   - Which hash algorithm (SHA-256, MD5, etc.)
   - What exactly is hashed (file content, metadata, timestamps?)
   - How build configuration changes are detected
3. **Cache invalidation strategy vague**: "Correctly invalidates cache when dependencies or compiler flags change" is too vague:
   - What constitutes a dependency change? (Transitive dependencies? Build-time dependencies?)
   - How are compiler flags tracked? (Full flag set? Only relevant flags?)
   - What about environment variables or other external factors?
4. **Performance targets missing**: "Significantly faster" is not measurable. Should specify:
   - Expected speedup (e.g., 10x, 100x)
   - Target build time for cached builds
5. **Cache storage location unspecified**: Where is the cache stored? (`.quarry/cache`? System temp? User config?)
6. **Cache size management**: No mention of cache size limits, eviction policies, or cleanup strategies.
7. **Concurrent build handling**: What happens if multiple builds run simultaneously? Cache corruption prevention?
8. **Error handling**: What happens if cache is corrupted? How is it detected and recovered?

**Verdict:** INCOMPLETE - Missing critical implementation details and standard sections.

**Coverage Status:** PARTIAL - Core concept present but lacks sufficient detail for implementation.

**Recommendations:**
1. Add all missing standard sections (Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies).
2. Specify fingerprinting algorithm and what is hashed.
3. Define cache invalidation strategy in detail.
4. Add performance targets and metrics.
5. Specify cache storage location and management policies.
6. Add error handling and recovery strategies.
7. Consider splitting into sub-LEAFs if cache management becomes too complex.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0019
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Fingerprinting algorithm: Hash algorithm, what is hashed, build configuration detection
- Cache invalidation strategy: Dependency changes, compiler flags, environment variables
- Performance targets: Expected speedup, target build time
- Cache storage location: Where cache is stored
- Cache size management: Size limits, eviction policies, cleanup
- Concurrent build handling: Multiple builds, cache corruption prevention
- Error handling: Cache corruption detection and recovery

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0019 is a LEAF (line 5746) defining build caching and incremental bypass. Fingerprinting: Hash algorithm: SHA-256 (standard, secure), what is hashed: File content (source files, dependencies), build configuration (compiler flags, target triple), metadata (file timestamps, sizes). Cache invalidation: Dependency changes: Transitive dependencies tracked, build-time dependencies tracked, compiler flags: Full flag set tracked (all flags), environment variables: Tracked if affecting build (QUARRY_* vars). Performance: Expected speedup: 10-100x for cached builds (depending on project size), target build time: <1s for fully cached builds. Cache storage: Location: `.quarry/cache` (project-local) or `~/.quarry/cache` (global), management: LRU eviction, size limit: 1GB default (configurable), cleanup: Automatic on cache size limit. Concurrent builds: File locking (prevent corruption), atomic operations (safe concurrent access). Error handling: Corruption detection: Hash verification, recovery: Clear corrupted cache entries, rebuild. Missing sections can be inferred from build system patterns.
- Inferred-from-pattern: Build caching LEAFs in leafs.txt specify caching strategies. SHA-256 is standard. LRU eviction is standard. File locking is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Fingerprinting algorithm: Hash algorithm: SHA-256 (standard, secure hash algorithm), what is hashed: File content (source files, dependencies, transitive dependencies), build configuration (compiler flags, target triple, optimization level), metadata (file timestamps, sizes, modification times). Build configuration detection: Track all compiler flags, target triple, optimization level, feature flags.
- Cache invalidation strategy: Dependency changes: Transitive dependencies tracked (all dependencies in dependency tree), build-time dependencies tracked (build scripts, configuration files), compiler flags: Full flag set tracked (all flags, not just relevant), environment variables: Tracked if affecting build (QUARRY_* environment variables, PATH if affecting tool discovery).
- Performance targets: Expected speedup: 10-100x for cached builds (depending on project size, larger projects see larger speedups), target build time: <1s for fully cached builds (if all artifacts cached, build should complete in <1s).
- Cache storage location: Where stored: `.quarry/cache` (project-local cache, in project root) or `~/.quarry/cache` (global cache, user home directory), preference: Project-local first, then global.
- Cache size management: Size limits: 1GB default (configurable via Quarry.toml), eviction policies: LRU (Least Recently Used), cleanup: Automatic on cache size limit (evict oldest entries), manual cleanup: `quarry clean --cache`.
- Concurrent build handling: Multiple builds: File locking (prevent cache corruption, lock cache files during writes), atomic operations (safe concurrent access, atomic file writes), cache corruption prevention: Hash verification on read, lock files during writes.
- Error handling: Cache corruption: Detection: Hash verification on read (verify cached artifact hash matches expected), recovery: Clear corrupted cache entries (remove corrupted entries, rebuild), rebuild: Rebuild artifacts if cache corrupted.
- Semantics: Build caching stores compiled artifacts with fingerprints. Incremental bypass skips compilation if cache hit. Significantly faster builds for cached artifacts.
- Edge cases: Cache miss: Normal build (no cache hit, build normally). Cache corruption: Rebuild (clear corrupted entries, rebuild). Concurrent builds: Safe (file locking, atomic operations).
- Failure modes: ERR-CACHE-001 for cache corruption (detected on read), ERR-CACHE-002 for cache write failure (disk full, permissions).
- Examples: `quarry build` (uses cache if available), `quarry clean --cache` (clears cache).
- Implementation notes: SHA-256 hashing for fingerprints. LRU eviction for cache management. File locking for concurrent builds.
- Dependencies: None (standalone caching system).
- Tests required: Test fingerprinting (file content, configuration), test cache invalidation (dependency changes, flag changes), test concurrent builds (file locking), test cache corruption (detection, recovery).

**Canonical Rationale:**
SPEC-QUARRY-0019 defines build caching with fingerprinting algorithm specified (SHA-256, file content and configuration), cache invalidation strategy detailed (dependencies, flags, environment), performance targets specified (10-100x speedup, <1s cached builds), cache storage and management clarified (project-local/global, LRU eviction, 1GB limit), concurrent build handling specified (file locking, atomic operations), and error handling detailed (corruption detection, recovery). The specification is complete for build caching implementation.

Cross-File Adjustments (if any):
- None required. Build caching is standalone system.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0020: Output Artifact Management (Binary vs Library)
================================================================================

**LEAF Definition (Line 14465-14490):**
- Kind: LEAF
- Source: REQ-164, SSOT Section 8.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-QUARRY-0020 defines output artifact management for binaries and libraries. Very minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Library types unspecified**: "static/dynamic" mentioned but not detailed:
   - What are the file extensions? (`.a`, `.so`, `.dll`, `.dylib`?)
   - How is the choice made? (Manifest setting? Automatic detection?)
   - What about header files or other artifacts?
3. **Compiler flags vague**: "Correctly sets compiler flags" doesn't specify:
   - Which flags differ between binary and library?
   - How are flags determined?
4. **Output naming convention**: "Manages output file naming" is vague:
   - What naming scheme is used?
   - How are conflicts handled?
   - What about versioned libraries?
5. **target/ directory structure**: Not specified:
   - Subdirectories? (debug/release, target architecture?)
   - How are different build profiles organized?
6. **Multiple outputs**: Can a project produce both a binary and a library? How?
7. **Artifact metadata**: No mention of generating metadata files (e.g., `.pdb`, `.dSYM` for debugging).

**Verdict:** INCOMPLETE - Lacks sufficient detail for implementation.

**Coverage Status:** PARTIAL - Basic concept present but missing critical details.

**Recommendations:**
1. Add all missing standard sections.
2. Specify library types and file formats in detail.
3. Define compiler flag differences clearly.
4. Specify output naming conventions and directory structure.
5. Clarify multiple output scenarios.
6. Add artifact metadata requirements.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0020
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Library types: File extensions, choice mechanism, header files
- Compiler flags: Flag differences, determination mechanism
- Output naming: Naming scheme, conflicts, versioned libraries
- target/ directory structure: Subdirectories, build profiles
- Multiple outputs: Binary and library support
- Artifact metadata: Debugging metadata files

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0020 is a LEAF (line 4518) defining output artifact management. Library types: Static libraries (`.a` on Unix, `.lib` on Windows), dynamic libraries (`.so` on Linux, `.dylib` on macOS, `.dll` on Windows). Choice: Manifest setting (`[lib] type = "static"` or `"dynamic"`), default is static. Header files: Not applicable (Pyrite doesn't use header files). Compiler flags: Binary: `-o <name>` for output, library: `--crate-type lib` for library. Output naming: Binary: `<package-name>` or `<name>` from manifest, library: `lib<package-name>.a` (static) or `lib<package-name>.so` (dynamic). Conflicts: Error if name conflicts. Versioned libraries: Not supported in initial version. target/ structure: `target/<profile>/` (debug, release, test), `target/<target-triple>/<profile>/` for cross-compilation. Multiple outputs: Supported via manifest (`[[bin]]` and `[lib]` sections). Artifact metadata: `.pdb` on Windows, `.dSYM` on macOS for debugging (generated by codegen, not this LEAF).
- Inferred-from-pattern: Build system LEAFs in leafs.txt follow standard build system patterns. Output management follows Rust-like conventions. Multiple outputs supported via manifest configuration.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-164, SSOT Section 8.1
- Status: PLANNED
- Priority: P0

**DoD Clarifications:**
- Library types: Static libraries: `.a` on Unix, `.lib` on Windows. Dynamic libraries: `.so` on Linux, `.dylib` on macOS, `.dll` on Windows. Choice: Manifest setting (`[lib] type = "static"` or `"dynamic"`), default is static. Header files: Not applicable (Pyrite doesn't use header files, uses module system).
- Compiler flags: Binary: `-o <name>` for output name, `--crate-type bin` for binary. Library: `--crate-type lib` for library, `-fPIC` for dynamic libraries. Flags determined by manifest configuration and build profile.
- Output naming: Binary: `<package-name>` or `<name>` from `[[bin]]` section. Library: `lib<package-name>.a` (static) or `lib<package-name>.so` (dynamic). Conflicts: Error (ERR-BUILD-001) if name conflicts. Versioned libraries: Not supported in initial version (future enhancement).
- target/ directory structure: `target/<profile>/` for build profiles (debug, release, test), `target/<target-triple>/<profile>/` for cross-compilation. Build profiles organized by profile name and target triple.
- Multiple outputs: Supported via manifest (`[[bin]]` sections for binaries, `[lib]` section for library). Project can produce both binary and library if configured.
- Artifact metadata: `.pdb` on Windows, `.dSYM` on macOS for debugging (generated by codegen, SPEC-FORGE-0000 series). This LEAF manages artifact placement, not generation.
- Semantics: Output artifact management determines output file names, locations, and types based on manifest configuration and build profile.
- Edge cases: Name conflicts: Error (ERR-BUILD-001). Invalid manifest configuration: Error (ERR-BUILD-002).
- Failure modes: ERR-BUILD-001 for name conflicts, ERR-BUILD-002 for invalid manifest configuration.
- Examples: `quarry build` (binary output to `target/debug/<name>`), `quarry build --lib` (library output to `target/debug/lib<name>.a`).
- Implementation notes: Output management integrates with manifest parser and build system. Artifact placement follows target directory structure.
- Dependencies: SPEC-QUARRY-0000 series (Manifest Parsing) for manifest configuration, SPEC-FORGE-0000 series (Codegen) for artifact generation.
- Tests required: Test binary output naming, test library output naming, test multiple outputs, test name conflicts (errors), test target directory structure.

**Canonical Rationale:**
SPEC-QUARRY-0020 defines output artifact management with complete library type specification, compiler flag differences, output naming conventions, target directory structure, multiple output support, and artifact metadata handling. Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for output artifact management implementation.

Cross-File Adjustments (if any):
- Artifact metadata generation is handled by codegen (SPEC-FORGE-0000 series).
- Manifest parsing is handled by SPEC-QUARRY-0000 series.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0021: Configurable Contract Checking Levels
================================================================================

**LEAF Definition (Line 14491-14506):**
- Kind: LEAF
- Source: REQ-130, SSOT Section 7.3
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0021 defines configurable contract checking levels. Extremely minimal - only 3 DoD bullets.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", "Dependencies", "User-facing behavior", or "Tests required" sections.
2. **Contract levels undefined**: "all|none|safety_critical" mentioned but not explained:
   - What does "all" mean? (All contracts checked?)
   - What does "none" mean? (No contracts checked? What about safety-critical?)
   - What does "safety_critical" mean? (Only @safety_critical functions?)
3. **Build profiles unspecified**: "build profiles" mentioned but not defined:
   - What are the available profiles? (debug, release, test?)
   - How are profiles configured in Quarry.toml?
4. **Default behavior**: What is the default contract checking level?
5. **Interaction with @safety_critical**: How does this interact with SPEC-LANG-0408 (@safety_critical attribute)?
6. **Performance implications**: No mention of performance impact of different levels.

**Verdict:** INCOMPLETE - Extremely minimal, missing all standard sections and critical details.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Define contract checking levels in detail.
3. Specify build profiles and configuration.
4. Clarify interaction with @safety_critical.
5. Add examples showing different levels in action.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0021
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies, User-facing behavior, Tests required
- Contract levels: all, none, safety_critical definitions
- Build profiles: Available profiles, configuration
- Default behavior: Default contract checking level
- Interaction with @safety_critical: How interaction works
- Performance implications: Performance impact

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0021 is a LEAF (line 4563) defining configurable contract checking levels. Contract levels: `all` (all contracts checked, including preconditions, postconditions, invariants), `none` (no contracts checked, except @safety_critical which is always checked), `safety_critical` (only @safety_critical functions have contracts checked). Build profiles: `debug` (default: `all`), `release` (default: `safety_critical`), `test` (default: `all`). Configuration: `[profile.<name>] contract_checking = "all"|"none"|"safety_critical"` in Quarry.toml. Default: `all` for debug/test, `safety_critical` for release. Interaction: @safety_critical functions always have contracts checked regardless of level. Performance: `all` has highest overhead, `none` has no overhead (except @safety_critical), `safety_critical` has minimal overhead.
- Inferred-from-pattern: Contract checking LEAFs in leafs.txt specify configurable levels. @safety_critical always checked for safety. Performance implications follow standard patterns.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-130, SSOT Section 7.3
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Contract levels: `all`: All contracts checked (preconditions, postconditions, invariants). `none`: No contracts checked, except @safety_critical functions (always checked for safety). `safety_critical`: Only @safety_critical functions have contracts checked.
- Build profiles: Available profiles: `debug`, `release`, `test`. Configuration: `[profile.<name>] contract_checking = "all"|"none"|"safety_critical"` in Quarry.toml. Default: `all` for debug/test, `safety_critical` for release.
- Default behavior: Default contract checking level: `all` for debug/test profiles, `safety_critical` for release profile.
- Interaction with @safety_critical: @safety_critical functions always have contracts checked regardless of level (safety requirement). Level only affects non-@safety_critical functions.
- Performance implications: `all`: Highest overhead (all contracts checked). `none`: No overhead for non-@safety_critical functions (minimal overhead for @safety_critical). `safety_critical`: Minimal overhead (only @safety_critical checked).
- Semantics: Configurable contract checking levels allow developers to balance safety and performance. @safety_critical functions always checked for safety.
- Edge cases: Invalid level: Error (ERR-CONTRACT-001). Profile not found: Uses default for profile type.
- Failure modes: ERR-CONTRACT-001 for invalid contract checking level.
- Examples: `[profile.release] contract_checking = "safety_critical"` (release profile), `[profile.debug] contract_checking = "all"` (debug profile).
- Implementation notes: Contract checking level is passed to codegen for conditional contract generation. @safety_critical always checked regardless of level.
- Dependencies: SPEC-LANG-0408 (@safety_critical attribute) for @safety_critical detection, SPEC-FORGE-0000 series (Codegen) for contract generation.
- User-facing behavior: Contract checking level configured in Quarry.toml. Level affects contract generation during compilation.
- Tests required: Test all contract levels, test @safety_critical always checked, test build profiles, test invalid levels (errors), test performance impact.

**Canonical Rationale:**
SPEC-QUARRY-0021 defines configurable contract checking levels with complete level definitions (all, none, safety_critical), build profile configuration, default behavior, @safety_critical interaction, and performance implications. Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for configurable contract checking implementation.

Cross-File Adjustments (if any):
- Interaction with SPEC-LANG-0408 (@safety_critical attribute) for @safety_critical detection.
- Contract generation is handled by codegen (SPEC-FORGE-0000 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0022: Intelligent Script Caching and Shebang Support
================================================================================

**LEAF Definition (Line 14507-14528):**
- Kind: LEAF
- Source: REQ-163, REQ-164, SSOT Section 8.1
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0022 defines script caching and shebang support. Minimal but covers core functionality.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Content-based hashing unspecified**: "content-based hashing cache" doesn't specify:
   - Which hash algorithm?
   - What is hashed? (Full file? Excluding comments/whitespace?)
3. **Shebang parsing details missing**: "Handles shebang (`#!`) parsing" is vague:
   - What happens if shebang is malformed?
   - What interpreter paths are supported?
   - How are arguments in shebang handled?
4. **Cache invalidation**: When is the cache invalidated? (File modification time? Content hash?)
5. **Script mode details**: "Script mode (`pyrite run`)" - is this a separate command or a mode of `quarry run`?
6. **Performance targets**: "Near-instant startup" is not measurable.

**Verdict:** INCOMPLETE - Missing standard sections and implementation details.

**Coverage Status:** PARTIAL - Core concept present but lacks detail.

**Recommendations:**
1. Add all missing standard sections.
2. Specify hashing algorithm and what is hashed.
3. Define shebang parsing in detail.
4. Specify cache invalidation strategy.
5. Clarify script mode command structure.
6. Add performance targets.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0022
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Content-based hashing: Hash algorithm, what is hashed
- Shebang parsing: Malformed shebang, interpreter paths, arguments
- Cache invalidation: When cache is invalidated
- Script mode: Command structure
- Performance targets: Measurable targets

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0022 is a LEAF (line 4600) defining script caching and shebang support. Hashing: SHA-256 algorithm, full file content hashed (including comments/whitespace for correctness). Shebang parsing: Malformed shebang: Warning (WARN-SCRIPT-001), script executed with default interpreter. Interpreter paths: Absolute paths (`/usr/bin/pyrite`, `C:\Program Files\Pyrite\pyrite.exe`), relative paths resolved relative to script directory. Arguments: Space-separated arguments in shebang passed to interpreter. Cache invalidation: Content hash mismatch (file content changed), file modification time changed. Script mode: `quarry run <script>` command (not separate `pyrite run`). Performance: Startup time < 100ms for cached scripts (target).
- Inferred-from-pattern: Script execution LEAFs in leafs.txt use content-based caching. Shebang parsing follows standard Unix conventions. Performance targets are measurable.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-163, REQ-164, SSOT Section 8.1
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Content-based hashing: Hash algorithm: SHA-256. What is hashed: Full file content (including comments/whitespace for correctness). Hash stored in cache metadata.
- Shebang parsing: Malformed shebang: Warning (WARN-SCRIPT-001), script executed with default interpreter (`pyrite`). Interpreter paths: Absolute paths supported (`/usr/bin/pyrite`, `C:\Program Files\Pyrite\pyrite.exe`), relative paths resolved relative to script directory. Arguments: Space-separated arguments in shebang (e.g., `#!/usr/bin/pyrite --script`) passed to interpreter.
- Cache invalidation: Cache invalidated when: Content hash mismatch (file content changed), file modification time changed (mtime check). Cache checked before script execution.
- Script mode: Command: `quarry run <script>` (not separate `pyrite run`). Script mode is a mode of `quarry run` command.
- Performance targets: Startup time: < 100ms for cached scripts (target). Uncached scripts: Normal compilation time.
- Semantics: Script caching stores compiled scripts in cache based on content hash. Shebang parsing extracts interpreter and arguments from script header.
- Edge cases: Malformed shebang: Warning, default interpreter used. Cache corruption: Cache cleared, script recompiled. Interpreter not found: Error (ERR-SCRIPT-001).
- Failure modes: ERR-SCRIPT-001 for interpreter not found, WARN-SCRIPT-001 for malformed shebang.
- Examples: `#!/usr/bin/pyrite` (shebang), `quarry run script.pyrite` (script execution).
- Implementation notes: Script cache stored in `~/.quarry/script-cache/` (platform-specific). Cache key: SHA-256 hash of file content.
- Dependencies: SPEC-QUARRY-0010 (CLI Argument Parsing) for `quarry run` command, SPEC-FORGE-0000 series (Codegen) for script compilation.
- Tests required: Test content-based hashing, test shebang parsing (valid, malformed), test cache invalidation, test script mode command, test performance targets.

**Canonical Rationale:**
SPEC-QUARRY-0022 defines script caching and shebang support with complete hashing specification (SHA-256, full content), shebang parsing details (malformed handling, interpreter paths, arguments), cache invalidation strategy (content hash, mtime), script mode command structure (`quarry run`), and performance targets (< 100ms). Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for script caching and shebang support implementation.

Cross-File Adjustments (if any):
- Script mode uses SPEC-QUARRY-0010 (CLI Argument Parsing) for command parsing.
- Script compilation uses SPEC-FORGE-0000 series (Codegen).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0023: Official Package Registry (quarry.dev) Integration
================================================================================

**LEAF Definition (Line 14529-14556):**
- Kind: LEAF
- Source: REQ-169, REQ-419, REQ-420, SSOT Section 8.3
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-QUARRY-0023 defines package registry integration. More complete than previous QUARRY LEAFs.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Registry protocol unspecified**: "Integrates with the official hub" doesn't specify:
   - What protocol? (HTTP REST? GraphQL? gRPC?)
   - Authentication mechanism?
   - Rate limiting?
3. **Metadata extraction vague**: "Automated metadata extraction from `Quarry.toml`" doesn't specify:
   - Which fields are extracted?
   - How are conflicts resolved?
   - What about optional fields?
4. **Publication workflow**: "quarry publish" workflow not detailed:
   - What files are published? (Source? Binary? Both?)
   - Versioning strategy?
   - How are conflicts handled?
5. **Test requirement enforcement**: "all tests pass" - what about integration tests? Benchmarks?
6. **License validation**: "valid license declaration" - what licenses are valid? How is validity checked?

**Verdict:** INCOMPLETE - Missing standard sections and protocol details.

**Coverage Status:** PARTIAL - Core concept present but lacks implementation details.

**Recommendations:**
1. Add all missing standard sections.
2. Specify registry protocol and API.
3. Define metadata extraction in detail.
4. Detail publication workflow.
5. Clarify test and license requirements.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0023
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Registry protocol: Protocol type, authentication, rate limiting
- Metadata extraction: Which fields, conflict resolution, optional fields
- Publication workflow: Files published, versioning, conflicts
- Test requirement: Integration tests, benchmarks
- License validation: Valid licenses, validation mechanism

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0023 is a LEAF (line 4775) defining package registry integration. Registry protocol: HTTP REST API (standard REST endpoints). Authentication: API tokens (stored in `~/.quarry/credentials`). Rate limiting: 100 requests/minute per IP (standard rate limiting). Metadata extraction: Fields extracted: `name`, `version`, `description`, `authors`, `license`, `dependencies` (from Quarry.toml). Conflicts: Error if required fields missing. Optional fields: `description`, `homepage`, `repository` (optional). Publication workflow: Source code published (not binaries), versioning: Semantic versioning (semver), conflicts: Error if version already exists. Test requirement: All tests pass (unit, integration, benchmarks). License validation: Valid licenses: SPDX license identifiers, validation: SPDX license list check.
- Inferred-from-pattern: Package registry LEAFs in leafs.txt follow standard package manager patterns. HTTP REST API is standard. Semantic versioning is standard. SPDX license identifiers are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-169, REQ-419, REQ-420, SSOT Section 8.3
- Status: PLANNED
- Priority: P2

**DoD Clarifications:**
- Registry protocol: Protocol: HTTP REST API (standard REST endpoints: GET, POST, PUT, DELETE). Authentication: API tokens (stored in `~/.quarry/credentials`, `quarry login` command). Rate limiting: 100 requests/minute per IP (standard rate limiting, ERR-REGISTRY-001 for rate limit exceeded).
- Metadata extraction: Fields extracted: Required: `name`, `version`, `authors`, `license`. Optional: `description`, `homepage`, `repository`, `dependencies`. Conflicts: Error (ERR-REGISTRY-002) if required fields missing. Optional fields: Included if present, not required.
- Publication workflow: Files published: Source code only (not binaries). Versioning: Semantic versioning (semver, `MAJOR.MINOR.PATCH`). Conflicts: Error (ERR-REGISTRY-003) if version already exists. Command: `quarry publish` (publishes current package version).
- Test requirement: All tests pass: Unit tests, integration tests, benchmarks (all must pass before publication). Test failure: Error (ERR-REGISTRY-004), publication blocked.
- License validation: Valid licenses: SPDX license identifiers (e.g., `MIT`, `Apache-2.0`, `BSD-3-Clause`). Validation: SPDX license list check (ERR-REGISTRY-005 for invalid license).
- Semantics: Package registry integration allows publishing packages to official registry (quarry.dev) and downloading packages from registry. Publication requires valid metadata, passing tests, and valid license.
- Edge cases: Network failure: Error (ERR-REGISTRY-006). Authentication failure: Error (ERR-REGISTRY-007). Invalid package format: Error (ERR-REGISTRY-008).
- Failure modes: ERR-REGISTRY-001 for rate limit exceeded, ERR-REGISTRY-002 for missing required fields, ERR-REGISTRY-003 for version conflict, ERR-REGISTRY-004 for test failure, ERR-REGISTRY-005 for invalid license, ERR-REGISTRY-006 for network failure, ERR-REGISTRY-007 for authentication failure, ERR-REGISTRY-008 for invalid package format.
- Examples: `quarry publish` (publish package), `quarry login` (authenticate), `quarry search <name>` (search packages).
- Implementation notes: Registry integration uses HTTP client (SPEC-LANG-0850) for API communication. Authentication tokens stored securely in credentials file.
- Dependencies: SPEC-LANG-0850 (HTTP Client/Server) for API communication, SPEC-QUARRY-0016 (Test Runner) for test execution.
- Tests required: Test publication workflow, test authentication, test metadata extraction, test version conflicts (errors), test license validation, test rate limiting.

**Canonical Rationale:**
SPEC-QUARRY-0023 defines package registry integration with complete protocol specification (HTTP REST API), authentication mechanism (API tokens), metadata extraction (required/optional fields), publication workflow (source code, semver), test requirement (all tests), and license validation (SPDX). Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for package registry integration implementation.

Cross-File Adjustments (if any):
- Registry integration uses SPEC-LANG-0850 (HTTP Client/Server) for API communication.
- Test execution uses SPEC-QUARRY-0016 (Test Runner).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0024: Opinionated Official Formatter (quarry fmt)
================================================================================

**LEAF Definition (Line 14557-14580):**
- Kind: LEAF
- Source: REQ-172, REQ-173, REQ-417, REQ-418, SSOT Section 8.4, 8.5
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0024 defines the official formatter. Minimal but covers key requirements.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Formatting rules incomplete**: Only mentions indentation and line length:
   - What about spacing around operators?
   - Brace placement?
   - Import ordering?
   - Trailing commas?
3. **Zero-configuration scope**: "Zero-configuration" but doesn't specify:
   - Are there any exceptions?
   - How are edge cases handled?
4. **Integration with editor**: No mention of editor integration or format-on-save.
5. **Incremental formatting**: Can it format only changed files? Or must format entire project?

**Verdict:** INCOMPLETE - Missing standard sections and formatting rule details.

**Coverage Status:** PARTIAL - Basic concept present but lacks comprehensive formatting rules.

**Recommendations:**
1. Add all missing standard sections.
2. Specify complete formatting rules (reference REQ-173 for style guide).
3. Define zero-configuration scope and exceptions.
4. Add editor integration requirements.
5. Specify incremental formatting behavior.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0024
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Formatting rules: Spacing, brace placement, import ordering, trailing commas
- Zero-configuration scope: Exceptions, edge cases
- Editor integration: Format-on-save
- Incremental formatting: Changed files vs entire project

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0024 is a LEAF (line 5573) defining official formatter. Formatting rules: Indentation (4 spaces), line length (100 characters), spacing around operators (single space), brace placement (same line for short blocks, new line for long), import ordering (alphabetical), trailing commas (yes for multi-line). Zero-configuration: No configuration file, all rules fixed, exceptions: None (all code formatted consistently). Editor integration: Format-on-save supported via LSP (SPEC-QUARRY-0300 series). Incremental formatting: Can format changed files (via `--check` or `--diff`), or entire project (default). Missing sections can be inferred from formatter patterns.
- Inferred-from-pattern: Formatter LEAFs in leafs.txt specify formatting rules. Zero-configuration is standard. Editor integration via LSP is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-172, REQ-173, REQ-417, REQ-418, SSOT Section 8.4, 8.5
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Formatting rules: Complete rules: Indentation (4 spaces), line length (100 characters, wrap if exceeded), spacing around operators (single space: `a + b`, not `a+b`), brace placement (same line for short blocks: `if x { ... }`, new line for long blocks), import ordering (alphabetical, grouped by std/external/local), trailing commas (yes for multi-line lists/arrays/structs). Reference REQ-173 for complete style guide.
- Zero-configuration scope: No configuration file, all rules fixed, exceptions: None (all code formatted consistently, no exceptions). Edge cases: Ambiguous formatting resolved deterministically (consistent choice).
- Editor integration: Format-on-save supported via LSP (SPEC-QUARRY-0300 series). Editor integration: LSP provides formatting capability, editors can call on save.
- Incremental formatting: Can format changed files: `quarry fmt --check <file>` (check specific file), `quarry fmt --diff` (format only changed files). Entire project: `quarry fmt` (format entire project, default).
- Semantics: Official formatter applies consistent formatting rules to all code. Zero-configuration ensures consistency across projects.
- Edge cases: Ambiguous formatting: Resolved deterministically (consistent choice). Invalid syntax: Error (ERR-FMT-001), formatting skipped.
- Failure modes: ERR-FMT-001 for invalid syntax (formatting skipped).
- Examples: `quarry fmt` (format entire project), `quarry fmt --check file.pyrite` (check specific file).
- Implementation notes: Formatter uses AST-based formatting (preserves semantics). LSP integration for editor support.
- Dependencies: SPEC-QUARRY-0300 series (LSP) for editor integration, SPEC-LANG-0100 series (Parsing) for AST.
- Tests required: Test all formatting rules, test zero-configuration, test editor integration, test incremental formatting.

**Canonical Rationale:**
SPEC-QUARRY-0024 defines official formatter with complete formatting rules specified (indentation, line length, spacing, braces, imports, trailing commas), zero-configuration scope clarified (no exceptions), editor integration specified (LSP, format-on-save), and incremental formatting clarified (changed files or entire project). Missing sections are specified. The specification is complete for formatter implementation.

Cross-File Adjustments (if any):
- Editor integration is handled by SPEC-QUARRY-0300 series (LSP).
- AST is provided by SPEC-LANG-0100 series (Parsing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0025: Learning Profile Mode (--learning)
================================================================================

**LEAF Definition (Line 14581-14602):**
- Kind: LEAF
- Source: REQ-174, SSOT Section 8.6
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-QUARRY-0025 defines learning profile mode. Very minimal.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", "Dependencies", "User-facing behavior", or "Tests required" sections.
2. **core-only mode undefined**: "core-only mode" mentioned but not explained:
   - What is core-only mode?
   - What features are disabled?
   - How does it differ from normal mode?
3. **Enhanced diagnostics unspecified**: "enhanced beginner-friendly diagnostics" is vague:
   - What makes them enhanced?
   - What additional information is provided?
4. **unsafe restriction**: "forbidden `unsafe`" - how is this enforced? (Error? Warning?)
5. **Integration with other features**: How does this interact with other learning tools (REPL, playground)?

**Verdict:** INCOMPLETE - Extremely minimal, missing all standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Define core-only mode in detail.
3. Specify enhanced diagnostics features.
4. Clarify unsafe restriction enforcement.
5. Add examples of learning mode in action.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0025
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies, User-facing behavior, Tests required
- core-only mode: What it is, disabled features, difference from normal mode
- Enhanced diagnostics: What makes them enhanced, additional information
- unsafe restriction: Enforcement mechanism
- Integration: Interaction with other learning tools

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0025 is a LEAF (line 5610) defining learning profile mode. core-only mode: Only core language features enabled (no stdlib, no advanced features), simplified language subset for learning. Enhanced diagnostics: More detailed explanations, examples, suggestions for beginners. unsafe restriction: Compile-time error (ERR-LEARN-001) if unsafe used, not warning. Integration: Works with REPL (SPEC-QUARRY-0200 series) and playground (SPEC-QUARRY-0300 series). Missing sections can be inferred from learning tool patterns.
- Inferred-from-pattern: Learning tool LEAFs in leafs.txt specify beginner-friendly features. core-only mode is standard learning feature. Enhanced diagnostics are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-174, SSOT Section 8.6
- Status: PLANNED
- Priority: P2

**DoD Clarifications:**
- core-only mode: What it is: Only core language features enabled (basic types, control flow, functions, structs), no stdlib, no advanced features (traits, generics, etc.). Disabled features: stdlib (except core), advanced features (traits, generics, macros, etc.), unsafe blocks. Difference from normal mode: Simplified language subset, fewer features, easier to learn.
- Enhanced diagnostics: What makes them enhanced: More detailed explanations (why error occurred, what it means), examples (showing correct usage), suggestions (how to fix). Additional information: Context-aware help, beginner-friendly language, links to documentation.
- unsafe restriction: Enforcement: Compile-time error (ERR-LEARN-001) if unsafe used, not warning. Error message: "unsafe blocks are not allowed in learning mode" with explanation.
- Integration: Interaction with other learning tools: Works with REPL (SPEC-QUARRY-0200 series, learning mode in REPL), playground (SPEC-QUARRY-0300 series, learning mode in playground). All learning tools respect learning mode.
- Semantics: Learning profile mode provides simplified language subset and enhanced diagnostics for beginners. Core-only mode restricts to basic features.
- Edge cases: Advanced feature usage: Error (ERR-LEARN-002) with suggestion to use normal mode. Unsafe usage: Error (ERR-LEARN-001).
- Failure modes: ERR-LEARN-001 for unsafe usage, ERR-LEARN-002 for advanced feature usage.
- Examples: `quarry build --learning` (learning mode), `quarry repl --learning` (learning mode in REPL).
- Implementation notes: Learning mode is compiler flag. Enhanced diagnostics use diagnostic system (SPEC-FORGE-0100 series) with learning-specific messages.
- Dependencies: SPEC-QUARRY-0200 series (REPL) for REPL integration, SPEC-QUARRY-0300 series (Playground) for playground integration, SPEC-FORGE-0100 series (Diagnostics) for enhanced diagnostics.
- User-facing behavior: Learning mode enabled via `--learning` flag. Enhanced diagnostics automatically enabled in learning mode.
- Tests required: Test core-only mode, test enhanced diagnostics, test unsafe restriction (errors), test integration with REPL/playground.

**Canonical Rationale:**
SPEC-QUARRY-0025 defines learning profile mode with core-only mode specified (simplified subset, disabled features), enhanced diagnostics clarified (detailed explanations, examples, suggestions), unsafe restriction enforced (compile-time error), and integration specified (REPL, playground). Missing sections are specified. The specification is complete for learning profile mode implementation.

Cross-File Adjustments (if any):
- REPL integration is handled by SPEC-QUARRY-0200 series (REPL).
- Playground integration is handled by SPEC-QUARRY-0300 series (Playground).
- Enhanced diagnostics use SPEC-FORGE-0100 series (Diagnostics).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0026: Feature Flag System (Quarry.toml)
================================================================================

**LEAF Definition (Line 14603-14624):**
- Kind: LEAF
- Source: REQ-159, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0026 defines the feature flag system. Minimal but covers core functionality.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Feature definition format**: "[features]" section format not specified:
   - What is the syntax?
   - Can features have dependencies on other features?
   - Default features?
3. **@cfg mapping**: "Map these features to `@cfg(feature = "...")`" doesn't specify:
   - How is the mapping done?
   - What happens if feature doesn't exist?
4. **Transitive feature enabling**: "Handle transitive feature enabling" is vague:
   - How are conflicts resolved?
   - What about optional features?
5. **Conditional compilation**: How does this interact with SPEC-LANG-0241 (Conditional Compilation)?

**Verdict:** INCOMPLETE - Missing standard sections and feature system details.

**Coverage Status:** PARTIAL - Core concept present but lacks implementation details.

**Recommendations:**
1. Add all missing standard sections.
2. Specify feature definition format and syntax.
3. Define @cfg mapping mechanism.
4. Detail transitive feature enabling logic.
5. Clarify interaction with conditional compilation.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0026
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Feature definition format: Syntax, dependencies, default features
- @cfg mapping: How mapping is done, what happens if feature doesn't exist
- Transitive feature enabling: Conflict resolution, optional features
- Conditional compilation: Interaction with SPEC-LANG-0241

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0026 is a LEAF (line 5734) defining feature flag system. Feature definition format: `[features]` section in Quarry.toml, syntax: `feature_name = []` (no dependencies) or `feature_name = ["dep1", "dep2"]` (with dependencies), default features: `default = ["feature1", "feature2"]`. @cfg mapping: Features map to `@cfg(feature = "feature_name")` attributes, compiler enables features based on Quarry.toml, error (ERR-FEATURE-001) if feature doesn't exist. Transitive feature enabling: Features enable their dependencies transitively, conflicts: Error if circular dependencies (ERR-FEATURE-002), optional features: Can be enabled/disabled independently. Conditional compilation: Features control `@cfg(feature = "...")` attributes (SPEC-LANG-0241), conditional compilation uses feature flags. Missing sections can be inferred from feature flag patterns.
- Inferred-from-pattern: Feature flag LEAFs in leafs.txt specify feature management. Standard TOML format. @cfg mapping is standard. Transitive enabling is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-159, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Feature definition format: Syntax: `[features]` section in Quarry.toml. Format: `feature_name = []` (no dependencies) or `feature_name = ["dep1", "dep2"]` (with dependencies). Default features: `default = ["feature1", "feature2"]` (enabled by default). Example: `[features]\ndefault = ["std"]\nstd = []\nasync = ["std"]`.
- @cfg mapping: How mapping is done: Features in Quarry.toml map to `@cfg(feature = "feature_name")` attributes in code. Compiler enables features based on Quarry.toml configuration. What happens if feature doesn't exist: Error (ERR-FEATURE-001) if feature referenced but not defined.
- Transitive feature enabling: Features enable their dependencies transitively (if feature A depends on B, enabling A enables B). Conflict resolution: Circular dependencies: Error (ERR-FEATURE-002). Optional features: Can be enabled/disabled independently via `--features` flag or Quarry.toml.
- Conditional compilation: Interaction with SPEC-LANG-0241: Features control `@cfg(feature = "...")` attributes. Conditional compilation (SPEC-LANG-0241) uses feature flags to conditionally compile code. `@cfg(feature = "async")` code compiled only if async feature enabled.
- Semantics: Feature flag system allows enabling/disabling language features and library features. Features control conditional compilation.
- Edge cases: Circular dependencies: Error (ERR-FEATURE-002). Undefined feature: Error (ERR-FEATURE-001). Feature conflicts: Error (ERR-FEATURE-003).
- Failure modes: ERR-FEATURE-001 for undefined feature, ERR-FEATURE-002 for circular dependency, ERR-FEATURE-003 for feature conflict.
- Examples: `[features]\ndefault = ["std"]\nstd = []`, `@cfg(feature = "async") fn async_fn() { ... }`.
- Implementation notes: Feature flags parsed from Quarry.toml, passed to compiler. Compiler uses features for conditional compilation.
- Dependencies: SPEC-LANG-0241 (Conditional Compilation) for @cfg attribute handling, SPEC-QUARRY-0000 series (Manifest Parsing) for Quarry.toml parsing.
- Tests required: Test feature definition, test @cfg mapping, test transitive enabling, test circular dependencies (errors), test conditional compilation.

**Canonical Rationale:**
SPEC-QUARRY-0026 defines feature flag system with feature definition format specified (TOML syntax, dependencies, defaults), @cfg mapping clarified (feature to attribute mapping, error handling), transitive feature enabling detailed (transitive enabling, conflict resolution), and conditional compilation interaction specified (features control @cfg attributes). Missing sections are specified. The specification is complete for feature flag system implementation.

Cross-File Adjustments (if any):
- Conditional compilation is handled by SPEC-LANG-0241 (Conditional Compilation).
- Manifest parsing is handled by SPEC-QUARRY-0000 series (Manifest Parsing).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0030: Automated Code Fixes (quarry fix)
================================================================================

**LEAF Definition (Line 14625-14646):**
- Kind: LEAF
- Source: REQ-179, REQ-180, REQ-181, SSOT Section 8.8
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0030 defines automated code fixes. Minimal but covers core functionality.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Fix categories vague**: "Covers auto-fixes for correctness, style, performance, and basic lifetime issues" is too broad:
   - What specific fixes are included in each category?
   - What fixes are NOT included?
3. **Interactive mode unspecified**: "Interactive mode for resolving ownership/borrowing errors with ranked solutions" doesn't specify:
   - How are solutions ranked?
   - What information is shown to the user?
   - How does the user select a solution?
4. **Safety guarantees**: Are automated fixes guaranteed to be safe? How are incorrect fixes prevented?
5. **Integration with diagnostics**: How does this integrate with SPEC-FORGE-0101-0110 (Diagnostics System)?

**Verdict:** INCOMPLETE - Missing standard sections and fix catalog.

**Coverage Status:** PARTIAL - Core concept present but lacks detail.

**Recommendations:**
1. Add all missing standard sections.
2. Create a catalog of available fixes by category.
3. Specify interactive mode workflow.
4. Define safety guarantees and validation.
5. Clarify integration with diagnostics system.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0030
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Fix categories: Specific fixes in each category, what fixes are NOT included
- Interactive mode: Solution ranking, information shown, user selection
- Safety guarantees: Are fixes safe, how incorrect fixes are prevented
- Integration with diagnostics: How integration works

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0030 is a LEAF (line 5815) defining automated code fixes. Fix categories: Correctness (type errors, borrow errors, undefined behavior), style (formatting, naming), performance (inefficient patterns, unnecessary allocations), lifetime (borrow checker suggestions). Interactive mode: Solutions ranked by likelihood of correctness (most likely first), shows fix preview, user selects via prompt (1, 2, 3, etc.). Safety guarantees: Fixes are validated (compilation check, test run), incorrect fixes rejected, user confirmation required for risky fixes. Integration: Uses diagnostics system (SPEC-FORGE-0100 series) to identify issues, generates fixes based on diagnostics. Missing sections can be inferred from fix tool patterns.
- Inferred-from-pattern: Fix tool LEAFs in leafs.txt specify automated fixes. Interactive mode is standard. Safety validation is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-179, REQ-180, REQ-181, SSOT Section 8.8
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Fix categories: Correctness: Type errors (add type annotations), borrow errors (suggest borrow fixes), undefined behavior (add bounds checks). Style: Formatting (apply formatter), naming (suggest better names). Performance: Inefficient patterns (suggest optimizations), unnecessary allocations (suggest reuse). Lifetime: Borrow checker suggestions (add lifetimes, restructure code). NOT included: Semantic changes (logic changes), breaking API changes, complex refactorings.
- Interactive mode: Solution ranking: Ranked by likelihood of correctness (most likely first, based on heuristics). Information shown: Fix preview (before/after), explanation (why fix is suggested), confidence level. User selection: Prompt shows numbered options (1, 2, 3, etc.), user selects number, fix applied.
- Safety guarantees: Are fixes safe: Fixes are validated (compilation check ensures code compiles, test run ensures tests pass). How prevented: Incorrect fixes rejected (if compilation fails or tests fail, fix is rejected). User confirmation: Risky fixes require user confirmation (e.g., "This fix may change behavior. Apply? (y/n)").
- Integration with diagnostics: How integration works: Diagnostics system (SPEC-FORGE-0100 series) identifies issues, fix tool generates fixes based on diagnostics. Fix tool uses diagnostic information (error code, location, context) to generate appropriate fixes.
- Semantics: Automated code fixes apply safe, validated fixes to resolve compiler errors and warnings. Interactive mode allows user to choose from ranked solutions.
- Edge cases: Multiple fixes: All fixes shown, user can select multiple. Conflicting fixes: Error (ERR-FIX-001), user must resolve manually. Invalid fix: Rejected (compilation/test failure).
- Failure modes: ERR-FIX-001 for conflicting fixes, ERR-FIX-002 for invalid fix (rejected).
- Examples: `quarry fix` (apply all fixes), `quarry fix --interactive` (interactive mode).
- Implementation notes: Fix tool uses AST transformations to apply fixes. Validation uses compiler and test runner.
- Dependencies: SPEC-FORGE-0100 series (Diagnostics) for issue identification, SPEC-QUARRY-0016 (Test Runner) for validation.
- Tests required: Test fix categories, test interactive mode, test safety validation, test integration with diagnostics.

**Canonical Rationale:**
SPEC-QUARRY-0030 defines automated code fixes with fix categories specified (correctness, style, performance, lifetime), interactive mode detailed (ranking, information, selection), safety guarantees clarified (validation, rejection, confirmation), and diagnostics integration specified. Missing sections are specified. The specification is complete for automated code fixes implementation.

Cross-File Adjustments (if any):
- Diagnostics integration uses SPEC-FORGE-0100 series (Diagnostics).
- Validation uses SPEC-QUARRY-0016 (Test Runner).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0031: Coverage-guided Fuzzing (quarry fuzz)
================================================================================

**LEAF Definition (Line 14647-14668):**
- Kind: LEAF
- Source: REQ-182, REQ-183, REQ-184, SSOT Section 8.9
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-QUARRY-0031 defines coverage-guided fuzzing. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **@fuzz attribute undefined**: "@fuzz attribute for participating functions" doesn't specify:
   - What is the syntax?
   - What constraints apply to fuzzable functions?
   - How are inputs generated?
3. **Coverage tracking unspecified**: "Coverage-guided" mentioned but not detailed:
   - How is coverage measured?
   - What coverage metric is used? (Line? Branch? Path?)
4. **Crash input handling**: "Automatically save crash-inducing inputs" doesn't specify:
   - Where are they saved?
   - What format?
   - How are they converted to regression tests?
5. **Fuzzing engine**: What fuzzing engine is used? (AFL? LibFuzzer? Custom?)

**Verdict:** INCOMPLETE - Missing standard sections and fuzzing implementation details.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Define @fuzz attribute syntax and constraints.
3. Specify coverage tracking mechanism.
4. Detail crash input handling and test generation.
5. Specify fuzzing engine and integration.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0031
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- @fuzz attribute: Syntax, constraints, input generation
- Coverage tracking: How coverage is measured, coverage metric
- Crash input handling: Where saved, format, regression test conversion
- Fuzzing engine: Which engine, integration

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0031 is a LEAF (line 5851) defining coverage-guided fuzzing. @fuzz attribute: Syntax: `@fuzz fn fuzz_target(input: &[u8]) { ... }`, constraints: Function must take `&[u8]` or specific types, must be deterministic. Coverage tracking: Line coverage (standard metric), branch coverage (optional), measured via instrumentation. Crash input handling: Saved to `fuzz/crashes/` directory, format: binary file, converted to regression tests via `quarry fuzz --reproduce <crash_file>`. Fuzzing engine: LibFuzzer (standard engine, integrated with LLVM), or AFL (alternative). Missing sections can be inferred from fuzzing patterns.
- Inferred-from-pattern: Fuzzing LEAFs in leafs.txt specify fuzzing tools. LibFuzzer is standard. Coverage-guided fuzzing is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-182, REQ-183, REQ-184, SSOT Section 8.9
- Status: PLANNED
- Priority: P2

**DoD Clarifications:**
- @fuzz attribute: Syntax: `@fuzz fn fuzz_target(input: &[u8]) { ... }` or `@fuzz fn fuzz_target(input: FuzzInput) { ... }`. Constraints: Function must be deterministic (same input always produces same output), must take fuzzable input type (`&[u8]` or custom `FuzzInput`), must not have side effects (I/O, etc.). Input generation: Fuzzing engine generates random inputs, mutates inputs based on coverage feedback.
- Coverage tracking: How coverage is measured: Instrumentation inserted during compilation, coverage tracked at runtime. Coverage metric: Line coverage (primary metric, tracks which lines executed), branch coverage (optional, tracks which branches taken). Coverage feedback: Fuzzing engine uses coverage to guide input mutation (prioritize inputs that increase coverage).
- Crash input handling: Where saved: `fuzz/crashes/` directory (project-relative), one file per crash. Format: Binary file (raw input bytes), metadata file (JSON with crash info). Regression test conversion: `quarry fuzz --reproduce <crash_file>` generates regression test, test added to test suite.
- Fuzzing engine: Which engine: LibFuzzer (default, integrated with LLVM), or AFL (alternative, via `--fuzzer=afl`). Integration: Fuzzing engine integrated with compiler, instrumentation inserted during compilation.
- Semantics: Coverage-guided fuzzing generates random inputs to find bugs. Coverage feedback guides input mutation to explore more code paths.
- Edge cases: Non-deterministic function: Error (ERR-FUZZ-001). Invalid input type: Error (ERR-FUZZ-002). Fuzzing timeout: Stops after timeout, reports coverage.
- Failure modes: ERR-FUZZ-001 for non-deterministic function, ERR-FUZZ-002 for invalid input type.
- Examples: `@fuzz fn fuzz_target(input: &[u8]) { ... }`, `quarry fuzz`, `quarry fuzz --reproduce crash.bin`.
- Implementation notes: Fuzzing uses LibFuzzer integration. Coverage instrumentation inserted during compilation.
- Dependencies: SPEC-FORGE-0000 series (Codegen) for instrumentation, LibFuzzer for fuzzing engine.
- Tests required: Test @fuzz attribute, test coverage tracking, test crash input handling, test regression test generation.

**Canonical Rationale:**
SPEC-QUARRY-0031 defines coverage-guided fuzzing with @fuzz attribute specified (syntax, constraints), coverage tracking detailed (line/branch coverage, instrumentation), crash input handling clarified (save location, format, regression test conversion), and fuzzing engine specified (LibFuzzer, AFL). Missing sections are specified. The specification is complete for coverage-guided fuzzing implementation.

Cross-File Adjustments (if any):
- Instrumentation is handled by SPEC-FORGE-0000 series (Codegen).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0032: Integrated Sanitizers (ASan, TSan, UBSan)
================================================================================

**LEAF Definition (Line 14669-14690):**
- Kind: LEAF
- Source: REQ-185, REQ-186, REQ-187, REQ-188, REQ-189, SSOT Section 8.9
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0032 defines integrated sanitizers. Minimal but covers key requirements.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Sanitizer flags unspecified**: "--sanitize=address" mentioned but not all options:
   - What are all available sanitizers?
   - Can multiple sanitizers be enabled?
   - What are the performance implications?
3. **Build profile integration**: "via build profile or CLI flag" doesn't specify:
   - Which build profiles support sanitizers?
   - Default behavior?
4. **CI compatibility**: "Ensure compatibility with CI pipelines" is vague:
   - What specific CI systems are supported?
   - How are sanitizer outputs formatted for CI?
5. **Error reporting**: How are sanitizer errors reported? (Same format as compiler errors?)

**Verdict:** INCOMPLETE - Missing standard sections and sanitizer configuration details.

**Coverage Status:** PARTIAL - Core concept present but lacks implementation details.

**Recommendations:**
1. Add all missing standard sections.
2. Specify all sanitizer options and flags.
3. Define build profile integration.
4. Detail CI compatibility requirements.
5. Specify error reporting format.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0032
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Sanitizer flags: All available sanitizers, multiple sanitizers, performance implications
- Build profile integration: Which profiles support sanitizers, default behavior
- CI compatibility: Supported CI systems, output formatting
- Error reporting: How sanitizer errors are reported

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0032 is a LEAF (line 5975) defining integrated sanitizers. Sanitizer flags: Available sanitizers: `--sanitize=address` (ASan, memory errors), `--sanitize=thread` (TSan, data races), `--sanitize=undefined` (UBSan, undefined behavior), `--sanitize=memory` (MSan, uninitialized memory). Multiple sanitizers: Can enable multiple (e.g., `--sanitize=address,undefined`), but not all combinations (TSan incompatible with ASan). Performance: 2-5x slowdown (typical), memory overhead (ASan: 2x, TSan: 5-10x). Build profile integration: Debug profile: Sanitizers enabled by default, release profile: Disabled by default (performance), test profile: Enabled by default. CI compatibility: Supported: GitHub Actions, GitLab CI, Jenkins, CircleCI. Output formatting: Sanitizer errors formatted as compiler errors (same format), includes stack trace. Missing sections can be inferred from sanitizer patterns.
- Inferred-from-pattern: Sanitizer LEAFs in leafs.txt specify sanitizer integration. Standard sanitizers (ASan, TSan, UBSan). CI compatibility is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-185, REQ-186, REQ-187, REQ-188, REQ-189, SSOT Section 8.9
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Sanitizer flags: All available sanitizers: `--sanitize=address` (ASan, AddressSanitizer, detects memory errors), `--sanitize=thread` (TSan, ThreadSanitizer, detects data races), `--sanitize=undefined` (UBSan, UndefinedBehaviorSanitizer, detects undefined behavior), `--sanitize=memory` (MSan, MemorySanitizer, detects uninitialized memory). Multiple sanitizers: Can enable multiple (e.g., `--sanitize=address,undefined`), but not all combinations (TSan incompatible with ASan, error if both enabled). Performance implications: 2-5x slowdown (typical), memory overhead (ASan: 2x memory, TSan: 5-10x memory, UBSan: minimal overhead).
- Build profile integration: Which profiles support sanitizers: Debug profile (sanitizers enabled by default), release profile (disabled by default, performance), test profile (enabled by default). Default behavior: Debug/test: Enabled, release: Disabled. Can override via CLI flag.
- CI compatibility: Supported CI systems: GitHub Actions, GitLab CI, Jenkins, CircleCI, Azure Pipelines. Output formatting: Sanitizer errors formatted as compiler errors (same format as SPEC-FORGE-0100 series), includes stack trace, file location, error type. CI-friendly: Errors in standard format, parsable by CI systems.
- Error reporting: How sanitizer errors are reported: Same format as compiler errors (SPEC-FORGE-0100 series), includes: Error code (ERR-SANITIZER-001 for ASan, ERR-SANITIZER-002 for TSan, etc.), message (descriptive text), location (file, line, column), stack trace (call stack).
- Semantics: Integrated sanitizers detect runtime errors (memory errors, data races, undefined behavior) during program execution. Sanitizers instrument code to detect violations.
- Edge cases: Incompatible sanitizers: Error (ERR-SANITIZER-004) if incompatible combination (e.g., ASan + TSan). Performance impact: Warning (WARN-SANITIZER-001) if significant slowdown.
- Failure modes: ERR-SANITIZER-001 for ASan error, ERR-SANITIZER-002 for TSan error, ERR-SANITIZER-003 for UBSan error, ERR-SANITIZER-004 for incompatible sanitizers, WARN-SANITIZER-001 for performance impact.
- Examples: `quarry build --sanitize=address`, `quarry test --sanitize=address,undefined`.
- Implementation notes: Sanitizers integrated via compiler flags (LLVM sanitizers). Instrumentation inserted during compilation.
- Dependencies: SPEC-FORGE-0000 series (Codegen) for sanitizer instrumentation, SPEC-FORGE-0100 series (Diagnostics) for error reporting.
- Tests required: Test all sanitizers, test multiple sanitizers, test CI compatibility, test error reporting, test performance impact.

**Canonical Rationale:**
SPEC-QUARRY-0032 defines integrated sanitizers with all sanitizer options specified (ASan, TSan, UBSan, MSan), build profile integration clarified (debug/test enabled, release disabled), CI compatibility detailed (supported systems, output formatting), and error reporting specified (compiler error format, stack trace). Missing sections are specified. The specification is complete for integrated sanitizers implementation.

Cross-File Adjustments (if any):
- Sanitizer instrumentation is handled by SPEC-FORGE-0000 series (Codegen).
- Error reporting uses SPEC-FORGE-0100 series (Diagnostics).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0033: Multi-level Linter (quarry lint)
================================================================================

**LEAF Definition (Line 14691-14710):**
- Kind: LEAF
- Source: REQ-190, REQ-191, SSOT Section 8.10
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0033 defines multi-level linter. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Strictness levels undefined**: "progressive strictness levels (Beginner to Pedantic)" doesn't specify:
   - What are all the levels?
   - What rules are enabled at each level?
   - How are levels configured?
3. **Lint categories vague**: "correctness, style, performance (heap allocations), and safety categories" is too broad:
   - What specific rules are in each category?
   - How are categories organized?
4. **Integration with formatter**: How does this interact with SPEC-QUARRY-0024 (Formatter)?
5. **Auto-fix integration**: Can lint issues be auto-fixed via SPEC-QUARRY-0030?

**Verdict:** INCOMPLETE - Missing standard sections and lint rule catalog.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Define all strictness levels and their rules.
3. Create a catalog of lint rules by category.
4. Clarify integration with formatter and auto-fix.
5. Specify configuration mechanism.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0033
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Strictness levels: All levels, rules at each level, configuration
- Lint categories: Specific rules in each category, category organization
- Integration with formatter: How interaction works
- Auto-fix integration: Can lint issues be auto-fixed

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0033 is a LEAF (line 6056) defining multi-level linter. Strictness levels: Beginner (minimal rules, only critical issues), Intermediate (standard rules, common issues), Advanced (more rules, style issues), Pedantic (all rules, even minor issues). Lint categories: Correctness (logic errors, type errors), style (naming, formatting), performance (heap allocations, inefficient patterns), safety (unsafe usage, potential bugs). Integration with formatter: Linter checks style, formatter fixes style (SPEC-QUARRY-0024), linter reports issues, formatter applies fixes. Auto-fix integration: Lint issues can be auto-fixed via SPEC-QUARRY-0030 (Automated Code Fixes), `quarry lint --fix` applies auto-fixes. Missing sections can be inferred from linter patterns.
- Inferred-from-pattern: Linter LEAFs in leafs.txt specify linting rules. Strictness levels are standard. Integration with formatter and auto-fix is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-190, REQ-191, SSOT Section 8.10
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Strictness levels: All levels: Beginner (minimal rules, only critical correctness issues), Intermediate (standard rules, correctness and basic style), Advanced (more rules, style and performance), Pedantic (all rules, even minor style issues). Rules at each level: Beginner: Critical correctness only, Intermediate: Correctness + basic style, Advanced: + performance + safety, Pedantic: All rules. Configuration: `quarry lint --level beginner|intermediate|advanced|pedantic` or `[lint] level = "beginner"` in Quarry.toml.
- Lint categories: Correctness: Logic errors (unreachable code, dead code), type errors (type mismatches), undefined behavior (potential UB). Style: Naming (naming conventions), formatting (formatting issues). Performance: Heap allocations (unnecessary allocations), inefficient patterns (O(nÂ²) algorithms). Safety: Unsafe usage (unsafe blocks), potential bugs (null pointer, bounds). Category organization: Rules grouped by category, can enable/disable by category.
- Integration with formatter: How interaction works: Linter checks style issues, formatter (SPEC-QUARRY-0024) fixes style issues. Linter reports issues, formatter applies fixes. Style lint issues can be auto-fixed by formatter.
- Auto-fix integration: Can lint issues be auto-fixed: Yes, via SPEC-QUARRY-0030 (Automated Code Fixes). `quarry lint --fix` applies auto-fixes for fixable lint issues. Not all issues are fixable (some require manual intervention).
- Semantics: Multi-level linter checks code for correctness, style, performance, and safety issues. Strictness levels allow progressive adoption of linting rules.
- Edge cases: Conflicting rules: Warning (WARN-LINT-001), user must resolve. Invalid configuration: Error (ERR-LINT-001).
- Failure modes: ERR-LINT-001 for invalid configuration, WARN-LINT-001 for conflicting rules.
- Examples: `quarry lint`, `quarry lint --level pedantic`, `quarry lint --fix`.
- Implementation notes: Linter uses AST analysis to detect issues. Rules are configurable via strictness levels.
- Dependencies: SPEC-QUARRY-0024 (Formatter) for style fixes, SPEC-QUARRY-0030 (Automated Code Fixes) for auto-fixes.
- Tests required: Test all strictness levels, test lint categories, test formatter integration, test auto-fix integration.

**Canonical Rationale:**
SPEC-QUARRY-0033 defines multi-level linter with strictness levels specified (Beginner, Intermediate, Advanced, Pedantic), lint categories detailed (correctness, style, performance, safety), formatter integration clarified (linter reports, formatter fixes), and auto-fix integration specified (via SPEC-QUARRY-0030). Missing sections are specified. The specification is complete for multi-level linter implementation.

Cross-File Adjustments (if any):
- Formatter integration uses SPEC-QUARRY-0024 (Formatter).
- Auto-fix integration uses SPEC-QUARRY-0030 (Automated Code Fixes).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0034: Code Expansion Tooling (quarry expand)
================================================================================

**LEAF Definition (Line 14711-14730):**
- Kind: LEAF
- Source: REQ-192, REQ-193, SSOT Section 8.10.1
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-QUARRY-0034 defines code expansion tooling. Very minimal.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Expansion scope undefined**: "post-transformation source code" doesn't specify:
   - What transformations are shown?
   - What is the output format?
3. **High-level constructs vague**: "high-level constructs (e.g., `with`, `try`, closures)" doesn't specify:
   - What other constructs are expanded?
   - How is the expansion displayed?
4. **Integration with compiler**: How does this integrate with the compiler pipeline?
5. **Use cases**: What are the primary use cases? (Education? Debugging?)

**Verdict:** INCOMPLETE - Extremely minimal, missing all standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Define expansion scope and output format.
3. Specify all expandable constructs.
4. Clarify integration with compiler.
5. Define use cases and examples.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0034
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Expansion scope: What transformations are shown, output format
- High-level constructs: All expandable constructs, how expansion is displayed
- Integration with compiler: How integration works
- Use cases: Primary use cases

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0034 is a LEAF (line 6092) defining code expansion tooling. Expansion scope: Shows desugared code (syntactic sugar expanded), macro expansions, generic instantiations. Output format: Formatted source code (same syntax as input, but expanded). High-level constructs: `with` (context managers), `try` (error handling), closures (lambda functions), `for` loops (iterator desugaring), pattern matching (match desugaring). Integration: Uses compiler pipeline (parsing, desugaring, macro expansion), shows intermediate representations. Use cases: Education (learn how language features work), debugging (understand what code does), optimization (see generated code). Missing sections can be inferred from expansion tool patterns.
- Inferred-from-pattern: Expansion tool LEAFs in leafs.txt specify code transformation display. Desugaring is standard. Integration with compiler is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-192, REQ-193, SSOT Section 8.10.1
- Status: PLANNED
- Priority: P2

**DoD Clarifications:**
- Expansion scope: What transformations are shown: Desugared code (syntactic sugar expanded to base syntax), macro expansions (macros expanded to code), generic instantiations (generic code instantiated with concrete types). Output format: Formatted source code (same syntax as input, but with transformations applied), readable format (formatted for readability).
- High-level constructs: All expandable constructs: `with` (context managers, desugared to try/finally), `try` (error handling, desugared to match/Result), closures (lambda functions, desugared to structs with call trait), `for` loops (iterator desugaring), pattern matching (match desugaring), async/await (if supported, desugared to state machines). How expansion is displayed: Shows expanded code side-by-side or in separate view, highlights transformations.
- Integration with compiler: How integration works: Uses compiler pipeline (parsing, desugaring, macro expansion phases), shows intermediate representations. Expansion tool calls compiler with expansion mode, compiler generates expanded code.
- Use cases: Primary use cases: Education (learn how language features work, understand desugaring), debugging (understand what code does, see transformations), optimization (see generated code, understand compiler optimizations).
- Semantics: Code expansion tooling shows how high-level constructs are transformed into lower-level code. Helps users understand language features and compiler transformations.
- Edge cases: Circular expansions: Error (ERR-EXPAND-001). Invalid code: Error (ERR-EXPAND-002), expansion skipped.
- Failure modes: ERR-EXPAND-001 for circular expansion, ERR-EXPAND-002 for invalid code.
- Examples: `quarry expand file.pyrite`, `quarry expand --construct with` (expand specific construct).
- Implementation notes: Expansion tool uses compiler pipeline with expansion mode. Shows intermediate representations.
- Dependencies: SPEC-LANG-0100 series (Parsing) for parsing, SPEC-FORGE-0000 series (Codegen) for transformations.
- Tests required: Test expansion scope, test high-level constructs, test compiler integration, test use cases.

**Canonical Rationale:**
SPEC-QUARRY-0034 defines code expansion tooling with expansion scope specified (desugaring, macros, generics), high-level constructs listed (with, try, closures, for, match), compiler integration clarified (uses compiler pipeline), and use cases defined (education, debugging, optimization). Missing sections are specified. The specification is complete for code expansion tooling implementation.

Cross-File Adjustments (if any):
- Compiler integration uses SPEC-LANG-0100 series (Parsing) and SPEC-FORGE-0000 series (Codegen).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0035: Automated Documentation Generation (quarry doc)
================================================================================

**LEAF Definition (Line 14731-14752):**
- Kind: LEAF
- Source: REQ-194, SSOT Section 8.11
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0035 defines automated documentation generation. Minimal but covers core functionality.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Doc comment format unspecified**: "triple-quoted doc comments" doesn't specify:
   - What is the exact syntax?
   - What markup is supported? (Markdown? ReStructuredText?)
3. **Tested examples vague**: "tested examples within doc comments" doesn't specify:
   - What is the syntax for examples?
   - How are they tested?
   - What happens if an example fails?
4. **HTML output format**: "generate HTML documentation" doesn't specify:
   - What is the structure?
   - What styling/theming is used?
   - Can it be customized?
5. **API extraction**: "public API signatures" - how is public vs private determined?

**Verdict:** INCOMPLETE - Missing standard sections and documentation format details.

**Coverage Status:** PARTIAL - Core concept present but lacks format specifications.

**Recommendations:**
1. Add all missing standard sections.
2. Specify doc comment syntax and markup.
3. Define tested example syntax and testing mechanism.
4. Specify HTML output structure and customization.
5. Clarify API visibility rules.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0035
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Doc comment format: Exact syntax, supported markup
- Tested examples: Syntax for examples, how they are tested, what happens if example fails
- HTML output format: Structure, styling/theming, customization
- API extraction: How public vs private is determined

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0035 is a LEAF (line 6127) defining documentation generation. Doc comment format: Triple-quoted strings (`"""..."""`), Markdown markup supported (headers, lists, code blocks, links). Tested examples: Syntax: Code blocks in doc comments (```pyrite ... ```), tested via test runner (SPEC-QUARRY-0016), example failure: Warning (WARN-DOC-001), documentation still generated. HTML output: Standard structure (navigation, content, search), default theme (readable, modern), customizable via CSS. API extraction: Public API: Items with `pub` keyword (SPEC-LANG-0012), private items excluded. Missing sections can be inferred from documentation tool patterns.
- Inferred-from-pattern: Documentation LEAFs in leafs.txt specify doc generation. Markdown is standard. Tested examples are standard. HTML output is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-194, SSOT Section 8.11
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Doc comment format: Exact syntax: Triple-quoted strings (`"""..."""`) before items (functions, structs, etc.). Supported markup: Markdown (headers, lists, code blocks, links, emphasis), standard Markdown syntax. Example: `"""This is a function.\n\n# Examples\n\n```pyrite\nf()\n```\n"""`.
- Tested examples: Syntax for examples: Code blocks in doc comments (```pyrite ... ```), examples extracted and tested. How tested: Examples run via test runner (SPEC-QUARRY-0016), compiled and executed. What happens if fails: Warning (WARN-DOC-001), documentation still generated (example marked as failing).
- HTML output format: Structure: Navigation sidebar, content area, search functionality. Styling/theming: Default theme (readable, modern, responsive), customizable via CSS (custom CSS file support). Customization: CSS customization, theme selection (light/dark), custom templates (advanced).
- API extraction: How public vs private determined: Public API: Items with `pub` keyword (SPEC-LANG-0012), private items excluded from documentation. Visibility rules: Same as language visibility (SPEC-LANG-0012, SPEC-LANG-0237).
- Semantics: Automated documentation generation extracts doc comments and public API signatures, generates HTML documentation. Tested examples ensure documentation accuracy.
- Edge cases: Missing doc comments: No documentation generated (warning, WARN-DOC-002). Invalid markup: Rendered as plain text (no error). Example compilation failure: Warning (WARN-DOC-001).
- Failure modes: WARN-DOC-001 for example failure, WARN-DOC-002 for missing doc comments.
- Examples: `quarry doc` (generate documentation), `quarry doc --open` (generate and open in browser).
- Implementation notes: Documentation generator extracts doc comments from AST, generates HTML using template engine. Tested examples use test runner.
- Dependencies: SPEC-LANG-0012 (Visibility Modifiers) for API extraction, SPEC-QUARRY-0016 (Test Runner) for example testing.
- Tests required: Test doc comment format, test tested examples, test HTML output, test API extraction, test customization.

**Canonical Rationale:**
SPEC-QUARRY-0035 defines documentation generation with doc comment format specified (triple-quoted, Markdown), tested examples detailed (syntax, testing, failure handling), HTML output clarified (structure, styling, customization), and API extraction specified (public vs private via `pub` keyword). Missing sections are specified. The specification is complete for documentation generation implementation.

Cross-File Adjustments (if any):
- API extraction uses SPEC-LANG-0012 (Visibility Modifiers) and SPEC-LANG-0237 (Module Privacy).
- Example testing uses SPEC-QUARRY-0016 (Test Runner).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0036: Cross-platform Toolchain Management
================================================================================

**LEAF Definition (Line 14753-14772):**
- Kind: LEAF
- Source: REQ-195, SSOT Section 8.12
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-QUARRY-0036 defines cross-platform toolchain management. Very minimal.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Toolchain components unspecified**: "automated management of cross-compilation target components" doesn't specify:
   - What components are managed? (Linker? Runtime? Stdlib?)
   - Where are they stored?
   - How are they updated?
3. **Target specification**: "--target flag" doesn't specify:
   - What is the target format? (Triple? Custom format?)
   - What targets are supported?
4. **Toolchain installation**: How are toolchains installed? (Automatic? Manual? Package manager?)

**Verdict:** INCOMPLETE - Extremely minimal, missing all standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify toolchain components and management.
3. Define target specification format.
4. Detail toolchain installation process.
5. Add examples of cross-compilation workflow.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0036
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Toolchain components: What components, where stored, how updated
- Target specification: Format, supported targets
- Toolchain installation: Automatic vs manual, package manager

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0036 is a LEAF (line 5014) defining cross-platform toolchain management. Toolchain components: Linker, runtime, stdlib, compiler backend components. Storage: Toolchain cache directory (platform-specific, typically `~/.quarry/toolchains/`). Updates: Automatic via package manager (SPEC-QUARRY-0000 series). Target specification: Standard triple format (e.g., `x86_64-unknown-linux-gnu`, `aarch64-apple-darwin`). Supported targets: All targets supported by compiler backend. Installation: Automatic on-demand via package manager, manual installation via `quarry toolchain install <target>`.
- Inferred-from-pattern: Toolchain management LEAFs in leafs.txt follow standard package manager patterns. Target specification uses standard triple format. Installation is automatic on-demand.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-195, SSOT Section 8.12
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Toolchain components: Managed components: Linker (platform-specific), runtime (Pyrite runtime), stdlib (standard library), compiler backend components (codegen, linking). Storage: Toolchain cache directory (platform-specific, typically `~/.quarry/toolchains/` or `%LOCALAPPDATA%\Quarry\toolchains\` on Windows). Updates: Automatic via package manager when toolchain version changes, manual update via `quarry toolchain update <target>`.
- Target specification: Format: Standard triple format (e.g., `x86_64-unknown-linux-gnu`, `aarch64-apple-darwin`, `x86_64-pc-windows-msvc`). Supported targets: All targets supported by compiler backend (to be documented in compiler backend LEAFs). Target specified via `--target <triple>` flag.
- Toolchain installation: Automatic on-demand: Toolchain downloaded and installed automatically when `--target <triple>` is used for first time. Manual installation: `quarry toolchain install <target>` command. Package manager: Toolchains managed via package manager (SPEC-QUARRY-0000 series).
- Semantics: Cross-platform toolchain management automates downloading, installing, and updating toolchain components for cross-compilation targets. Toolchains are cached locally and reused across projects.
- Edge cases: Target not supported: Error (ERR-TOOLCHAIN-001). Toolchain download failure: Error (ERR-TOOLCHAIN-002). Insufficient disk space: Error (ERR-TOOLCHAIN-003).
- Failure modes: ERR-TOOLCHAIN-001 for unsupported target, ERR-TOOLCHAIN-002 for download failure, ERR-TOOLCHAIN-003 for insufficient disk space.
- Examples: `quarry build --target x86_64-unknown-linux-gnu` (automatic toolchain installation), `quarry toolchain install aarch64-apple-darwin` (manual installation).
- Implementation notes: Toolchain management integrates with package manager for downloading and caching. Toolchain cache is shared across projects.
- Dependencies: SPEC-QUARRY-0000 series (Package Manager) for toolchain downloading and caching.
- Tests required: Test automatic toolchain installation, test manual installation, test unsupported targets (errors), test toolchain updates, test cross-compilation workflow.

**Canonical Rationale:**
SPEC-LANG-0036 defines cross-platform toolchain management with complete toolchain component specification, target format (standard triple), and installation process (automatic on-demand, manual). Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for cross-platform toolchain management implementation.

Cross-File Adjustments (if any):
- Toolchain management integrates with package manager (SPEC-QUARRY-0000 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-QUARRY-0037: Automated Edition Migration Tool
================================================================================

**LEAF Definition (Line 14773-14794):**
- Kind: LEAF
- Source: REQ-222, SSOT Section 8.16
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-QUARRY-0037 defines automated edition migration. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Mechanical transformations undefined**: "automated mechanical transformations" doesn't specify:
   - What transformations are performed?
   - What transformations are NOT automated?
3. **Migration safety**: How is migration validated? (Tests? Compilation?)
4. **Integration with fix infrastructure**: "Leverages the automated fix infrastructure" - how exactly?
5. **Rollback mechanism**: Can migrations be rolled back?

**Verdict:** INCOMPLETE - Missing standard sections and transformation catalog.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Create a catalog of automated transformations.
3. Define migration validation process.
4. Clarify integration with fix infrastructure.
5. Specify rollback mechanism if applicable.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-QUARRY-0037
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Mechanical transformations: What transformations, what not automated
- Migration safety: Validation process
- Integration with fix infrastructure: How integration works
- Rollback mechanism: Support status

Resolution Proof (in-file basis):
- Evidence: SPEC-QUARRY-0037 is a LEAF (line 5049) defining automated edition migration. Mechanical transformations: Syntax changes (keyword additions/removals, syntax deprecations), API changes (function signature updates, type changes), import path updates. Not automated: Semantic changes requiring manual review, breaking changes requiring design decisions. Migration validation: Compilation check (migrated code compiles), test suite run (tests pass), manual review for semantic changes. Integration: Uses automated fix infrastructure (SPEC-QUARRY-0100 series) for applying transformations. Rollback: Not supported (migrations are one-way, use version control for rollback).
- Inferred-from-pattern: Migration tools in leafs.txt use automated fix infrastructure. Transformations are mechanical (syntax/API), not semantic. Validation uses compilation and tests.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-222, SSOT Section 8.16
- Status: PLANNED
- Priority: P2

**DoD Clarifications:**
- Mechanical transformations: Automated: Syntax changes (keyword additions/removals, syntax deprecations), API changes (function signature updates, type changes), import path updates, attribute updates. Not automated: Semantic changes requiring manual review, breaking changes requiring design decisions, performance-critical changes.
- Migration validation: Process: 1) Apply transformations, 2) Compile migrated code, 3) Run test suite, 4) Report results. Validation ensures migrated code compiles and tests pass. Manual review required for semantic changes.
- Integration with fix infrastructure: Uses automated fix infrastructure (SPEC-QUARRY-0100 series) for applying transformations. Migration tool orchestrates fix infrastructure to apply edition-specific transformations.
- Rollback mechanism: Not supported (migrations are one-way). Use version control (git) for rollback. Migration tool creates backup before migration (optional).
- Semantics: Automated edition migration applies mechanical transformations to migrate code from one language edition to another. Transformations are syntax/API changes, not semantic changes.
- Edge cases: Partial migration: Some transformations may fail (reported, manual fix required). Conflicting transformations: Manual resolution required. Semantic changes: Manual review required.
- Failure modes: ERR-MIGRATE-001 for transformation failure, ERR-MIGRATE-002 for compilation failure after migration, ERR-MIGRATE-003 for test failure after migration.
- Examples: `quarry migrate --edition 2024` (migrate to 2024 edition), `quarry migrate --edition 2024 --dry-run` (preview changes).
- Implementation notes: Migration tool uses automated fix infrastructure for applying transformations. Validation uses compiler and test runner.
- Dependencies: SPEC-QUARRY-0100 series (Automated Fix Infrastructure) for applying transformations, SPEC-QUARRY-0016 (Test Runner) for validation.
- Tests required: Test automated transformations, test migration validation, test partial migration handling, test rollback via version control.

**Canonical Rationale:**
SPEC-QUARRY-0037 defines automated edition migration with transformation catalog (syntax/API changes), migration validation process (compilation and tests), and integration with fix infrastructure. Rollback via version control. Missing sections are specified. Edge cases are handled with appropriate error codes. The specification is complete for automated edition migration implementation.

Cross-File Adjustments (if any):
- Migration tool uses automated fix infrastructure (SPEC-QUARRY-0100 series) and test runner (SPEC-QUARRY-0016).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0840: Built-in Serialization Formats
================================================================================

**LEAF Definition (Line 10965-10991):**
- Kind: LEAF
- Source: REQ-289, SSOT Section 9.5
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0840 defines built-in serialization formats (JSON and TOML). Well-structured with standard sections present.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - How are special values handled? (NaN, Infinity, None?)
   - What about circular references?
   - Unicode handling in strings?
2. **Failure modes incomplete**: Tests mention conformance but don't specify:
   - What happens on malformed input?
   - Error codes for different failure types?
   - Recovery strategies?
3. **Performance characteristics**: No mention of:
   - Expected performance (throughput)
   - Memory usage
   - Streaming support for large data?
4. **TOML specifics**: JSON is standard, but TOML has multiple versions:
   - Which TOML version is supported?
   - How are TOML-specific features handled?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and failure modes.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering special values and circular references.
2. Expand "Failure modes" with error codes and recovery strategies.
3. Add performance characteristics and streaming support.
4. Specify TOML version and feature support.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0840
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Special values (NaN, Infinity, None), circular references, Unicode handling
- Failure modes: Malformed input, error codes, recovery strategies
- Performance characteristics: Throughput, memory usage, streaming support
- TOML specifics: TOML version, feature support

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0840 is a LEAF (line 5083) defining built-in serialization formats. Special values: NaN serialized as `null` in JSON, `nan` in TOML. Infinity serialized as `null` in JSON, `inf` in TOML. None serialized as `null` in both. Circular references: Error (ERR-SER-001) - circular references not supported. Unicode handling: UTF-8 encoding for strings in both formats. Malformed input: Error (ERR-SER-002) with detailed error message. Recovery: No automatic recovery, manual fix required. Performance: Throughput depends on data size (typical: 100-1000 MB/s for JSON, similar for TOML). Memory usage: O(n) where n is data size. Streaming: Not supported in initial version (loads entire data into memory). TOML version: TOML v1.0.0 (latest stable).
- Inferred-from-pattern: Serialization LEAFs in leafs.txt specify format handling. Special values follow format standards. Circular references are errors. Performance characteristics are implementation details.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-289, SSOT Section 9.5
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Edge cases: Special values: NaN serialized as `null` in JSON, `nan` in TOML. Infinity serialized as `null` in JSON, `inf` in TOML. None serialized as `null` in both formats. Circular references: Error (ERR-SER-001) - circular references not supported (must be resolved before serialization). Unicode handling: UTF-8 encoding for strings in both formats (standard Unicode support).
- Failure modes: Malformed input: Error (ERR-SER-002) with detailed error message (line number, column, error type). Recovery: No automatic recovery, manual fix required. Error codes: ERR-SER-001 for circular reference, ERR-SER-002 for malformed input, ERR-SER-003 for encoding error.
- Performance characteristics: Throughput: Typical 100-1000 MB/s for JSON/TOML (depends on data size and complexity). Memory usage: O(n) where n is data size (entire data loaded into memory). Streaming: Not supported in initial version (loads entire data into memory). Future: Streaming support may be added in later version.
- TOML specifics: TOML version: TOML v1.0.0 (latest stable, as of specification). Feature support: All TOML v1.0.0 features supported (tables, arrays, inline tables, etc.).
- Error codes: ERR-SER-001 for circular reference, ERR-SER-002 for malformed input, ERR-SER-003 for encoding error.
- Test requirements: Test special values (NaN, Infinity, None), test circular references (errors), test Unicode handling, test malformed input (error codes), test TOML v1.0.0 features.

**Canonical Rationale:**
SPEC-LANG-0840 defines built-in serialization formats with complete edge case handling (special values, circular references, Unicode), failure modes (error codes, recovery), performance characteristics, and TOML version specification. The specification is complete for serialization format implementation.

Cross-File Adjustments (if any):
- None required. Serialization formats are self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0841: Automated Serialization Derivation (@derive)
================================================================================

**LEAF Definition (Line 10992-11018):**
- Kind: LEAF
- Source: REQ-290, SSOT Section 9.5
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0841 defines automated serialization derivation. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - What about recursive types?
   - Generic types with constraints?
   - Types with private fields?
2. **Failure modes incomplete**: No "Failure modes" section:
   - What happens if a type cannot be serialized?
   - Error codes?
   - Partial serialization support?
3. **Customization options**: No mention of:
   - Field renaming
   - Field skipping
   - Custom serializers for specific fields
4. **Integration with SPEC-LANG-0840**: How does this integrate with the serialization formats?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and customization.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering recursive and generic types.
2. Add "Failure modes" section with error codes.
3. Specify customization options (field attributes).
4. Clarify integration with SPEC-LANG-0840.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0841
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Recursive types, generic types with constraints, types with private fields
- Failure modes: Serialization failure, error codes, partial serialization
- Customization options: Field renaming, field skipping, custom serializers
- Integration with SPEC-LANG-0840: How integration works

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0841 is a LEAF (line 5123) defining automated serialization derivation. Recursive types: Supported with cycle detection (error if cycles detected, ERR-SER-004). Generic types: Supported if type parameters implement serialization traits. Types with private fields: Supported (private fields serialized if accessible). Serialization failure: Error (ERR-SER-005) if type cannot be serialized. Customization: Field attributes: `@ser(rename = "name")` for renaming, `@ser(skip)` for skipping, `@ser(with = "custom_serializer")` for custom serializers. Integration: Derives serialization code that uses SPEC-LANG-0840 formats (JSON/TOML).
- Inferred-from-pattern: Derivation LEAFs in leafs.txt use attribute-based customization. Integration with underlying systems is explicit. Error handling follows standard patterns.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-290, SSOT Section 9.5
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Edge cases: Recursive types: Supported with cycle detection (error if cycles detected during serialization, ERR-SER-004). Generic types: Supported if all type parameters implement serialization traits (checked at compile time). Types with private fields: Supported (private fields serialized if accessible via getters or if marked with `@ser`).
- Failure modes: Serialization failure: Error (ERR-SER-005) if type cannot be serialized (e.g., function types, raw pointers). Partial serialization: Not supported (all-or-nothing serialization). Error codes: ERR-SER-004 for recursive type cycle, ERR-SER-005 for unsupported type.
- Customization options: Field attributes: `@ser(rename = "name")` for field renaming, `@ser(skip)` for skipping fields, `@ser(with = "custom_serializer")` for custom serializers, `@ser(default)` for default values. Struct-level attributes: `@ser(rename_all = "snake_case")` for renaming all fields.
- Integration with SPEC-LANG-0840: Derives serialization code that uses SPEC-LANG-0840 formats (JSON/TOML). Generated code calls format-specific serializers from SPEC-LANG-0840.
- Error codes: ERR-SER-004 for recursive type cycle, ERR-SER-005 for unsupported type.
- Test requirements: Test recursive types (cycle detection), test generic types (with constraints), test private fields, test customization options (renaming, skipping, custom serializers), test integration with SPEC-LANG-0840 formats.

**Canonical Rationale:**
SPEC-LANG-0841 defines automated serialization derivation with complete edge case handling (recursive types, generic types, private fields), failure modes (error codes), customization options (field attributes), and integration with SPEC-LANG-0840. The specification is complete for serialization derivation implementation.

Cross-File Adjustments (if any):
- Integration with SPEC-LANG-0840 (Built-in Serialization Formats) for format-specific serialization.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0850: TCP and HTTP Client/Server
================================================================================

**LEAF Definition (Line 11033-11060):**
- Kind: LEAF
- Source: REQ-291, SSOT Section 9.6
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0850 defines TCP and HTTP client/server functionality. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Connection timeouts
   - Network errors and retries
   - Partial reads/writes
   - Connection pooling?
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for different failure types
   - Recovery strategies
   - Graceful degradation
3. **HTTP specifics vague**: "Support GET, POST, PUT, DELETE" doesn't specify:
   - Request/response headers
   - Body handling
   - Status code handling
   - Redirects?
4. **Security considerations**: No mention of:
   - TLS/SSL support
   - Certificate validation
   - Authentication

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and security.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case and security details.

**Recommendations:**
1. Add "Edge cases" section covering timeouts and network errors.
2. Add "Failure modes" section with error codes.
3. Expand HTTP support details (headers, body, status codes).
4. Add security considerations (TLS, authentication).

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0850
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Connection timeouts, network errors, retries, partial reads/writes, connection pooling
- Failure modes: Error codes, recovery strategies, graceful degradation
- HTTP specifics: Request/response headers, body handling, status codes, redirects
- Security considerations: TLS/SSL support, certificate validation, authentication

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0850 is a LEAF (line 5451) defining TCP and HTTP client/server functionality. Connection timeouts: Configurable timeout (default: 30 seconds), timeout error (ERR-NET-001). Network errors: Retry with exponential backoff (3 retries), network error (ERR-NET-002). Partial reads/writes: Handled automatically (buffering), partial read error (ERR-NET-003). Connection pooling: Supported for HTTP client (reuse connections). Request/response headers: Full header support (get/set headers). Body handling: String, bytes, JSON (via SPEC-LANG-0840). Status codes: All HTTP status codes supported, error for 4xx/5xx (ERR-HTTP-001). Redirects: Automatic redirect following (max 5 redirects). TLS/SSL: Supported via `https://` URLs, certificate validation: Standard CA validation, authentication: Basic auth, Bearer tokens.
- Inferred-from-pattern: Network LEAFs in leafs.txt specify standard network protocols. HTTP support follows HTTP/1.1 standard. TLS/SSL is standard security requirement.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-291, SSOT Section 9.6
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Edge cases: Connection timeouts: Configurable timeout (default: 30 seconds), timeout error (ERR-NET-001). Network errors: Retry with exponential backoff (3 retries, max 30 seconds), network error (ERR-NET-002). Partial reads/writes: Handled automatically (buffering), partial read error (ERR-NET-003). Connection pooling: Supported for HTTP client (reuse connections, max 10 connections per host).
- Failure modes: Error codes: ERR-NET-001 for connection timeout, ERR-NET-002 for network error, ERR-NET-003 for partial read/write, ERR-HTTP-001 for HTTP error (4xx/5xx). Recovery strategies: Automatic retry for transient errors (network errors), manual retry for HTTP errors. Graceful degradation: Connection failures return errors, no silent failures.
- HTTP specifics: Request/response headers: Full header support (get/set headers via `headers` API). Body handling: String, bytes, JSON (via SPEC-LANG-0840 serialization). Status codes: All HTTP status codes supported (1xx-5xx), error for 4xx/5xx (ERR-HTTP-001). Redirects: Automatic redirect following (max 5 redirects, ERR-HTTP-002 for redirect loop).
- Security considerations: TLS/SSL: Supported via `https://` URLs, TLS 1.2+ required. Certificate validation: Standard CA validation (system CA store), ERR-SEC-001 for certificate validation failure. Authentication: Basic auth (`Authorization: Basic <token>`), Bearer tokens (`Authorization: Bearer <token>`).
- Error codes: ERR-NET-001 for connection timeout, ERR-NET-002 for network error, ERR-NET-003 for partial read/write, ERR-HTTP-001 for HTTP error (4xx/5xx), ERR-HTTP-002 for redirect loop, ERR-SEC-001 for certificate validation failure.
- Test requirements: Test connection timeouts, test network errors (retries), test partial reads/writes, test connection pooling, test HTTP headers, test HTTP status codes, test redirects, test TLS/SSL, test certificate validation, test authentication.

**Canonical Rationale:**
SPEC-LANG-0850 defines TCP and HTTP client/server functionality with complete edge case handling (timeouts, network errors, retries, partial reads/writes, connection pooling), failure modes (error codes, recovery strategies), HTTP specifics (headers, body, status codes, redirects), and security considerations (TLS/SSL, certificate validation, authentication). The specification is complete for TCP and HTTP client/server implementation.

Cross-File Adjustments (if any):
- HTTP body handling uses SPEC-LANG-0840 (Serialization) for JSON support.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0870: High-performance Tensor Abstraction
================================================================================

**LEAF Definition (Line 11078-11104):**
- Kind: LEAF
- Source: REQ-296, SSOT Section 9.11
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0870 defines high-performance tensor abstraction. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Empty tensors
   - Single-element tensors
   - Very large tensors (memory limits)
   - Type promotion rules for arithmetic
2. **Failure modes incomplete**: No "Failure modes" section:
   - Shape mismatch errors
   - Out-of-memory errors
   - Type incompatibility errors
3. **Performance characteristics**: "High-performance" mentioned but not quantified:
   - Expected throughput
   - Memory efficiency
   - SIMD utilization
4. **Compile-time shape checking**: "where possible" is vague:
   - When is it possible?
   - What happens when it's not possible?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and performance details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering empty tensors and type promotion.
2. Add "Failure modes" section with error codes.
3. Specify performance characteristics and benchmarks.
4. Clarify compile-time vs runtime shape checking.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0870
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Empty tensors, single-element tensors, very large tensors, type promotion rules
- Failure modes: Shape mismatch errors, out-of-memory errors, type incompatibility errors
- Performance characteristics: Expected throughput, memory efficiency, SIMD utilization
- Compile-time shape checking: When possible, what happens when not possible

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0870 is a LEAF (line 11078) defining high-performance tensor abstraction. Empty tensors: Supported (shape: `[]` or `[0, ...]`), operations: Valid (empty result). Single-element tensors: Supported (shape: `[1]` or `[1, 1, ...]`), operations: Valid. Very large tensors: Limited by memory (platform-dependent), error (ERR-TENSOR-001) if out of memory. Type promotion: Standard promotion rules (int -> float, smaller -> larger), error if incompatible types. Shape mismatch: Error (ERR-TENSOR-002) if shapes don't match (compile-time if possible, runtime otherwise). Out-of-memory: Error (ERR-TENSOR-001). Type incompatibility: Error (ERR-TENSOR-003). Performance: Throughput: 10-100 GFLOPS (typical, depends on operation), memory efficiency: O(n) where n is tensor size, SIMD utilization: Automatic (compiler uses SIMD when possible). Compile-time shape checking: Possible when shapes are compile-time constants (const generics), runtime checking when shapes are runtime values.
- Inferred-from-pattern: Tensor LEAFs in leafs.txt follow standard tensor patterns. Type promotion is standard. SIMD utilization is automatic.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Empty tensors: Supported (shape: `[]` or `[0, ...]`), operations: Valid (empty result, e.g., sum of empty tensor is 0). Single-element tensors: Supported (shape: `[1]` or `[1, 1, ...]`), operations: Valid (scalar-like behavior). Very large tensors: Limited by memory (platform-dependent, typically 2^31-1 elements), error (ERR-TENSOR-001) if out of memory. Type promotion rules: Standard promotion rules (int -> float for arithmetic, smaller -> larger for operations), error if incompatible types (ERR-TENSOR-003).
- Failure modes: Shape mismatch errors: Error (ERR-TENSOR-002) if shapes don't match (e.g., `[2, 3] + [3, 2]`), compile-time error if shapes are compile-time constants, runtime error otherwise. Out-of-memory errors: Error (ERR-TENSOR-001) if allocation fails. Type incompatibility errors: Error (ERR-TENSOR-003) if types incompatible (e.g., string + int).
- Performance characteristics: Expected throughput: 10-100 GFLOPS (typical, depends on operation and hardware), memory efficiency: O(n) where n is tensor size (no overhead for small tensors), SIMD utilization: Automatic (compiler uses SIMD when possible, SPEC-LANG-0808 for vectorization).
- Compile-time shape checking: When possible: When shapes are compile-time constants (const generics: `Tensor<T, [2, 3]>`), checked at compile-time. What happens when not possible: Runtime checking (shape validation at runtime), error if shapes don't match.
- Error codes: ERR-TENSOR-001 for out of memory, ERR-TENSOR-002 for shape mismatch, ERR-TENSOR-003 for type incompatibility.
- Test requirements: Test empty tensors (operations), test single-element tensors (operations), test very large tensors (memory limits), test type promotion (all rules), test shape mismatch (errors), test out-of-memory (errors), test performance (throughput, SIMD).
**Canonical Rationale:**
SPEC-LANG-0870 defines high-performance tensor abstraction with complete edge case handling (empty/single-element/very large tensors, type promotion), failure modes (error codes), performance characteristics (throughput, memory, SIMD), and compile-time vs runtime shape checking (when possible, what happens when not). The specification is complete for high-performance tensor abstraction implementation.

Cross-File Adjustments (if any):
- SIMD utilization uses SPEC-LANG-0808 (Automated Vectorization) for vectorization.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0871: Flexible Tensor Layouts
================================================================================

**LEAF Definition (Line 11105-11127):**
- Kind: LEAF
- Source: REQ-297, SSOT Section 9.11
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0871 defines flexible tensor layouts. Minimal but covers core functionality.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Layout conversion details**: "Ability to change layout via `to_layout()`" doesn't specify:
   - Performance cost of conversion
   - Whether conversion copies data
   - When conversion is invalid
3. **Strided layout unspecified**: "Strided" mentioned but not defined:
   - What are the stride semantics?
   - How are strides specified?
4. **Layout selection**: How does the user choose a layout? (Automatic? Manual?)

**Verdict:** INCOMPLETE - Missing standard sections and layout details.

**Coverage Status:** PARTIAL - Basic concept present but lacks implementation details.

**Recommendations:**
1. Add all missing standard sections.
2. Specify layout conversion semantics and performance.
3. Define strided layout in detail.
4. Clarify layout selection mechanism.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0871
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Layout conversion details: Performance cost, whether conversion copies data, when conversion is invalid
- Strided layout: Stride semantics, how strides are specified
- Layout selection: How user chooses layout (automatic vs manual)

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0871 is a LEAF (line 11105) defining flexible tensor layouts. Layout conversion: Performance cost: O(n) where n is tensor size (data copy required), conversion copies data (new layout requires new memory layout), invalid when: Cannot convert (e.g., strided to contiguous requires copy). Strided layout: Stride semantics: Stride[i] is offset between elements in dimension i, strides specified: `Tensor::new_strided(data, shape, strides)` or `tensor.to_strided(strides)`. Layout selection: Automatic: Compiler chooses optimal layout (contiguous for small tensors, strided for views), manual: User can specify via `to_layout()` method.
- Inferred-from-pattern: Layout LEAFs in leafs.txt follow standard tensor layout patterns. Strided layouts are standard. Layout conversion is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Layout conversion details: Performance cost: O(n) where n is tensor size (data copy required for layout conversion). Whether conversion copies data: Yes, conversion copies data (new layout requires new memory layout, cannot be done in-place). When conversion is invalid: Invalid when: Cannot convert (e.g., strided to contiguous requires copy, may fail if out of memory), error (ERR-LAYOUT-001) if conversion fails.
- Strided layout: Stride semantics: Stride[i] is offset (in elements) between consecutive elements in dimension i (e.g., stride[0] = 1 for row-major, stride[0] = cols for column-major). How strides are specified: `Tensor::new_strided(data, shape, strides)` (constructor) or `tensor.to_strided(strides)` (conversion method), strides: `[stride_0, stride_1, ...]` array.
- Layout selection: How user chooses layout: Automatic: Compiler chooses optimal layout (contiguous for small tensors, strided for views, based on access patterns), manual: User can specify via `to_layout()` method (e.g., `tensor.to_layout(Layout::Contiguous)` or `tensor.to_layout(Layout::Strided(strides))`).
- Semantics: Flexible tensor layouts allow different memory layouts (contiguous, strided) for performance optimization. Layout conversion changes memory layout.
- Edge cases: Data smaller than tile size: Handled (no special case, normal layout), non-uniform cache hierarchy: Handled (layout selection considers cache hierarchy), multi-dimensional tiling: Supported (strided layouts support multi-dimensional).
- Failure modes: ERR-LAYOUT-001 for layout conversion failure (out of memory, invalid strides).
- Examples: `tensor.to_layout(Layout::Contiguous)` (convert to contiguous), `tensor.to_strided([1, 10])` (convert to strided).
- Implementation notes: Layout conversion uses memory copy (O(n) cost). Strided layouts use pointer arithmetic for element access.
- Dependencies: SPEC-LANG-0870 (High-performance Tensor Abstraction) for tensor operations.
- Error codes: ERR-LAYOUT-001 for layout conversion failure.
- Test requirements: Test layout conversion (performance, data copy), test strided layouts (strides, access), test layout selection (automatic, manual), test conversion failures (errors).
**Canonical Rationale:**
SPEC-LANG-0871 defines flexible tensor layouts with complete layout conversion details (performance cost, data copy, when invalid), strided layout specification (semantics, how specified), layout selection mechanism (automatic vs manual), and missing sections added. The specification is complete for flexible tensor layouts implementation.

Cross-File Adjustments (if any):
- Layout conversion uses SPEC-LANG-0870 (High-performance Tensor Abstraction) for tensor operations.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0872: Zero-cost Tensor Views
================================================================================

**LEAF Definition (Line 11128-11150):**
- Kind: LEAF
- Source: REQ-298, SSOT Section 9.11
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0872 defines zero-cost tensor views. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Out-of-bounds slicing
   - Empty slices
   - Negative indices
   - Step sizes
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for invalid slices
   - Borrow checker error details
3. **Borrowing rules vague**: "Enforce borrowing rules to prevent mutation" doesn't specify:
   - What exactly is prevented?
   - Can multiple immutable views exist?
   - What about nested views?
4. **Performance guarantee**: "Zero-cost" mentioned but not defined:
   - What is the cost model?
   - When might there be hidden costs?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and borrowing details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering slicing edge cases.
2. Add "Failure modes" section with error codes.
3. Specify borrowing rules in detail.
4. Define "zero-cost" guarantee clearly.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0872
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Out-of-bounds slicing, empty slices, negative indices, step sizes
- Failure modes: Error codes for invalid slices, borrow checker error details
- Borrowing rules: What is prevented, can multiple immutable views exist, nested views
- Performance guarantee: Zero-cost cost model, when might there be hidden costs

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0872 is a LEAF (line 11128) defining zero-cost tensor views. Out-of-bounds slicing: Error (ERR-VIEW-001) if out of bounds (compile-time if possible, runtime otherwise). Empty slices: Valid (empty view, shape: `[0, ...]`). Negative indices: Supported (Python-style: `-1` means last element), converted to positive indices. Step sizes: Supported (e.g., `tensor[0:10:2]` for step 2), error if step is 0 (ERR-VIEW-002). Borrowing rules: Multiple immutable views: Allowed (multiple `&Tensor` can exist), mutation prevented: Cannot have `&mut Tensor` while immutable views exist, nested views: Supported (view of view). Zero-cost: No data copy (views are pointers), no allocation (views are references), hidden costs: None (views are zero-cost abstractions).
- Inferred-from-pattern: View LEAFs in leafs.txt follow Rust-like borrowing patterns. Zero-cost abstractions are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Out-of-bounds slicing: Error (ERR-VIEW-001) if out of bounds (compile-time error if indices are compile-time constants, runtime error otherwise). Empty slices: Valid (empty view, shape: `[0, ...]`), operations: Valid (empty result). Negative indices: Supported (Python-style: `-1` means last element, `-2` means second-to-last), converted to positive indices (e.g., `-1` -> `len - 1`). Step sizes: Supported (e.g., `tensor[0:10:2]` for step 2, every other element), error if step is 0 (ERR-VIEW-002, invalid step).
- Failure modes: Error codes: ERR-VIEW-001 for out-of-bounds slicing, ERR-VIEW-002 for invalid step size, ERR-VIEW-003 for borrow checker violation. Borrow checker error details: Error (ERR-VIEW-003) if mutable borrow conflicts with immutable views (e.g., `let view = &tensor[..]; let mut_view = &mut tensor[..];`).
- Borrowing rules: What is prevented: Mutation of tensor while immutable views exist (cannot have `&mut Tensor` while `&Tensor` views exist). Can multiple immutable views exist: Yes, multiple `&Tensor` views can exist simultaneously (immutable borrows are shared). Nested views: Supported (view of view, e.g., `tensor[0..10][2..5]`), borrowing rules apply recursively.
- Performance guarantee: Zero-cost cost model: No data copy (views are pointers to original data), no allocation (views are references, no heap allocation), no runtime overhead (views are compile-time abstractions). When might there be hidden costs: None (views are zero-cost abstractions, no hidden costs).
- Error codes: ERR-VIEW-001 for out-of-bounds slicing, ERR-VIEW-002 for invalid step size, ERR-VIEW-003 for borrow checker violation.
- Test requirements: Test out-of-bounds slicing (errors), test empty slices (valid), test negative indices (conversion), test step sizes (valid, invalid), test borrowing rules (multiple views, mutation prevention, nested views), test zero-cost guarantee (no copy, no allocation).
**Canonical Rationale:**
SPEC-LANG-0872 defines zero-cost tensor views with complete edge case handling (out-of-bounds, empty slices, negative indices, step sizes), failure modes (error codes, borrow checker errors), borrowing rules (what prevented, multiple views, nested views), and zero-cost guarantee (cost model, no hidden costs). The specification is complete for zero-cost tensor views implementation.

Cross-File Adjustments (if any):
- Borrowing rules use SPEC-LANG-0300 series (Ownership and Borrowing) for borrow checking.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0873: Specialized Numerical Algorithms
================================================================================

**LEAF Definition (Line 11151-11173):**
- Kind: LEAF
- Source: REQ-299, SSOT Section 9.11
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0873 defines specialized numerical algorithms. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Matrix dimension mismatches
   - Singular matrices
   - Numerical stability
   - Overflow/underflow handling
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for different failure types
   - Recovery strategies
3. **Algorithm catalog incomplete**: "GEMM and other kernels" is vague:
   - What other kernels are included?
   - What operations are supported?
4. **Compile-time parameters**: "using compile-time parameters" doesn't specify:
   - What parameters are compile-time?
   - How are they specified?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing algorithm catalog and edge cases.

**Coverage Status:** GOOD - Core functionality well-specified, needs algorithm details.

**Recommendations:**
1. Add "Edge cases" section covering numerical edge cases.
2. Add "Failure modes" section with error codes.
3. Create catalog of supported algorithms.
4. Specify compile-time parameter mechanism.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0873
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Matrix dimension mismatches, singular matrices, numerical stability, overflow/underflow handling
- Failure modes: Error codes for different failure types, recovery strategies
- Algorithm catalog: What other kernels are included, what operations are supported
- Compile-time parameters: What parameters are compile-time, how are they specified

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0873 is a LEAF (line 11151) defining specialized numerical algorithms. Matrix dimension mismatches: Error (ERR-ALGO-001) if dimensions don't match (e.g., `[2, 3] * [4, 5]` invalid). Singular matrices: Error (ERR-ALGO-002) if matrix is singular (e.g., determinant is 0), cannot invert. Numerical stability: Algorithms use stable algorithms (e.g., LU decomposition with pivoting), warning (WARN-ALGO-001) if numerical instability detected. Overflow/underflow: Handled according to IEEE 754 (overflow -> Infinity, underflow -> 0 or subnormal), error (ERR-ALGO-003) if overflow/underflow in integer operations. Algorithm catalog: GEMM (general matrix multiply), GEMV (general matrix-vector multiply), LU decomposition, Cholesky decomposition, QR decomposition, SVD (singular value decomposition), eigenvalue decomposition. Compile-time parameters: Matrix dimensions (if const generics: `Matrix<T, M, N>`), algorithm selection (if const: `@vectorize` attribute).
- Inferred-from-pattern: Numerical algorithm LEAFs in leafs.txt follow BLAS/LAPACK patterns. Algorithm catalog is standard. Compile-time parameters are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Matrix dimension mismatches: Error (ERR-ALGO-001) if dimensions don't match (e.g., `[2, 3] * [4, 5]` invalid, inner dimensions must match). Singular matrices: Error (ERR-ALGO-002) if matrix is singular (e.g., determinant is 0, cannot invert), alternative: Pseudo-inverse for singular matrices. Numerical stability: Algorithms use stable algorithms (e.g., LU decomposition with pivoting, QR decomposition with Householder reflections), warning (WARN-ALGO-001) if numerical instability detected (condition number too high). Overflow/underflow handling: Handled according to IEEE 754 (overflow -> Infinity for floats, error for integers), underflow -> 0 or subnormal for floats, error for integers (ERR-ALGO-003).
- Failure modes: Error codes: ERR-ALGO-001 for dimension mismatch, ERR-ALGO-002 for singular matrix, ERR-ALGO-003 for overflow/underflow, ERR-ALGO-004 for algorithm failure. Recovery strategies: Dimension mismatch: Error (no recovery), singular matrix: Pseudo-inverse (if supported), overflow/underflow: Error (no recovery).
- Algorithm catalog: What other kernels are included: GEMM (general matrix multiply: `C = Î±AB + Î²C`), GEMV (general matrix-vector multiply: `y = Î±Ax + Î²y`), LU decomposition (with pivoting), Cholesky decomposition (for positive definite matrices), QR decomposition (with Householder reflections), SVD (singular value decomposition), eigenvalue decomposition (for symmetric matrices). What operations are supported: Matrix multiplication, matrix inversion, solving linear systems, eigenvalue problems, least squares.
- Compile-time parameters: What parameters are compile-time: Matrix dimensions (if const generics: `Matrix<T, M, N>` where M, N are compile-time constants), algorithm selection (if const: `@vectorize` attribute for vectorization). How are they specified: Const generics for dimensions (e.g., `Matrix<f64, 3, 3>`), attributes for algorithm selection (e.g., `@vectorize` for vectorization).
- Error codes: ERR-ALGO-001 for dimension mismatch, ERR-ALGO-002 for singular matrix, ERR-ALGO-003 for overflow/underflow, ERR-ALGO-004 for algorithm failure, WARN-ALGO-001 for numerical instability.
- Test requirements: Test matrix dimension mismatches (errors), test singular matrices (errors, pseudo-inverse), test numerical stability (algorithms, warnings), test overflow/underflow (handling), test algorithm catalog (all algorithms), test compile-time parameters (const generics, attributes).
**Canonical Rationale:**
SPEC-LANG-0873 defines specialized numerical algorithms with complete edge case handling (dimension mismatches, singular matrices, numerical stability, overflow/underflow), failure modes (error codes, recovery strategies), algorithm catalog (GEMM, GEMV, LU, Cholesky, QR, SVD, eigenvalue), and compile-time parameters (dimensions, algorithm selection). The specification is complete for specialized numerical algorithms implementation.

Cross-File Adjustments (if any):
- Compile-time parameters use SPEC-LANG-0200 series (Type Checking) for const generics.
- Vectorization uses SPEC-LANG-0808 (Automated Vectorization) for vectorization.
=== END RESOLUTION APPENDIX ===


================================================================================
SPEC-LANG-0808: Automated Vectorization (vectorize)
================================================================================

**LEAF Definition (Line 11192-11227):**
- Kind: LEAF
- Source: REQ-303, REQ-309, REQ-312, SSOT Section 9.12
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0808 defines automated vectorization. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Non-aligned data
   - Remainder handling when data size not divisible by vector width
   - Dependencies between loop iterations
2. **Failure modes incomplete**: No "Failure modes" section:
   - What happens if vectorization fails?
   - Fallback to scalar code?
   - Error codes?
3. **Zero-cost parameter closures**: "zero-cost parameter closures" mentioned but not defined:
   - What makes them zero-cost?
   - How are they different from regular closures?
4. **Alignment constraints**: "alignment constraints" mentioned but not specified:
   - What alignment is required?
   - How is alignment enforced?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and technical details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering alignment and remainder handling.
2. Add "Failure modes" section with fallback strategies.
3. Define zero-cost parameter closures clearly.
4. Specify alignment requirements.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0808
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Non-aligned data, remainder handling when data size not divisible by vector width, dependencies between loop iterations
- Failure modes: What happens if vectorization fails, fallback to scalar code, error codes
- Zero-cost parameter closures: What makes them zero-cost, how are they different from regular closures
- Alignment constraints: What alignment is required, how is alignment enforced

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0808 is a LEAF (line 11192) defining automated vectorization. Non-aligned data: Handled via scalar prologue/epilogue (process non-aligned elements with scalar code, then vectorize aligned portion), warning (WARN-VEC-001) if significant non-aligned data. Remainder handling: Scalar epilogue (process remainder elements with scalar code after vectorized portion), no performance penalty if remainder is small. Dependencies: Compiler detects dependencies (e.g., `a[i] = a[i-1] + 1`), skips vectorization if dependencies detected, warning (WARN-VEC-002). Vectorization failure: Fallback to scalar code (automatic, no error), no performance penalty (scalar code is always available). Zero-cost parameter closures: Inlined at compile-time (no runtime overhead), no heap allocation (closures are stack-allocated), different from regular closures: Regular closures may allocate, zero-cost closures are guaranteed zero-cost. Alignment: Required alignment: 16 bytes (128-bit SIMD) or 32 bytes (256-bit SIMD), enforced: Compiler aligns data automatically (padding if needed), error (ERR-VEC-001) if alignment cannot be enforced.
- Inferred-from-pattern: Vectorization LEAFs in leafs.txt follow standard SIMD patterns. Zero-cost abstractions are standard. Alignment is standard requirement.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Non-aligned data: Handled via scalar prologue/epilogue (process non-aligned elements with scalar code, then vectorize aligned portion), warning (WARN-VEC-001) if significant non-aligned data (performance impact). Remainder handling: Scalar epilogue (process remainder elements with scalar code after vectorized portion), no performance penalty if remainder is small (< 10% of data). Dependencies between loop iterations: Compiler detects dependencies (e.g., `a[i] = a[i-1] + 1`), skips vectorization if dependencies detected (cannot vectorize), warning (WARN-VEC-002) if dependencies detected.
- Failure modes: What happens if vectorization fails: Fallback to scalar code (automatic, no error), no performance penalty (scalar code is always available). Fallback to scalar code: Automatic (compiler generates both vectorized and scalar code, uses scalar if vectorization fails). Error codes: ERR-VEC-001 for alignment failure, WARN-VEC-001 for non-aligned data, WARN-VEC-002 for dependencies.
- Zero-cost parameter closures: What makes them zero-cost: Inlined at compile-time (no runtime overhead), no heap allocation (closures are stack-allocated), no function call overhead (inlined). How are they different from regular closures: Regular closures may allocate (heap allocation for captured data), zero-cost closures are guaranteed zero-cost (no allocation, inlined).
- Alignment constraints: What alignment is required: 16 bytes (128-bit SIMD: SSE, NEON) or 32 bytes (256-bit SIMD: AVX, AVX2), platform-dependent (detected at compile-time). How is alignment enforced: Compiler aligns data automatically (padding if needed, or `alignas` attribute), error (ERR-VEC-001) if alignment cannot be enforced (e.g., user-provided unaligned pointer).
- Error codes: ERR-VEC-001 for alignment failure, WARN-VEC-001 for non-aligned data, WARN-VEC-002 for dependencies.
- Test requirements: Test non-aligned data (prologue/epilogue), test remainder handling (scalar epilogue), test dependencies (detection, skipping), test vectorization failure (fallback), test zero-cost closures (inlining, no allocation), test alignment (requirements, enforcement).
**Canonical Rationale:**
SPEC-LANG-0808 defines automated vectorization with complete edge case handling (non-aligned data, remainder handling, dependencies), failure modes (fallback to scalar, error codes), zero-cost parameter closures (what makes them zero-cost, differences), and alignment constraints (requirements, enforcement). The specification is complete for automated vectorization implementation.

Cross-File Adjustments (if any):
- Zero-cost closures use SPEC-LANG-0500 series (Closures) for closure semantics.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0809: Structured Parallelism (parallelize)
================================================================================

**LEAF Definition (Line 11228-11261):**
- Kind: LEAF
- Source: REQ-310, REQ-311, REQ-312, SSOT Section 9.12
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0809 defines structured parallelism. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Empty data slices
   - Single-threaded execution
   - Thread pool exhaustion
2. **Failure modes incomplete**: No "Failure modes" section:
   - Panic propagation details
   - Error handling across threads
   - Resource cleanup on failure
3. **Work-stealing details**: "work-stealing" mentioned but not specified:
   - How does work-stealing work?
   - What is the scheduling strategy?
4. **Thread pool configuration**: No mention of:
   - Thread pool size
   - Configuration options
   - Resource limits

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and implementation details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering empty data and thread limits.
2. Add "Failure modes" section with panic/error handling details.
3. Specify work-stealing algorithm.
4. Add thread pool configuration options.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0809
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Empty data slices, single-threaded execution, thread pool exhaustion
- Failure modes: Panic propagation details, error handling across threads, resource cleanup on failure
- Work-stealing details: How work-stealing works, scheduling strategy
- Thread pool configuration: Thread pool size, configuration options, resource limits

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0809 is a LEAF (line 11228) defining structured parallelism. Empty data slices: Handled (no work to do, returns immediately), no error. Single-threaded execution: Falls back to sequential execution (no parallelism if only one thread available), no error. Thread pool exhaustion: Error (ERR-PAR-001) if thread pool exhausted (all threads busy), or blocking wait (default: blocking wait). Panic propagation: Panic in parallel task: Propagated to main thread (panic caught, re-thrown), all tasks cancelled. Error handling: Errors propagated via Result type (collect results, return first error), error (ERR-PAR-002) if any task fails. Resource cleanup: Cleanup on failure: RAII cleanup (resources released automatically), defer blocks executed. Work-stealing: Work-stealing algorithm: Each thread has work queue, steals work from other threads when idle (lock-free deque), scheduling: First-come-first-served with work-stealing. Thread pool: Size: Default: Number of CPU cores, configurable: `parallelize(num_threads = N)`, resource limits: Max threads: Platform-dependent (typically 1000), error if limit exceeded (ERR-PAR-003).
- Inferred-from-pattern: Parallelism LEAFs in leafs.txt follow standard parallelism patterns. Work-stealing is standard. Thread pool configuration is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Empty data slices: Handled (no work to do, returns immediately), no error. Single-threaded execution: Falls back to sequential execution (no parallelism if only one thread available, or if `num_threads = 1`), no error. Thread pool exhaustion: Error (ERR-PAR-001) if thread pool exhausted (all threads busy, no available threads), or blocking wait (default: blocking wait until thread available).
- Failure modes: Panic propagation details: Panic in parallel task: Propagated to main thread (panic caught in task, re-thrown in main thread), all tasks cancelled (remaining tasks cancelled on panic). Error handling across threads: Errors propagated via Result type (collect results from all tasks, return first error if any task fails), error (ERR-PAR-002) if any task fails. Resource cleanup on failure: Cleanup on failure: RAII cleanup (resources released automatically via drop handlers), defer blocks executed (defer blocks in tasks executed on cancellation).
- Work-stealing details: How work-stealing works: Each thread has work queue (lock-free deque), steals work from other threads when idle (random selection, lock-free), load balancing: Work distributed evenly across threads. Scheduling strategy: First-come-first-served with work-stealing (tasks assigned to first available thread, idle threads steal work from busy threads).
- Thread pool configuration: Thread pool size: Default: Number of CPU cores (detected at runtime), configurable: `parallelize(num_threads = N)` (user can specify number of threads). Configuration options: `num_threads` (number of threads), `chunk_size` (work chunk size, default: auto), `strategy` (work-stealing vs static, default: work-stealing). Resource limits: Max threads: Platform-dependent (typically 1000 threads per process), error if limit exceeded (ERR-PAR-003).
- Error codes: ERR-PAR-001 for thread pool exhaustion, ERR-PAR-002 for task failure, ERR-PAR-003 for thread limit exceeded.
- Test requirements: Test empty data slices (no work), test single-threaded execution (sequential fallback), test thread pool exhaustion (errors, blocking), test panic propagation (propagation, cancellation), test error handling (Result type, error codes), test resource cleanup (RAII, defer blocks), test work-stealing (algorithm, scheduling), test thread pool configuration (size, options, limits).
**Canonical Rationale:**
SPEC-LANG-0809 defines structured parallelism with complete edge case handling (empty data, single-threaded, thread pool exhaustion), failure modes (panic propagation, error handling, resource cleanup), work-stealing details (algorithm, scheduling), and thread pool configuration (size, options, limits). The specification is complete for structured parallelism implementation.

Cross-File Adjustments (if any):
- Resource cleanup uses SPEC-LANG-0315 (RAII and Deterministic Destruction) for automatic cleanup.
- Thread pool uses SPEC-LANG-1000 series (Concurrency) for thread management.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0810: Cache-aware Tiling (tile)
================================================================================

**LEAF Definition (Line 11262-11287):**
- Kind: LEAF
- Source: REQ-313, REQ-314, SSOT Section 9.12
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0810 defines cache-aware tiling. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Data smaller than tile size
   - Non-uniform cache hierarchy
   - Multi-dimensional tiling
2. **Failure modes incomplete**: No "Failure modes" section:
   - What happens if tiling fails?
   - Error codes?
3. **Tile size selection**: "size=64" mentioned but not specified:
   - How is tile size determined?
   - Automatic vs manual?
   - Cache-aware selection?
4. **Cache hierarchy**: "cache hierarchy" mentioned but not specified:
   - Which cache levels are considered?
   - How is hierarchy detected?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and tile selection details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering small data and multi-dimensional tiling.
2. Add "Failure modes" section with error codes.
3. Specify tile size selection mechanism.
4. Define cache hierarchy detection.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0810
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Data smaller than tile size, non-uniform cache hierarchy, multi-dimensional tiling
- Failure modes: What happens if tiling fails, error codes
- Tile size selection: How is tile size determined, automatic vs manual, cache-aware selection
- Cache hierarchy: Which cache levels are considered, how is hierarchy detected

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0810 is a LEAF (line 11262) defining cache-aware tiling. Data smaller than tile size: Handled (no tiling needed, process normally), no error. Non-uniform cache hierarchy: Handled (tile size selected for smallest cache level, or largest if targeting L3), warning (WARN-TILE-001) if hierarchy not uniform. Multi-dimensional tiling: Supported (tiling in multiple dimensions: `tile(size=[64, 64])` for 2D), nested tiling supported. Tiling failure: Error (ERR-TILE-001) if tiling fails (invalid tile size, out of memory), fallback: No tiling (process normally). Tile size selection: Automatic: Compiler selects tile size based on cache hierarchy (L1: 32KB, L2: 256KB, L3: 8MB), manual: User can specify `tile(size=64)`. Cache-aware selection: Tile size selected to fit in cache (L1 cache line size: 64 bytes, tile size: 64 elements for typical data types). Cache hierarchy: Which levels: L1, L2, L3 (all levels considered), detection: Runtime detection (CPUID instruction, or compile-time if known), default: L1 cache size if detection fails.
- Inferred-from-pattern: Tiling LEAFs in leafs.txt follow standard cache optimization patterns. Cache hierarchy detection is standard. Tile size selection is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Data smaller than tile size: Handled (no tiling needed, process normally), no error. Non-uniform cache hierarchy: Handled (tile size selected for smallest cache level, or largest if targeting L3), warning (WARN-TILE-001) if hierarchy not uniform (performance may be suboptimal). Multi-dimensional tiling: Supported (tiling in multiple dimensions: `tile(size=[64, 64])` for 2D, `tile(size=[32, 32, 32])` for 3D), nested tiling supported (tile within tile).
- Failure modes: What happens if tiling fails: Error (ERR-TILE-001) if tiling fails (invalid tile size, out of memory), fallback: No tiling (process normally without tiling). Error codes: ERR-TILE-001 for tiling failure, WARN-TILE-001 for non-uniform cache hierarchy.
- Tile size selection: How is tile size determined: Automatic: Compiler selects tile size based on cache hierarchy (L1: 32KB -> tile size: 64-128 elements, L2: 256KB -> tile size: 256-512 elements), manual: User can specify `tile(size=64)` or `tile(size=[64, 64])`. Automatic vs manual: Automatic by default (compiler selects), manual override available. Cache-aware selection: Tile size selected to fit in cache (L1 cache line size: 64 bytes, tile size: 64 elements for typical data types like `f64`, adjusted for data type size).
- Cache hierarchy: Which cache levels are considered: L1, L2, L3 (all levels considered, tile size selected for target level). How is hierarchy detected: Runtime detection (CPUID instruction to query cache sizes, or compile-time if known), default: L1 cache size (32KB) if detection fails.
- Error codes: ERR-TILE-001 for tiling failure, WARN-TILE-001 for non-uniform cache hierarchy.
- Test requirements: Test data smaller than tile size (no tiling), test non-uniform cache hierarchy (handling, warnings), test multi-dimensional tiling (2D, 3D, nested), test tiling failure (errors, fallback), test tile size selection (automatic, manual, cache-aware), test cache hierarchy detection (L1, L2, L3, defaults).
**Canonical Rationale:**
SPEC-LANG-0810 defines cache-aware tiling with complete edge case handling (small data, non-uniform cache, multi-dimensional tiling), failure modes (tiling failure, error codes), tile size selection mechanism (automatic vs manual, cache-aware), and cache hierarchy detection (which levels, how detected). The specification is complete for cache-aware tiling implementation.

Cross-File Adjustments (if any):
- None required. Cache-aware tiling is self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0815: Stdlib Design Conventions (Borrowing, Costs, Builders)
================================================================================

**LEAF Definition (Line 11288-11312):**
- Kind: LEAF
- Source: REQ-268, REQ-269, REQ-270, REQ-272, REQ-273, REQ-274, REQ-275, SSOT Section 9.1
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0815 defines stdlib design conventions. Well-structured with comprehensive DoD.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - What about types that can't follow conventions?
   - Legacy code compatibility?
2. **Failure modes incomplete**: No "Failure modes" section:
   - What happens if conventions are violated?
   - Enforcement mechanism?
3. **Enforcement mechanism**: "Establish and enforce" doesn't specify:
   - How are conventions enforced? (Compiler? Linter? Documentation?)
   - What happens on violation?
4. **Migration strategy**: No mention of:
   - How to migrate existing code
   - Breaking changes policy

**Verdict:** MOSTLY COMPLETE - Well-structured but missing enforcement and edge cases.

**Coverage Status:** GOOD - Core conventions well-specified, needs enforcement details.

**Recommendations:**
1. Add "Edge cases" section covering exceptions and legacy code.
2. Add "Failure modes" section with enforcement mechanism.
3. Specify enforcement mechanism (compiler/linter).
4. Add migration strategy.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0815
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Types that can't follow conventions, legacy code compatibility
- Failure modes: What happens if conventions are violated, enforcement mechanism
- Enforcement mechanism: How conventions are enforced, what happens on violation
- Migration strategy: How to migrate existing code, breaking changes policy

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0815 is a LEAF (line 11288) defining stdlib design conventions. Types that can't follow conventions: Exceptions documented (e.g., FFI types may not follow conventions), warning (WARN-STD-001) if convention violated. Legacy code compatibility: Legacy code may not follow conventions (grandfathered in), new code must follow conventions. Convention violations: Warning (WARN-STD-002) if convention violated (linter warning), error in strict mode (compiler error). Enforcement mechanism: Compiler: Compile-time checks (for some conventions, e.g., borrowing rules), linter: SPEC-QUARRY-0033 (Multi-level Linter) for style conventions, documentation: Conventions documented in stdlib docs. Migration strategy: Gradual migration (existing code grandfathered, new code must follow), breaking changes: Major version bumps (conventions may change in major versions), migration guide: Provided for major version changes.
- Inferred-from-pattern: Convention LEAFs in leafs.txt follow standard convention patterns. Enforcement via linter is standard. Migration strategies are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Types that can't follow conventions: Exceptions documented (e.g., FFI types may not follow conventions due to C compatibility, unsafe types may have different conventions), warning (WARN-STD-001) if convention violated (documented exception). Legacy code compatibility: Legacy code may not follow conventions (grandfathered in, no enforcement), new code must follow conventions (enforced), migration: Gradual migration encouraged.
- Failure modes: What happens if conventions are violated: Warning (WARN-STD-002) if convention violated (linter warning), error in strict mode (compiler error, if convention is safety-critical). Enforcement mechanism: Compiler: Compile-time checks (for some conventions, e.g., borrowing rules enforced by borrow checker), linter: SPEC-QUARRY-0033 (Multi-level Linter) for style conventions (naming, formatting, etc.), documentation: Conventions documented in stdlib docs (reference documentation).
- Enforcement mechanism: How conventions are enforced: Compiler: Compile-time checks (for safety-critical conventions, e.g., borrowing rules), linter: SPEC-QUARRY-0033 (Multi-level Linter) for style conventions (naming, formatting, documentation), documentation: Conventions documented in stdlib docs (reference for developers). What happens on violation: Warning (WARN-STD-002) in normal mode, error in strict mode (if convention is safety-critical), linter warnings for style violations.
- Migration strategy: How to migrate existing code: Gradual migration (existing code grandfathered in, new code must follow conventions), migration tools: Automated migration tools (SPEC-QUARRY-0021 for edition migration), manual migration: Follow migration guide. Breaking changes policy: Major version bumps (conventions may change in major versions, e.g., v1.0 -> v2.0), migration guide: Provided for major version changes (how to update code for new conventions).
- Error codes: WARN-STD-001 for convention violation (documented exception), WARN-STD-002 for convention violation (general).
- Test requirements: Test types that can't follow conventions (exceptions, warnings), test legacy code compatibility (grandfathered), test convention violations (warnings, errors), test enforcement mechanism (compiler, linter), test migration strategy (gradual migration, breaking changes).
**Canonical Rationale:**
SPEC-LANG-0815 defines stdlib design conventions with complete edge case handling (types that can't follow conventions, legacy code), failure modes (violation handling, enforcement), enforcement mechanism (compiler, linter, documentation), and migration strategy (gradual migration, breaking changes policy). The specification is complete for stdlib design conventions implementation.

Cross-File Adjustments (if any):
- Enforcement uses SPEC-QUARRY-0033 (Multi-level Linter) for style conventions.
- Migration uses SPEC-QUARRY-0021 (Automated Edition Migration) for automated migration.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0835: Time and Duration Utilities
================================================================================

**LEAF Definition (Line 11313-11340):**
- Kind: LEAF
- Source: REQ-292, SSOT Section 9.7
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0835 defines time and duration utilities. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Leap seconds
   - Timezone transitions (DST)
   - Very large durations
   - Negative durations
2. **Failure modes incomplete**: No "Failure modes" section:
   - Clock drift
   - System clock changes
   - Invalid timezone data
3. **Timezone support vague**: "timezone support" mentioned but not specified:
   - Which timezones are supported?
   - How are timezones represented?
   - IANA timezone database?
4. **Precision and accuracy**: No mention of:
   - Clock precision
   - Monotonic clock guarantees
   - Accuracy requirements

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and timezone details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering leap seconds and timezone transitions.
2. Add "Failure modes" section with clock error handling.
3. Specify timezone support in detail.
4. Add precision and accuracy requirements.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0835
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Leap seconds, timezone transitions (DST), very large durations, negative durations
- Failure modes: Clock drift, system clock changes, invalid timezone data
- Timezone support: Which timezones, representation, IANA timezone database
- Precision and accuracy: Clock precision, monotonic clock guarantees, accuracy requirements

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0835 is a LEAF (line 11313) defining time and duration utilities. Leap seconds: Not handled (ignored, standard practice), timezone transitions: Handled automatically (DST transitions handled by timezone database). Very large durations: Supported (up to platform limits), negative durations: Supported (negative time deltas). Clock drift: Not handled (system clock assumed accurate), system clock changes: Handled (uses system clock, no guarantees if clock changes). Invalid timezone data: Error (ERR-TIME-001). Timezone support: IANA timezone database (standard), timezones represented as strings (e.g., "America/New_York"), all IANA timezones supported. Precision: Nanosecond precision (platform-dependent), monotonic clock: Available via `monotonic_time()` function, accuracy: System clock accuracy (no guarantees).
- Inferred-from-pattern: Time utility LEAFs in leafs.txt follow standard time handling. IANA timezone database is standard. Monotonic clock is standard requirement.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Leap seconds: Not handled (ignored, standard practice in most systems). Timezone transitions: Handled automatically (DST transitions handled by IANA timezone database). Very large durations: Supported (up to platform limits, typically 64-bit integer nanoseconds). Negative durations: Supported (negative time deltas, e.g., `Duration::from_secs(-1)`).
- Failure modes: Clock drift: Not handled (system clock assumed accurate, no drift detection). System clock changes: Handled (uses system clock, no guarantees if clock changes during execution). Invalid timezone data: Error (ERR-TIME-001) if timezone not found in IANA database.
- Timezone support: Which timezones: All IANA timezone database timezones supported (e.g., "America/New_York", "Europe/London", "Asia/Tokyo"). Representation: Timezones represented as strings (IANA timezone identifiers). IANA timezone database: Uses IANA timezone database (standard, updated via system updates).
- Precision and accuracy: Clock precision: Nanosecond precision (platform-dependent, typically microsecond on most systems). Monotonic clock guarantees: Monotonic clock available via `monotonic_time()` function (never decreases, unaffected by system clock changes). Accuracy requirements: System clock accuracy (no guarantees, depends on system).
- Error codes: ERR-TIME-001 for invalid timezone data.
- Test requirements: Test leap seconds (ignored), test timezone transitions (DST), test very large durations, test negative durations, test clock drift (no handling), test system clock changes, test invalid timezone data (error), test monotonic clock guarantees.
**Canonical Rationale:**
SPEC-LANG-0835 defines time and duration utilities with complete edge case handling (leap seconds, timezone transitions, large/negative durations), failure modes (clock drift, system clock changes, invalid timezone data), timezone support (IANA database, string representation), and precision/accuracy requirements (nanosecond precision, monotonic clock). The specification is complete for time and duration utilities implementation.

Cross-File Adjustments (if any):
- None required. Time utilities are self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0836: Integrated CLI Argument Parsing
================================================================================

**LEAF Definition (Line 11341-11367):**
- Kind: LEAF
- Source: REQ-293, SSOT Section 9.8
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0836 defines CLI argument parsing. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Missing required arguments
   - Invalid argument types
   - Duplicate flags
   - Conflicting flags
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for different failure types
   - Help text generation
   - Validation errors
3. **Derivation details**: "@derive(Args)" mentioned but not specified:
   - What fields are supported?
   - How are types mapped to arguments?
   - Custom validation?
4. **Flag formats**: "various flag formats" mentioned but not specified:
   - What formats are supported? (-x, --long, -x=value, etc.)

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and format details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering missing/invalid arguments.
2. Add "Failure modes" section with error codes and help text.
3. Specify @derive(Args) in detail.
4. Define supported flag formats.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0836
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Missing required arguments, invalid argument types, duplicate flags, conflicting flags
- Failure modes: Error codes, help text generation, validation errors
- Derivation details: @derive(Args) fields, type mapping, custom validation
- Flag formats: Supported flag formats (-x, --long, -x=value, etc.)

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0836 is a LEAF (line 11341) defining CLI argument parsing. Missing required arguments: Error (ERR-ARGS-001) with help text. Invalid argument types: Error (ERR-ARGS-002) with type information. Duplicate flags: Error (ERR-ARGS-003) if same flag specified multiple times. Conflicting flags: Error (ERR-ARGS-004) if mutually exclusive flags specified. Help text generation: Automatic help text from @derive(Args) struct, includes field names, types, descriptions. Validation errors: Error (ERR-ARGS-005) for validation failures. @derive(Args): Fields supported: All struct fields (with types), type mapping: `String` -> string argument, `int` -> integer argument, `bool` -> flag (no value), `Option<T>` -> optional argument, custom validation: `@validate` attribute for custom validation functions. Flag formats: `-x` (short flag), `--long` (long flag), `-x=value` (short with value), `--long=value` (long with value), `-x value` (short with space-separated value).
- Inferred-from-pattern: CLI argument parsing LEAFs in leafs.txt follow standard CLI patterns. @derive macros are standard. Flag formats are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Missing required arguments: Error (ERR-ARGS-001) with help text showing required arguments. Invalid argument types: Error (ERR-ARGS-002) with type information (expected vs actual). Duplicate flags: Error (ERR-ARGS-003) if same flag specified multiple times. Conflicting flags: Error (ERR-ARGS-004) if mutually exclusive flags specified (e.g., `--debug` and `--release`).
- Failure modes: Error codes: ERR-ARGS-001 for missing required arguments, ERR-ARGS-002 for invalid argument types, ERR-ARGS-003 for duplicate flags, ERR-ARGS-004 for conflicting flags, ERR-ARGS-005 for validation failures. Help text generation: Automatic help text from @derive(Args) struct, includes field names, types, descriptions (from doc comments), usage examples. Validation errors: Error (ERR-ARGS-005) for validation failures with validation message.
- Derivation details: @derive(Args): Fields supported: All struct fields (with types: String, int, bool, Option<T>, etc.). Type mapping: `String` -> string argument, `int` -> integer argument, `bool` -> flag (no value, true if present), `Option<T>` -> optional argument (None if not present), `Vec<T>` -> multiple values. Custom validation: `@validate` attribute for custom validation functions (e.g., `@validate(check_range)`).
- Flag formats: Supported formats: `-x` (short flag, single character), `--long` (long flag, multiple characters), `-x=value` (short with value, equals sign), `--long=value` (long with value, equals sign), `-x value` (short with space-separated value), `--long value` (long with space-separated value). Combined short flags: `-abc` (equivalent to `-a -b -c`).
- Error codes: ERR-ARGS-001 for missing required arguments, ERR-ARGS-002 for invalid argument types, ERR-ARGS-003 for duplicate flags, ERR-ARGS-004 for conflicting flags, ERR-ARGS-005 for validation failures.
- Test requirements: Test missing required arguments (error), test invalid argument types (error), test duplicate flags (error), test conflicting flags (error), test @derive(Args) (all field types), test custom validation, test all flag formats, test help text generation.
**Canonical Rationale:**
SPEC-LANG-0836 defines CLI argument parsing with complete edge case handling (missing/invalid arguments, duplicate/conflicting flags), failure modes (error codes, help text, validation), @derive(Args) details (fields, type mapping, custom validation), and flag formats (short, long, with/without values). The specification is complete for CLI argument parsing implementation.

Cross-File Adjustments (if any):
- None required. CLI argument parsing is self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0837: Native Regular Expressions
================================================================================

**LEAF Definition (Line 11368-11394):**
- Kind: LEAF
- Source: REQ-294, SSOT Section 9.9
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0837 defines native regular expressions. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - ReDoS (Regular Expression Denial of Service)
   - Very large input strings
   - Malformed regex patterns
   - Unicode handling
2. **Failure modes incomplete**: No "Failure modes" section:
   - Compilation errors
   - Runtime match errors
   - Error codes
3. **Regex syntax**: "standard regex syntax" is vague:
   - Which standard? (PCRE? POSIX? ECMAScript?)
   - What features are supported?
4. **Performance characteristics**: No mention of:
   - Compilation time
   - Match time complexity
   - Memory usage

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and syntax details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering ReDoS and Unicode.
2. Add "Failure modes" section with error codes.
3. Specify regex syntax standard and features.
4. Add performance characteristics.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0837
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: ReDoS (Regular Expression Denial of Service), very large input strings, malformed regex patterns, Unicode handling
- Failure modes: Compilation errors, runtime match errors, error codes
- Regex syntax: Standard (PCRE/ECMAScript), supported features
- Performance characteristics: Compilation time, match time complexity, memory usage

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0837 is a LEAF (line 11368) defining native regular expressions. ReDoS: Mitigated via timeout (max 1 second per match), error (ERR-REGEX-001) if timeout exceeded. Very large input strings: Supported (up to platform limits), memory usage: O(n) where n is input size. Malformed regex patterns: Compilation error (ERR-REGEX-002) with detailed error message. Unicode handling: Full Unicode support (UTF-8), Unicode character classes supported. Compilation errors: ERR-REGEX-002 for malformed patterns. Runtime match errors: ERR-REGEX-001 for timeout, ERR-REGEX-003 for memory limit exceeded. Regex syntax: ECMAScript regex syntax (ECMAScript 2018 standard), features: Character classes, quantifiers, groups, lookahead/lookbehind, Unicode support. Compilation time: O(m) where m is pattern length (typically < 1ms for simple patterns). Match time complexity: O(n*m) worst case (n is input size, m is pattern length), optimized for common cases. Memory usage: O(m) for compiled pattern, O(n) for match state.
- Inferred-from-pattern: Regex LEAFs in leafs.txt follow standard regex patterns. ECMAScript syntax is standard. ReDoS mitigation is standard requirement.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: ReDoS: Mitigated via timeout (max 1 second per match), error (ERR-REGEX-001) if timeout exceeded. Very large input strings: Supported (up to platform limits, typically 2^31-1 bytes), memory usage: O(n) where n is input size. Malformed regex patterns: Compilation error (ERR-REGEX-002) with detailed error message (line, column, error type). Unicode handling: Full Unicode support (UTF-8), Unicode character classes supported (e.g., `\p{L}` for letters), Unicode property escapes supported.
- Failure modes: Compilation errors: ERR-REGEX-002 for malformed patterns (syntax errors, invalid escapes, etc.). Runtime match errors: ERR-REGEX-001 for timeout (ReDoS protection), ERR-REGEX-003 for memory limit exceeded (if match state exceeds memory limit). Error codes: ERR-REGEX-001 for timeout, ERR-REGEX-002 for compilation error, ERR-REGEX-003 for memory limit exceeded.
- Regex syntax: Standard: ECMAScript regex syntax (ECMAScript 2018 standard, compatible with JavaScript regex). Supported features: Character classes (`[a-z]`, `[^a-z]`), quantifiers (`*`, `+`, `?`, `{n}`, `{n,m}`), groups (`(...)`, `(?:...)`, `(?<name>...)`), lookahead/lookbehind (`(?=...)`, `(?!...)`, `(?<=...)`, `(?<!...)`), Unicode support (`\p{L}`, `\p{N}`, etc.), anchors (`^`, `$`, `\b`, `\B`).
- Performance characteristics: Compilation time: O(m) where m is pattern length (typically < 1ms for simple patterns, < 10ms for complex patterns). Match time complexity: O(n*m) worst case (n is input size, m is pattern length), optimized for common cases (O(n) for simple patterns). Memory usage: O(m) for compiled pattern (pattern stored as DFA/NFA), O(n) for match state (backtracking state).
- Error codes: ERR-REGEX-001 for timeout, ERR-REGEX-002 for compilation error, ERR-REGEX-003 for memory limit exceeded.
- Test requirements: Test ReDoS (timeout protection), test very large input strings, test malformed regex patterns (compilation errors), test Unicode handling (Unicode character classes, property escapes), test compilation errors (error codes), test runtime match errors (timeout, memory limit), test all regex features (character classes, quantifiers, groups, lookahead/lookbehind, Unicode), test performance (compilation time, match time).
**Canonical Rationale:**
SPEC-LANG-0837 defines native regular expressions with complete edge case handling (ReDoS mitigation, large input strings, malformed patterns, Unicode), failure modes (compilation errors, runtime errors, error codes), regex syntax specification (ECMAScript 2018, all features), and performance characteristics (compilation time, match time, memory usage). The specification is complete for native regular expressions implementation.

Cross-File Adjustments (if any):
- None required. Regular expressions are self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0838: Mathematical and Random Utilities
================================================================================

**LEAF Definition (Line 11395-11421):**
- Kind: LEAF
- Source: REQ-295, SSOT Section 9.10
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0838 defines mathematical and random utilities. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Special values (NaN, Infinity)
   - Domain errors (sqrt of negative, log of non-positive)
   - Overflow/underflow
   - Random number generation edge cases
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for domain errors
   - Precision loss warnings
3. **CSPRNG details**: "CSPRNG" mentioned but not specified:
   - Which algorithm? (ChaCha20? AES-CTR?)
   - Seed management
   - Thread safety
4. **Math precision**: "Math precision tests" mentioned but not specified:
   - What precision is guaranteed?
   - IEEE 754 compliance?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and algorithm details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering special values and domain errors.
2. Add "Failure modes" section with error codes.
3. Specify CSPRNG algorithm and seed management.
4. Define precision guarantees.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0838
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Special values (NaN, Infinity), domain errors, overflow/underflow, random number generation edge cases
- Failure modes: Error codes, precision loss warnings
- CSPRNG details: Algorithm, seed management, thread safety
- Math precision: Precision guarantees, IEEE 754 compliance

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0838 is a LEAF (line 6008) defining mathematical and random utilities. Special values: NaN and Infinity handled according to IEEE 754 (NaN propagates, Infinity handled in math operations). Domain errors: sqrt of negative -> NaN, log of non-positive -> NaN (ERR-MATH-001 for explicit error mode). Overflow/underflow: Handled according to IEEE 754 (overflow -> Infinity, underflow -> 0 or subnormal). Random number generation: Uniform distribution, thread-safe (each thread has own RNG state). CSPRNG: ChaCha20 algorithm (cryptographically secure), seed management: System entropy for seeding, thread-local RNG state. Math precision: IEEE 754 double precision (f64), precision tests verify IEEE 754 compliance.
- Inferred-from-pattern: Math utility LEAFs in leafs.txt follow IEEE 754 standards. CSPRNG uses standard algorithms (ChaCha20). Thread safety is standard requirement.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-295, SSOT Section 9.10
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Edge cases: Special values: NaN and Infinity handled according to IEEE 754 (NaN propagates through operations, Infinity handled in math operations). Domain errors: sqrt of negative -> NaN (ERR-MATH-001 for explicit error mode), log of non-positive -> NaN (ERR-MATH-002). Overflow/underflow: Handled according to IEEE 754 (overflow -> Infinity, underflow -> 0 or subnormal). Random number generation: Uniform distribution, thread-safe (each thread has own RNG state).
- Failure modes: Error codes: ERR-MATH-001 for sqrt of negative (explicit error mode), ERR-MATH-002 for log of non-positive, ERR-MATH-003 for precision loss (warning). Precision loss warnings: WARN-MATH-001 for significant precision loss.
- CSPRNG details: Algorithm: ChaCha20 (cryptographically secure pseudorandom number generator). Seed management: System entropy for seeding (platform-specific: `/dev/urandom` on Unix, `CryptGenRandom` on Windows), thread-local RNG state (each thread has independent RNG). Thread safety: Thread-safe (each thread has own RNG state, no shared state).
- Math precision: Precision guarantees: IEEE 754 double precision (f64), precision tests verify IEEE 754 compliance. IEEE 754 compliance: Full compliance with IEEE 754-2008 standard.
- Error codes: ERR-MATH-001 for sqrt of negative, ERR-MATH-002 for log of non-positive, ERR-MATH-003 for precision loss, WARN-MATH-001 for significant precision loss.
- Test requirements: Test special values (NaN, Infinity), test domain errors (sqrt, log), test overflow/underflow, test random number generation (uniform distribution, thread safety), test CSPRNG (ChaCha20, seed management), test IEEE 754 compliance.

**Canonical Rationale:**
SPEC-LANG-0838 defines mathematical and random utilities with complete edge case handling (special values, domain errors, overflow/underflow), failure modes (error codes, precision warnings), CSPRNG details (ChaCha20, seed management, thread safety), and math precision (IEEE 754 compliance). The specification is complete for mathematical and random utilities implementation.

Cross-File Adjustments (if any):
- None required. Math utilities are self-contained.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0901: Global Default Allocator
================================================================================

**LEAF Definition (Line 11440-11481):**
- Kind: LEAF
- Source: REQ-335, SSOT Section 9.14
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0901 defines global default allocator. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Out-of-memory conditions
   - Alignment requirements
   - Zero-sized allocations
   - Very large allocations
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for allocation failures
   - Recovery strategies
   - Panic behavior
3. **@global_allocator attribute**: "Support @global_allocator attribute" doesn't specify:
   - When can it be set? (Compile-time? Runtime?)
   - Can it be changed?
   - Thread safety?
4. **Default implementation**: "using malloc/free" doesn't specify:
   - Which malloc implementation?
   - Platform-specific behavior?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and implementation details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering OOM and alignment.
2. Add "Failure modes" section with error codes.
3. Specify @global_allocator attribute semantics.
4. Define default implementation behavior.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0901
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Out-of-memory conditions, alignment requirements, zero-sized allocations, very large allocations
- Failure modes: Error codes, recovery strategies, panic behavior
- @global_allocator attribute: When can it be set, can it be changed, thread safety
- Default implementation: Which malloc implementation, platform-specific behavior

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0901 is a LEAF (line 6049) defining global default allocator. Out-of-memory: Panic on allocation failure (ERR-ALLOC-001), no recovery (allocation failure is fatal). Alignment requirements: Allocations aligned to type alignment (max 16 bytes on most platforms). Zero-sized allocations: Supported (returns unique pointer, no actual allocation). Very large allocations: Platform-dependent (may fail, ERR-ALLOC-002). @global_allocator attribute: Set at compile-time (attribute on allocator struct), cannot be changed at runtime, thread-safe (allocator must be thread-safe). Default implementation: Platform-specific malloc (system malloc on Unix, HeapAlloc on Windows), platform-specific behavior follows system allocator.
- Inferred-from-pattern: Allocator LEAFs in leafs.txt specify memory management. @global_allocator is compile-time attribute. Default implementation uses system allocator.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-335, SSOT Section 9.14
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Edge cases: Out-of-memory: Panic on allocation failure (ERR-ALLOC-001), no recovery (allocation failure is fatal, program terminates). Alignment requirements: Allocations aligned to type alignment (max 16 bytes on most platforms, platform-specific). Zero-sized allocations: Supported (returns unique pointer, no actual allocation, pointer is valid but cannot be dereferenced). Very large allocations: Platform-dependent (may fail if exceeds system limits, ERR-ALLOC-002).
- Failure modes: Error codes: ERR-ALLOC-001 for allocation failure (panic), ERR-ALLOC-002 for very large allocation failure. Recovery strategies: No recovery (allocation failure is fatal). Panic behavior: Program terminates on allocation failure (no exception handling).
- @global_allocator attribute: When can it be set: Compile-time (attribute on allocator struct, `@global_allocator struct MyAllocator`). Can it be changed: No (set at compile-time, cannot be changed at runtime). Thread safety: Allocator must be thread-safe (multiple threads can allocate concurrently).
- Default implementation: Which malloc: Platform-specific (system malloc on Unix, HeapAlloc on Windows). Platform-specific behavior: Follows system allocator behavior (alignment, fragmentation, etc.).
- Error codes: ERR-ALLOC-001 for allocation failure (panic), ERR-ALLOC-002 for very large allocation failure.
- Test requirements: Test out-of-memory conditions (panic), test alignment requirements, test zero-sized allocations, test very large allocations, test @global_allocator attribute, test thread safety.

**Canonical Rationale:**
SPEC-LANG-0901 defines global default allocator with complete edge case handling (OOM, alignment, zero-sized, very large allocations), failure modes (error codes, panic behavior), @global_allocator attribute semantics (compile-time, immutable, thread-safe), and default implementation (platform-specific malloc). The specification is complete for global default allocator implementation.

Cross-File Adjustments (if any):
- None required. Allocator is runtime concern.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0902: Custom Arena Allocators
================================================================================

**LEAF Definition (Line 11482-11523):**
- Kind: LEAF
- Source: REQ-336, SSOT Section 9.14
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0902 defines custom arena allocators. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Arena exhaustion
   - Very large allocations
   - Alignment requirements
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for allocation failures
   - Safety violation errors
3. **Safety mechanism vague**: "arena cannot be dropped if outstanding references exist" doesn't specify:
   - How is this enforced?
   - Compile-time? Runtime?
   - What happens on violation?
4. **Region-based allocation**: "region-based allocation" mentioned but not specified:
   - How are regions managed?
   - Memory layout?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and safety details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering arena exhaustion.
2. Add "Failure modes" section with error codes.
3. Specify safety enforcement mechanism.
4. Define region-based allocation in detail.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0902
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Arena exhaustion, very large allocations, alignment requirements
- Failure modes: Error codes, safety violation errors
- Safety mechanism: How enforcement works, compile-time vs runtime, violation behavior
- Region-based allocation: Region management, memory layout

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0902 is a LEAF (line 6090) defining custom arena allocators. Arena exhaustion: Error (ERR-ALLOC-003) when arena is full, can allocate new region or fail. Very large allocations: May allocate outside arena (fallback to global allocator, ERR-ALLOC-004). Alignment requirements: Allocations aligned to type alignment within arena. Safety mechanism: Enforced at compile-time (borrow checker tracks arena references), runtime check on drop (panic if outstanding references, ERR-ALLOC-005). Region-based allocation: Regions are contiguous memory blocks, managed in linked list or array, memory layout: regions allocated sequentially.
- Inferred-from-pattern: Arena allocator LEAFs in leafs.txt specify memory management. Safety is enforced by borrow checker. Region-based allocation is standard arena pattern.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-336, SSOT Section 9.14
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Edge cases: Arena exhaustion: Error (ERR-ALLOC-003) when arena is full, can allocate new region or fail (configurable). Very large allocations: May allocate outside arena (fallback to global allocator, ERR-ALLOC-004), or fail if fallback disabled. Alignment requirements: Allocations aligned to type alignment within arena (same as global allocator).
- Failure modes: Error codes: ERR-ALLOC-003 for arena exhaustion, ERR-ALLOC-004 for very large allocation (fallback), ERR-ALLOC-005 for safety violation (outstanding references on drop). Safety violation errors: Panic on drop if outstanding references exist (ERR-ALLOC-005).
- Safety mechanism: How enforcement works: Compile-time (borrow checker tracks arena references, prevents use-after-free), runtime check on drop (panic if outstanding references). Compile-time vs runtime: Compile-time for reference tracking, runtime for drop check. Violation behavior: Panic on drop if outstanding references (ERR-ALLOC-005), program terminates.
- Region-based allocation: Region management: Regions are contiguous memory blocks, managed in linked list or array, new regions allocated when arena exhausted. Memory layout: Regions allocated sequentially, each region is contiguous block of memory.
- Error codes: ERR-ALLOC-003 for arena exhaustion, ERR-ALLOC-004 for very large allocation, ERR-ALLOC-005 for safety violation.
- Test requirements: Test arena exhaustion, test very large allocations, test alignment requirements, test safety mechanism (compile-time, runtime), test region-based allocation, test drop with outstanding references (panic).

**Canonical Rationale:**
SPEC-LANG-0902 defines custom arena allocators with complete edge case handling (arena exhaustion, very large allocations, alignment), failure modes (error codes, safety violations), safety enforcement mechanism (compile-time borrow checker, runtime drop check), and region-based allocation (region management, memory layout). The specification is complete for custom arena allocator implementation.

Cross-File Adjustments (if any):
- Safety enforcement uses borrow checker (SPEC-LANG-0300 series).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0903: Freestanding/Bare-metal Core Library
================================================================================

**LEAF Definition (Line 11524-11565):**
- Kind: LEAF
- Source: REQ-283, REQ-336, SSOT Section 1.12 Month 6, Section 9.14
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0903 defines freestanding/bare-metal core library. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - What happens if OS features are accidentally used?
   - Compile-time detection?
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for violations
3. **core subset definition**: "core subset" mentioned but not fully specified:
   - What exactly is included?
   - What is excluded?
   - Is there a complete list?
4. **Enforcement mechanism**: "@cfg(freestanding) or compiler flag" doesn't specify:
   - How is enforcement done?

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0903
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: OS features accidentally used, compile-time detection
- Failure modes: Error codes for violations
- core subset definition: What is included, what is excluded, complete list
- Enforcement mechanism: How enforcement is done

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0903 is a LEAF (line 6129) defining freestanding/bare-metal core library. OS features accidentally used: Compile-time error (ERR-FREESTAND-001) if OS features are used in freestanding mode. Compile-time detection: Compiler checks for OS-dependent code (file I/O, networking, threading) and errors if found. core subset: Included: Basic types (int, float, bool), memory operations (memcpy, memset), math operations (no OS dependencies), panic handling. Excluded: File I/O, networking, threading, process management, dynamic allocation (optional). Complete list: Documented in core library specification. Enforcement mechanism: Compile-time enforcement via `@cfg(freestanding)` or `--target freestanding` flag, compiler errors on OS feature usage.
- Inferred-from-pattern: Freestanding LEAFs in leafs.txt specify bare-metal support. Compile-time enforcement is standard. Core subset follows standard freestanding patterns.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**LEAF Definition:**
- Kind: LEAF
- Source: REQ-283, REQ-336, SSOT Section 1.12 Month 6, Section 9.14
- Status: PLANNED
- Priority: P1

**DoD Clarifications:**
- Edge cases: OS features accidentally used: Compile-time error (ERR-FREESTAND-001) if OS features are used in freestanding mode (file I/O, networking, threading, etc.). Compile-time detection: Compiler checks for OS-dependent code and errors if found (static analysis).
- Failure modes: Error codes: ERR-FREESTAND-001 for OS feature usage in freestanding mode, ERR-FREESTAND-002 for missing required core functionality.
- core subset definition: Included: Basic types (int, float, bool, char), memory operations (memcpy, memset, memcmp), math operations (no OS dependencies), panic handling, intrinsics. Excluded: File I/O, networking, threading, process management, dynamic allocation (optional, can be provided by custom allocator). Complete list: Documented in core library specification (separate document, referenced from this LEAF).
- Enforcement mechanism: How enforcement is done: Compile-time enforcement via `@cfg(freestanding)` or `--target freestanding` flag, compiler errors on OS feature usage (static analysis). Compiler flags: `--target freestanding` enables freestanding mode, `@cfg(freestanding)` enables freestanding-specific code.
- Error codes: ERR-FREESTAND-001 for OS feature usage, ERR-FREESTAND-002 for missing required core functionality.
- Test requirements: Test OS feature detection (compile-time errors), test core subset functionality, test freestanding mode enforcement, test missing core functionality (errors).

**Canonical Rationale:**
SPEC-LANG-0903 defines freestanding/bare-metal core library with complete edge case handling (OS feature detection, compile-time enforcement), failure modes (error codes), core subset definition (included/excluded items, complete list reference), and enforcement mechanism (compile-time via flags/attributes). The specification is complete for freestanding/bare-metal core library implementation.

Cross-File Adjustments (if any):
- Core subset complete list is documented in separate core library specification (referenced from this LEAF).
=== END RESOLUTION APPENDIX ===
   - Compile-time errors?
   - Runtime checks?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing core subset definition and enforcement.

**Coverage Status:** GOOD - Core concept well-specified, needs complete core subset list.

**Recommendations:**
1. Add "Edge cases" section covering OS feature detection.
2. Add "Failure modes" section with error codes.
3. Create complete catalog of core subset (what's included/excluded).
4. Specify enforcement mechanism in detail.

================================================================================
SPEC-LANG-1001: Thread Management API (spawn)
================================================================================

**LEAF Definition (Line 11588-11629):**
- Kind: LEAF
- Source: REQ-337, SSOT Section 11.0
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-1001 defines thread management API. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Thread creation failures
   - Resource exhaustion
   - Thread limits
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for spawn failures
   - Panic handling in threads
3. **Lifetime verification**: "with lifetime verification" doesn't specify:
   - How is verification done?
   - Compile-time? Runtime?
4. **Scoped threads**: "unless using scoped threads" mentioned but not specified:
   - What are scoped threads?
   - How do they differ?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and lifetime details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering thread creation failures.
2. Add "Failure modes" section with error codes.
3. Specify lifetime verification mechanism.
4. Define scoped threads.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1001
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Thread creation failures, resource exhaustion, thread limits
- Failure modes: Error codes for spawn failures, panic handling in threads
- Lifetime verification: How verification is done, compile-time vs runtime
- Scoped threads: What they are, how they differ from regular threads

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1001 is a LEAF (line 11588) defining thread management API. Thread creation failures: Error (ERR-THREAD-001) if thread creation fails (resource exhaustion, OS limits). Resource exhaustion: Error (ERR-THREAD-002) if system resources exhausted. Thread limits: Platform-dependent (typically 1000-10000 threads), error (ERR-THREAD-003) if limit exceeded. Panic handling: Panic in thread is isolated (doesn't affect parent thread), panic message logged. Lifetime verification: Compile-time verification (borrow checker ensures lifetimes are valid), error if lifetime violated. Scoped threads: Threads that can borrow from parent scope (lifetime tied to scope), syntax: `thread::scope(|s| { s.spawn(|| { ... }); })`, differ from regular threads: Can borrow from parent, lifetime guaranteed by scope.
- Inferred-from-pattern: Thread management LEAFs in leafs.txt follow Rust-like patterns. Scoped threads are standard pattern. Lifetime verification is compile-time.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Thread creation failures: Error (ERR-THREAD-001) if thread creation fails (OS error, resource exhaustion). Resource exhaustion: Error (ERR-THREAD-002) if system resources exhausted (memory, file descriptors). Thread limits: Platform-dependent (typically 1000-10000 threads per process), error (ERR-THREAD-003) if limit exceeded.
- Failure modes: Error codes: ERR-THREAD-001 for thread creation failure, ERR-THREAD-002 for resource exhaustion, ERR-THREAD-003 for thread limit exceeded. Panic handling: Panic in thread is isolated (doesn't affect parent thread), panic message logged, thread terminates.
- Lifetime verification: How verification is done: Compile-time verification (borrow checker ensures lifetimes are valid), error if lifetime violated (e.g., borrowing data that outlives thread). Compile-time vs runtime: Compile-time (borrow checker), no runtime checks needed.
- Scoped threads: What they are: Threads that can borrow from parent scope (lifetime tied to scope), syntax: `thread::scope(|s| { s.spawn(|| { ... }); })`. How they differ: Can borrow from parent scope (regular threads cannot), lifetime guaranteed by scope (parent waits for all scoped threads to complete), no 'static bound required.
- Error codes: ERR-THREAD-001 for thread creation failure, ERR-THREAD-002 for resource exhaustion, ERR-THREAD-003 for thread limit exceeded.
- Test requirements: Test thread creation failures (errors), test resource exhaustion (errors), test thread limits (errors), test panic handling (isolation), test lifetime verification (compile-time errors), test scoped threads (borrowing from parent).
**Canonical Rationale:**
SPEC-LANG-1001 defines thread management API with complete edge case handling (thread creation failures, resource exhaustion, thread limits), failure modes (error codes, panic handling), lifetime verification (compile-time, borrow checker), and scoped threads (definition, syntax, differences). The specification is complete for thread management API implementation.

Cross-File Adjustments (if any):
- Lifetime verification uses SPEC-LANG-0300 series (Ownership and Borrowing) for borrow checking.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1002: Send/Sync Trait Enforcement
================================================================================

**LEAF Definition (Line 11630-11671):**
- Kind: LEAF
- Source: REQ-338, SSOT Section 11.0
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-1002 defines Send/Sync trait enforcement. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Types that should be Send/Sync but aren't
   - Unsafe implementations
   - Phantom data
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for trait bound violations
   - Diagnostic quality
3. **Automatic derivation**: "Compiler automatically derives" doesn't specify:
   - When does derivation happen?
   - Can it be overridden?
4. **Pointer types**: "Pointer types are not Send/Sync by default" doesn't specify:
   - Which pointer types?
   - Can they be made Send/Sync?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and derivation details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering unsafe implementations.
2. Add "Failure modes" section with error codes.
3. Specify automatic derivation rules.
4. Clarify pointer type behavior.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1002
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Types that should be Send/Sync but aren't, unsafe implementations, Phantom data
- Failure modes: Error codes for trait bound violations, diagnostic quality
- Automatic derivation: When derivation happens, can it be overridden
- Pointer types: Which pointer types, can they be made Send/Sync

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1002 is a LEAF (line 11630) defining Send/Sync trait enforcement. Types that should be Send/Sync but aren't: Compiler error (ERR-SEND-001) if type used across threads but not Send/Sync. Unsafe implementations: Can manually implement Send/Sync in unsafe blocks (programmer responsible for safety), warning (WARN-SEND-001) for unsafe implementations. Phantom data: PhantomData<T> is Send/Sync if T is Send/Sync. Automatic derivation: Compiler automatically derives Send/Sync for types where all fields are Send/Sync, happens during type checking, can be overridden: Manual impl in unsafe block. Pointer types: Raw pointers (*const T, *mut T) are not Send/Sync by default, can be made Send/Sync: Manual impl in unsafe block (programmer responsible).
- Inferred-from-pattern: Send/Sync LEAFs in leafs.txt follow Rust-like patterns. Automatic derivation is standard. Unsafe implementations are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Types that should be Send/Sync but aren't: Compiler error (ERR-SEND-001) if type used across threads but not Send/Sync (e.g., `spawn(|| { use_non_send_type(); })`). Unsafe implementations: Can manually implement Send/Sync in unsafe blocks (programmer responsible for safety), warning (WARN-SEND-001) for unsafe implementations. Phantom data: PhantomData<T> is Send/Sync if T is Send/Sync (follows type parameter).
- Failure modes: Error codes: ERR-SEND-001 for trait bound violation (type not Send/Sync), ERR-SYNC-001 for Sync violation. Diagnostic quality: Detailed error messages (why type is not Send/Sync, which field prevents Send/Sync), suggestions (how to make type Send/Sync).
- Automatic derivation: When derivation happens: During type checking (compiler analyzes type structure). Can it be overridden: Yes, manual impl in unsafe block (e.g., `unsafe impl Send for MyType {}`), warning (WARN-SEND-001) for unsafe implementations.
- Pointer types: Which pointer types: Raw pointers (*const T, *mut T) are not Send/Sync by default. Can they be made Send/Sync: Yes, manual impl in unsafe block (programmer responsible for safety), warning (WARN-SEND-001).
- Error codes: ERR-SEND-001 for Send trait bound violation, ERR-SYNC-001 for Sync trait bound violation, WARN-SEND-001 for unsafe Send/Sync implementations.
- Test requirements: Test types that should be Send/Sync but aren't (errors), test unsafe implementations (warnings), test Phantom data (Send/Sync propagation), test automatic derivation (all field types), test pointer types (not Send/Sync by default, can be made Send/Sync).
**Canonical Rationale:**
SPEC-LANG-1002 defines Send/Sync trait enforcement with complete edge case handling (types that should be Send/Sync, unsafe implementations, Phantom data), failure modes (error codes, diagnostic quality), automatic derivation rules (when, can be overridden), and pointer type behavior (not Send/Sync by default, can be made Send/Sync). The specification is complete for Send/Sync trait enforcement implementation.

Cross-File Adjustments (if any):
- Send/Sync trait enforcement uses SPEC-LANG-0200 series (Type Checking) for trait checking.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1003: Synchronization Primitives (Mutex, Channels)
================================================================================

**LEAF Definition (Line 11672-11709):**
- Kind: LEAF
- Source: REQ-339, REQ-340, SSOT Section 11.0
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-1003 defines synchronization primitives. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Deadlock prevention
   - Lock ordering
   - Channel buffer overflow
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for different failures
   - Panic behavior
3. **RAII guards**: "RAII guards" mentioned but not specified:
   - How do guards work?
   - What happens on panic?
4. **mpsc channels**: "multi-producer, single-consumer" doesn't specify:
   - Buffer size
   - Blocking vs non-blocking
   - Error handling

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and channel details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering deadlocks and buffer overflow.
2. Add "Failure modes" section with error codes.
3. Specify RAII guard behavior.
4. Define channel semantics in detail.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1003
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Deadlock prevention, lock ordering, channel buffer overflow
- Failure modes: Error codes for different failures, panic behavior
- RAII guards: How guards work, what happens on panic
- mpsc channels: Buffer size, blocking vs non-blocking, error handling

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1003 is a LEAF (line 11672) defining synchronization primitives. Deadlock prevention: No automatic prevention (programmer responsible), deadlock detection: Not supported (would be too expensive). Lock ordering: No enforced ordering (programmer responsible), best practice: Consistent lock ordering. Channel buffer overflow: Error (ERR-CHAN-001) if buffer full (blocking send), or return error (non-blocking send). RAII guards: Guards automatically unlock on drop (even on panic), syntax: `let guard = mutex.lock();` (guard holds lock), drop guard: Lock released. Panic behavior: Panic in critical section: Lock released (guard dropped), other threads can proceed. mpsc channels: Buffer size: Configurable (default: unbounded), blocking: `send()` blocks if buffer full, non-blocking: `try_send()` returns error if buffer full, error handling: Error (ERR-CHAN-001) for send failures.
- Inferred-from-pattern: Synchronization LEAFs in leafs.txt follow Rust-like patterns. RAII guards are standard. mpsc channels are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Deadlock prevention: No automatic prevention (programmer responsible for avoiding deadlocks), deadlock detection: Not supported (would be too expensive). Lock ordering: No enforced ordering (programmer responsible), best practice: Consistent lock ordering to avoid deadlocks. Channel buffer overflow: Error (ERR-CHAN-001) if buffer full (blocking send blocks, non-blocking send returns error).
- Failure modes: Error codes: ERR-CHAN-001 for channel send failure (buffer full), ERR-MUTEX-001 for mutex lock failure (poisoned mutex). Panic behavior: Panic in critical section: Lock released (guard dropped), mutex marked as poisoned (ERR-MUTEX-001 for subsequent lock attempts), other threads can proceed.
- RAII guards: How guards work: Guards automatically unlock on drop (even on panic), syntax: `let guard = mutex.lock();` (guard holds lock, type: `MutexGuard<T>`), drop guard: Lock released automatically. What happens on panic: Guard dropped, lock released, mutex marked as poisoned.
- mpsc channels: Buffer size: Configurable (default: unbounded, can specify: `channel::<T>(buffer_size)`). Blocking vs non-blocking: Blocking: `send(value)` blocks if buffer full, non-blocking: `try_send(value)` returns error if buffer full (ERR-CHAN-001). Error handling: Error (ERR-CHAN-001) for send failures (buffer full, receiver dropped).
- Error codes: ERR-CHAN-001 for channel send failure, ERR-MUTEX-001 for mutex lock failure (poisoned mutex).
- Test requirements: Test deadlock scenarios (no automatic prevention), test lock ordering (no enforced ordering), test channel buffer overflow (errors), test RAII guards (automatic unlock, panic behavior), test mpsc channels (buffer size, blocking/non-blocking, error handling).
**Canonical Rationale:**
SPEC-LANG-1003 defines synchronization primitives with complete edge case handling (deadlocks, lock ordering, channel buffer overflow), failure modes (error codes, panic behavior), RAII guard behavior (automatic unlock, panic handling), and mpsc channel semantics (buffer size, blocking/non-blocking, error handling). The specification is complete for synchronization primitives implementation.

Cross-File Adjustments (if any):
- RAII guards use SPEC-LANG-0315 (RAII and Deterministic Destruction) for automatic cleanup.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1004: Structured Concurrency (async with)
================================================================================

**LEAF Definition (Line 11710-11753):**
- Kind: LEAF
- Source: REQ-341, REQ-342, SSOT Section 11.0
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-1004 defines structured concurrency. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Nested async with blocks
   - Task cancellation edge cases
   - Resource cleanup on cancellation
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for different failures
   - Cancellation token behavior
3. **Compiler-enforced guarantee**: "Compiler-enforced guarantee" doesn't specify:
   - How is it enforced?
   - Compile-time? Runtime?
4. **Automatic cancellation**: "automatic cancellation of sibling tasks" doesn't specify:
   - How is cancellation propagated?
   - What about cleanup?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and enforcement details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering nested blocks and cancellation.
2. Add "Failure modes" section with error codes.
3. Specify compiler enforcement mechanism.
4. Define cancellation propagation.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1004
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Nested async with blocks, task cancellation edge cases, resource cleanup on cancellation
- Failure modes: Error codes for different failures, cancellation token behavior
- Compiler-enforced guarantee: How it is enforced, compile-time vs runtime
- Automatic cancellation: How cancellation is propagated, what about cleanup

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1004 is a LEAF (line 11710) defining structured concurrency. Nested async with blocks: Supported (nested scopes), each scope manages its own tasks. Task cancellation edge cases: Cancellation propagates to all sibling tasks, parent task waits for all children. Resource cleanup on cancellation: Cleanup handlers called (defer blocks, drop handlers), resources released. Compiler-enforced guarantee: Compile-time enforcement (borrow checker ensures all tasks complete before scope exits), error if task escapes scope. Automatic cancellation: Cancellation propagated via cancellation token (shared between parent and children), cleanup: Defer blocks and drop handlers called on cancellation.
- Inferred-from-pattern: Structured concurrency LEAFs in leafs.txt follow structured concurrency patterns. Compiler enforcement is compile-time. Cancellation propagation is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Nested async with blocks: Supported (nested scopes: `async with { async with { ... } }`), each scope manages its own tasks, parent waits for all children. Task cancellation edge cases: Cancellation propagates to all sibling tasks (if one task fails, all siblings cancelled), parent task waits for all children (blocking wait). Resource cleanup on cancellation: Cleanup handlers called (defer blocks executed, drop handlers called), resources released (RAII cleanup).
- Failure modes: Error codes: ERR-ASYNC-001 for task failure, ERR-ASYNC-002 for cancellation failure. Cancellation token behavior: Cancellation token shared between parent and children, checked periodically (cooperative cancellation), error if cancellation requested.
- Compiler-enforced guarantee: How it is enforced: Compile-time enforcement (borrow checker ensures all tasks complete before scope exits), error if task escapes scope (lifetime violation). Compile-time vs runtime: Compile-time (borrow checker), no runtime checks needed.
- Automatic cancellation: How cancellation is propagated: Cancellation propagated via cancellation token (shared between parent and children), parent cancels all children if one fails. What about cleanup: Defer blocks and drop handlers called on cancellation (RAII cleanup), resources released.
- Error codes: ERR-ASYNC-001 for task failure, ERR-ASYNC-002 for cancellation failure.
- Test requirements: Test nested async with blocks (nested scopes), test task cancellation (propagation, cleanup), test resource cleanup on cancellation (defer blocks, drop handlers), test compiler enforcement (compile-time errors), test cancellation propagation (token sharing).
**Canonical Rationale:**
SPEC-LANG-1004 defines structured concurrency with complete edge case handling (nested blocks, cancellation, resource cleanup), failure modes (error codes, cancellation token behavior), compiler enforcement mechanism (compile-time, borrow checker), and cancellation propagation (token sharing, cleanup). The specification is complete for structured concurrency implementation.

Cross-File Adjustments (if any):
- Compiler enforcement uses SPEC-LANG-0300 series (Ownership and Borrowing) for borrow checking.
- Resource cleanup uses SPEC-LANG-0315 (RAII and Deterministic Destruction) for automatic cleanup.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1005: Task Cancellation and Detached Tasks
================================================================================

**LEAF Definition (Line 11754-11789):**
- Kind: LEAF
- Source: REQ-342, REQ-343, SSOT Section 11.0
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-1005 defines task cancellation and detached tasks. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Cancellation during critical sections
   - Detached task cleanup
   - Resource leaks
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for cancellation failures
3. **Cooperative cancellation**: "cooperative cancellation" doesn't specify:
   - How is cooperation enforced?
   - What if a task doesn't check?
4. **Safety warnings**: "with safety warnings" doesn't specify:
   - What are the warnings?
   - When are they issued?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and cancellation details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering cancellation edge cases.
2. Add "Failure modes" section with error codes.
3. Specify cooperative cancellation mechanism.
4. Define safety warnings.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1005
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Cancellation during critical sections, detached task cleanup, resource leaks
- Failure modes: Error codes for cancellation failures
- Cooperative cancellation: How cooperation is enforced, what if task doesn't check
- Safety warnings: What are the warnings, when are they issued

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1005 is a LEAF (line 11754) defining task cancellation and detached tasks. Cancellation during critical sections: Cancellation checked at cancellation points (not in critical sections), critical sections protected from cancellation. Detached task cleanup: Detached tasks cleaned up on program exit (no explicit cleanup), resource leaks: Warning (WARN-TASK-001) if resources not cleaned up. Cooperative cancellation: Cancellation checked at cancellation points (await, yield, etc.), not enforced (programmer responsible), no automatic cancellation. Safety warnings: Warning (WARN-TASK-002) for detached tasks (potential resource leaks), warning (WARN-TASK-003) for tasks that don't check cancellation.
- Inferred-from-pattern: Task cancellation LEAFs in leafs.txt follow cooperative cancellation patterns. Safety warnings are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Cancellation during critical sections: Cancellation checked at cancellation points (await, yield, etc.), not in critical sections (critical sections protected from cancellation). Detached task cleanup: Detached tasks cleaned up on program exit (no explicit cleanup, OS cleanup), resource leaks: Warning (WARN-TASK-001) if resources not cleaned up (detected via static analysis). Resource leaks: Detached tasks may leak resources if not properly cleaned up (warning issued).
- Failure modes: Error codes: ERR-TASK-001 for cancellation failure (if cancellation cannot be completed), ERR-TASK-002 for detached task failure (if detached task panics).
- Cooperative cancellation: How cooperation is enforced: Cancellation checked at cancellation points (await, yield, etc.), not enforced (programmer responsible for checking). What if task doesn't check: Task continues running (no automatic cancellation), warning (WARN-TASK-003) if task doesn't check cancellation (detected via static analysis).
- Safety warnings: What are the warnings: WARN-TASK-001 for potential resource leaks (detached tasks), WARN-TASK-002 for detached tasks (safety concern), WARN-TASK-003 for tasks that don't check cancellation. When are they issued: At compile-time (static analysis) or runtime (if detected).
- Error codes: ERR-TASK-001 for cancellation failure, ERR-TASK-002 for detached task failure, WARN-TASK-001 for potential resource leaks, WARN-TASK-002 for detached tasks, WARN-TASK-003 for tasks that don't check cancellation.
- Test requirements: Test cancellation during critical sections (protected), test detached task cleanup (OS cleanup), test resource leaks (warnings), test cooperative cancellation (cancellation points), test safety warnings (compile-time, runtime).
**Canonical Rationale:**
SPEC-LANG-1005 defines task cancellation and detached tasks with complete edge case handling (cancellation during critical sections, detached task cleanup, resource leaks), failure modes (error codes), cooperative cancellation mechanism (cancellation points, not enforced), and safety warnings (what, when). The specification is complete for task cancellation and detached tasks implementation.

Cross-File Adjustments (if any):
- Safety warnings use SPEC-QUARRY-0033 (Multi-level Linter) for static analysis.
=== END RESOLUTION APPENDIX ===


================================================================================
SPEC-LANG-1101: Structured Logging API
================================================================================

**LEAF Definition (Line 11810-11855):**
- Kind: LEAF
- Source: REQ-344, REQ-345, REQ-347, SSOT Section 9.17
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-1101 defines structured logging API. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Very large log messages
   - Circular references in structured data
   - Special characters in keys/values
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for logging failures
   - What happens if logging fails?
3. **Type-checking**: "type-checked against the provided schema" doesn't specify:
   - What is the schema format?
   - How is it defined?
4. **Compile-time feature flags**: "compile-time feature flags" doesn't specify:
   - How are flags configured?
   - What is the syntax?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and schema details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering large messages and circular references.
2. Add "Failure modes" section with error codes.
3. Specify schema format and definition.
4. Define compile-time feature flag mechanism.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1101
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Very large log messages, circular references in structured data, special characters in keys/values
- Failure modes: Error codes for logging failures, what happens if logging fails
- Type-checking: Schema format, how it is defined
- Compile-time feature flags: How flags are configured, syntax

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1101 is a LEAF (line 11810) defining structured logging API. Very large log messages: Truncated if exceeds limit (default: 1MB), warning (WARN-LOG-001) if truncated. Circular references: Error (ERR-LOG-001) if circular reference detected (serialization fails). Special characters: Escaped in keys/values (JSON-style escaping). Logging failures: Error (ERR-LOG-002) if logging fails (e.g., disk full), fallback: Log to stderr. Schema format: JSON Schema (standard), defined via `@log_schema` attribute or separate schema file. Compile-time feature flags: `@cfg(log_level = "debug")` for conditional logging, syntax: `@cfg(log_level = "...")` attribute.
- Inferred-from-pattern: Logging LEAFs in leafs.txt follow standard logging patterns. JSON Schema is standard. Compile-time feature flags are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Very large log messages: Truncated if exceeds limit (default: 1MB per message), warning (WARN-LOG-001) if truncated. Circular references: Error (ERR-LOG-001) if circular reference detected (serialization fails, cannot serialize circular data). Special characters: Escaped in keys/values (JSON-style escaping: `\"`, `\\`, `\n`, etc.).
- Failure modes: Error codes: ERR-LOG-001 for circular reference, ERR-LOG-002 for logging failure (disk full, permission denied, etc.). What happens if logging fails: Fallback to stderr (last resort), error logged to stderr if primary logging fails.
- Type-checking: Schema format: JSON Schema (standard JSON Schema format), defined via `@log_schema` attribute (inline schema) or separate schema file (`.schema.json`). How it is defined: `@log_schema({ "type": "object", "properties": { ... } })` or `log_schema!("path/to/schema.json")`.
- Compile-time feature flags: How flags are configured: `@cfg(log_level = "debug")` for conditional logging, syntax: `@cfg(log_level = "...")` attribute (log_level: "trace", "debug", "info", "warn", "error"). Feature flags: `@cfg(feature = "logging")` for feature-based logging.
- Error codes: ERR-LOG-001 for circular reference, ERR-LOG-002 for logging failure, WARN-LOG-001 for truncated message.
- Test requirements: Test very large log messages (truncation), test circular references (errors), test special characters (escaping), test logging failures (fallback), test schema format (JSON Schema), test compile-time feature flags (conditional logging).
**Canonical Rationale:**
SPEC-LANG-1101 defines structured logging API with complete edge case handling (large messages, circular references, special characters), failure modes (error codes, fallback), schema format (JSON Schema, definition methods), and compile-time feature flags (syntax, configuration). The specification is complete for structured logging API implementation.

Cross-File Adjustments (if any):
- Schema format uses JSON Schema (standard).
- Compile-time feature flags use SPEC-LANG-0241 (Conditional Compilation).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1102: Distributed Tracing Spans
================================================================================

**LEAF Definition (Line 11856-11902):**
- Kind: LEAF
- Source: REQ-345, REQ-347, SSOT Section 9.17
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-1102 defines distributed tracing spans. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Very deep span hierarchies
   - Span context propagation failures
   - Clock skew in distributed systems
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for propagation failures
3. **Trace context propagation**: "propagation of trace context across thread boundaries" doesn't specify:
   - How is context propagated?
   - What format? (W3C Trace Context?)
4. **Type-safe attributes**: "type-safe and validated at compile time" doesn't specify:
   - What types are supported?
   - Validation rules?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and propagation details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering deep hierarchies and clock skew.
2. Add "Failure modes" section with error codes.
3. Specify trace context propagation format.
4. Define type-safe attribute system.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1102
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Very deep span hierarchies, span context propagation failures, clock skew in distributed systems
- Failure modes: Error codes for propagation failures
- Trace context propagation: How context is propagated, what format (W3C Trace Context?)
- Type-safe attributes: What types are supported, validation rules

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1102 is a LEAF (line 11856) defining distributed tracing spans. Very deep span hierarchies: Limited to max depth (default: 100 spans), warning (WARN-TRACE-001) if limit exceeded. Span context propagation failures: Error (ERR-TRACE-001) if propagation fails (invalid context, network error). Clock skew: Handled by trace system (uses local clock, skew correction in exporter). Trace context propagation: W3C Trace Context format (standard), propagated via headers (HTTP) or context (thread-local). Type-safe attributes: Supported types: String, int, float, bool, validation: Compile-time type checking, error if invalid type.
- Inferred-from-pattern: Tracing LEAFs in leafs.txt follow OpenTelemetry patterns. W3C Trace Context is standard. Type-safe attributes are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Very deep span hierarchies: Limited to max depth (default: 100 spans per trace), warning (WARN-TRACE-001) if limit exceeded. Span context propagation failures: Error (ERR-TRACE-001) if propagation fails (invalid context format, network error, etc.). Clock skew: Handled by trace system (uses local clock for timestamps, skew correction in exporter if needed).
- Failure modes: Error codes: ERR-TRACE-001 for span context propagation failure, ERR-TRACE-002 for span creation failure.
- Trace context propagation: How context is propagated: W3C Trace Context format (standard W3C Trace Context specification), propagated via headers (HTTP: `traceparent`, `tracestate` headers) or context (thread-local context for same-process propagation). What format: W3C Trace Context (standard format: `traceparent: 00-<trace-id>-<parent-id>-<flags>`).
- Type-safe attributes: What types are supported: String, int, float, bool (primitive types), arrays of primitives. Validation rules: Compile-time type checking (error if invalid type), runtime validation (error if value out of range).
- Error codes: ERR-TRACE-001 for span context propagation failure, ERR-TRACE-002 for span creation failure, WARN-TRACE-001 for span depth limit exceeded.
- Test requirements: Test very deep span hierarchies (depth limits), test span context propagation failures (errors), test clock skew (handling), test trace context propagation (W3C format), test type-safe attributes (validation).
**Canonical Rationale:**
SPEC-LANG-1102 defines distributed tracing spans with complete edge case handling (deep hierarchies, propagation failures, clock skew), failure modes (error codes), trace context propagation (W3C Trace Context format, propagation methods), and type-safe attribute system (supported types, validation rules). The specification is complete for distributed tracing spans implementation.

Cross-File Adjustments (if any):
- Trace context propagation uses W3C Trace Context format (standard).
- Type-safe attributes use SPEC-LANG-0200 series (Type Checking) for compile-time validation.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1103: Type-safe Metrics Collection
================================================================================

**LEAF Definition (Line 11903-11942):**
- Kind: LEAF
- Source: REQ-345, REQ-347, SSOT Section 9.17
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-1103 defines type-safe metrics collection. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Metric name collisions
   - Very high-frequency updates
   - Label cardinality explosion
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for metric failures
3. **Type-safety**: "Enforce type-safety for metric labels and values" doesn't specify:
   - What types are supported?
   - How is type-safety enforced?
4. **Thread-local buffers**: "thread-local buffers" mentioned but not specified:
   - How do buffers work?
   - When are they flushed?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and buffer details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering collisions and cardinality.
2. Add "Failure modes" section with error codes.
3. Specify type-safety mechanism.
4. Define thread-local buffer behavior.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1103
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Metric name collisions, very high-frequency updates, label cardinality explosion
- Failure modes: Error codes for metric failures
- Type-safety: What types are supported, how is type-safety enforced
- Thread-local buffers: How buffers work, when are they flushed

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1103 is a LEAF (line 11903) defining type-safe metrics collection. Metric name collisions: Error (ERR-METRIC-001) if metric name already exists (compile-time or runtime check). Very high-frequency updates: Buffered in thread-local buffer (reduces contention), flushed periodically (every 1 second or 1000 updates). Label cardinality explosion: Warning (WARN-METRIC-001) if label cardinality exceeds limit (default: 10000 unique label combinations). Type-safety: Supported types: Counter (int, float), Gauge (int, float), Histogram (int, float), enforced at compile-time (type checking). Thread-local buffers: Each thread has own buffer (reduces contention), flushed periodically (every 1 second) or on buffer full (1000 updates).
- Inferred-from-pattern: Metrics LEAFs in leafs.txt follow OpenTelemetry patterns. Thread-local buffers are standard. Type-safety is compile-time.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Metric name collisions: Error (ERR-METRIC-001) if metric name already exists (compile-time check if possible, runtime check otherwise). Very high-frequency updates: Buffered in thread-local buffer (reduces contention on shared metric storage), flushed periodically (every 1 second or 1000 updates, whichever comes first). Label cardinality explosion: Warning (WARN-METRIC-001) if label cardinality exceeds limit (default: 10000 unique label combinations per metric), metric may be dropped if limit exceeded.
- Failure modes: Error codes: ERR-METRIC-001 for metric name collision, ERR-METRIC-002 for metric update failure (buffer full, etc.).
- Type-safety: What types are supported: Counter (int, float), Gauge (int, float), Histogram (int, float), Summary (int, float). How is type-safety enforced: Compile-time type checking (error if invalid type), runtime validation (error if value out of range).
- Thread-local buffers: How buffers work: Each thread has own buffer (thread-local storage, reduces contention on shared metric storage), buffer stores metric updates (key-value pairs: metric name, labels, value). When are they flushed: Flushed periodically (every 1 second, background task), or on buffer full (1000 updates, immediate flush), or on thread exit (final flush).
- Error codes: ERR-METRIC-001 for metric name collision, ERR-METRIC-002 for metric update failure, WARN-METRIC-001 for label cardinality limit exceeded.
- Test requirements: Test metric name collisions (errors), test very high-frequency updates (buffering), test label cardinality explosion (warnings), test type-safety (compile-time errors), test thread-local buffers (flushing behavior).
**Canonical Rationale:**
SPEC-LANG-1103 defines type-safe metrics collection with complete edge case handling (name collisions, high-frequency updates, label cardinality), failure modes (error codes), type-safety mechanism (supported types, compile-time enforcement), and thread-local buffer behavior (how buffers work, flushing). The specification is complete for type-safe metrics collection implementation.

Cross-File Adjustments (if any):
- Type-safety uses SPEC-LANG-0200 series (Type Checking) for compile-time validation.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1104: OpenTelemetry Compatible Exporters
================================================================================

**LEAF Definition (Line 11943-11986):**
- Kind: LEAF
- Source: REQ-346, REQ-348, SSOT Section 9.17
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-1104 defines OpenTelemetry compatible exporters. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Exporter failures
   - Network timeouts
   - Batch size limits
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for export failures
   - Retry strategies
3. **Pluggable trait**: "pluggable TelemetryExporter trait" doesn't specify:
   - What is the trait interface?
   - What methods are required?
4. **Background task**: "run in a background task" doesn't specify:
   - How is the task managed?
   - Resource limits?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and trait details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering exporter failures.
2. Add "Failure modes" section with error codes and retries.
3. Specify TelemetryExporter trait interface.
4. Define background task management.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1104
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Exporter failures, network timeouts, batch size limits
- Failure modes: Error codes for export failures, retry strategies
- Pluggable trait: TelemetryExporter trait interface, required methods
- Background task: How task is managed, resource limits

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1104 is a LEAF (line 11943) defining OpenTelemetry compatible exporters. Exporter failures: Error (ERR-EXPORT-001) if export fails (network error, invalid data), retry with exponential backoff (3 retries). Network timeouts: Timeout error (ERR-EXPORT-002) if network timeout (default: 30 seconds), retry with exponential backoff. Batch size limits: Batched exports (default: 1000 spans/metrics per batch), error if batch too large (ERR-EXPORT-003). TelemetryExporter trait: `trait TelemetryExporter { fn export_spans(&self, spans: &[Span]) -> Result<(), ExportError>; fn export_metrics(&self, metrics: &[Metric]) -> Result<(), ExportError>; }`. Background task: Managed by runtime (dedicated thread or async task), resource limits: Max memory (default: 100MB), max queue size (default: 10000 items).
- Inferred-from-pattern: Exporter LEAFs in leafs.txt follow OpenTelemetry patterns. TelemetryExporter trait is standard. Background tasks are standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Exporter failures: Error (ERR-EXPORT-001) if export fails (network error, invalid data, etc.), retry with exponential backoff (3 retries, max 30 seconds). Network timeouts: Timeout error (ERR-EXPORT-002) if network timeout (default: 30 seconds), retry with exponential backoff. Batch size limits: Batched exports (default: 1000 spans/metrics per batch), error if batch too large (ERR-EXPORT-003, batch split if possible).
- Failure modes: Error codes: ERR-EXPORT-001 for export failure, ERR-EXPORT-002 for network timeout, ERR-EXPORT-003 for batch too large. Retry strategies: Exponential backoff (initial: 1 second, max: 30 seconds, 3 retries), retry on transient errors (network errors), no retry on permanent errors (invalid data).
- Pluggable trait: TelemetryExporter trait interface: `trait TelemetryExporter { fn export_spans(&self, spans: &[Span]) -> Result<(), ExportError>; fn export_metrics(&self, metrics: &[Metric]) -> Result<(), ExportError>; fn shutdown(&self) -> Result<(), ExportError>; }`. Required methods: `export_spans`, `export_metrics`, `shutdown` (cleanup).
- Background task: How task is managed: Managed by runtime (dedicated thread or async task), task runs continuously (polling for exports), shutdown on program exit. Resource limits: Max memory (default: 100MB for export buffer), max queue size (default: 10000 items in export queue), error if limits exceeded (ERR-EXPORT-004).
- Error codes: ERR-EXPORT-001 for export failure, ERR-EXPORT-002 for network timeout, ERR-EXPORT-003 for batch too large, ERR-EXPORT-004 for resource limit exceeded.
- Test requirements: Test exporter failures (retries), test network timeouts (retries), test batch size limits (splitting), test TelemetryExporter trait (interface), test background task (management, resource limits).
**Canonical Rationale:**
SPEC-LANG-1104 defines OpenTelemetry compatible exporters with complete edge case handling (exporter failures, network timeouts, batch size limits), failure modes (error codes, retry strategies), TelemetryExporter trait interface (required methods), and background task management (task management, resource limits). The specification is complete for OpenTelemetry compatible exporters implementation.

Cross-File Adjustments (if any):
- Background task uses SPEC-LANG-1000 series (Concurrency) for task management.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1201: Native C FFI (extern)
================================================================================

**LEAF Definition (Line 12003-12040):**
- Kind: LEAF
- Source: REQ-353, SSOT Section 11.1
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-1201 defines native C FFI. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - ABI mismatches
   - Calling convention mismatches
   - Type size mismatches
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for FFI failures
   - Runtime errors
3. **Type safety**: "manual type translation" doesn't specify:
   - What types can be translated?
   - What are the translation rules?
4. **Linking**: "linking against static and dynamic C libraries" doesn't specify:
   - How is linking configured?
   - Platform-specific behavior?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and type translation.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering ABI and calling convention mismatches.
2. Add "Failure modes" section with error codes.
3. Specify type translation rules.
4. Define linking configuration.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1201
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: ABI mismatches, calling convention mismatches, type size mismatches
- Failure modes: Error codes for FFI failures, runtime errors
- Type safety: What types can be translated, translation rules
- Linking: How linking is configured, platform-specific behavior

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1201 is a LEAF (line 12003) defining native C FFI. ABI mismatches: Compile-time error (ERR-FFI-001) if ABI mismatch detected (platform-specific), runtime error if not detected. Calling convention mismatches: Compile-time error (ERR-FFI-002) if calling convention mismatch (e.g., `extern "C"` vs `extern "stdcall"`). Type size mismatches: Compile-time error (ERR-FFI-003) if type size mismatch (e.g., `int` size differs). Type translation: Supported types: `int` -> `i32`, `long` -> `i64`, `float` -> `f32`, `double` -> `f64`, `char*` -> `*const u8`, `void*` -> `*mut ()`. Linking: Configured via `Quarry.toml` (`[dependencies]` section) or CLI flags (`-l` for libraries), platform-specific: `.a` on Unix, `.lib` on Windows.
- Inferred-from-pattern: FFI LEAFs in leafs.txt follow standard FFI patterns. Type translation is standard. Linking configuration is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: ABI mismatches: Compile-time error (ERR-FFI-001) if ABI mismatch detected (platform-specific ABI checks), runtime error if not detected (undefined behavior). Calling convention mismatches: Compile-time error (ERR-FFI-002) if calling convention mismatch (e.g., `extern "C"` vs `extern "stdcall"` on Windows), must match function declaration. Type size mismatches: Compile-time error (ERR-FFI-003) if type size mismatch (e.g., `int` size differs between platforms), size checked at compile-time.
- Failure modes: Error codes: ERR-FFI-001 for ABI mismatch, ERR-FFI-002 for calling convention mismatch, ERR-FFI-003 for type size mismatch, ERR-FFI-004 for runtime FFI failure (function not found, etc.). Runtime errors: Panic if FFI call fails (e.g., function not found, invalid arguments), error handling via Result type if possible.
- Type safety: What types can be translated: Primitive types: `int` -> `i32`, `long` -> `i64`, `float` -> `f32`, `double` -> `f64`, `char` -> `u8`, `char*` -> `*const u8`, `void*` -> `*mut ()`. Translation rules: Size must match (compile-time check), alignment must match (compile-time check), signed/unsigned preserved.
- Linking: How linking is configured: Configured via `Quarry.toml` (`[dependencies]` section: `libc = { path = "...", link = "static" }`) or CLI flags (`-l` for libraries: `-l pthread`). Platform-specific behavior: Static libraries: `.a` on Unix, `.lib` on Windows, dynamic libraries: `.so` on Linux, `.dylib` on macOS, `.dll` on Windows.
- Error codes: ERR-FFI-001 for ABI mismatch, ERR-FFI-002 for calling convention mismatch, ERR-FFI-003 for type size mismatch, ERR-FFI-004 for runtime FFI failure.
- Test requirements: Test ABI mismatches (compile-time errors), test calling convention mismatches (errors), test type size mismatches (errors), test type translation (all types), test linking configuration (static/dynamic, platform-specific).
**Canonical Rationale:**
SPEC-LANG-1201 defines native C FFI with complete edge case handling (ABI mismatches, calling convention mismatches, type size mismatches), failure modes (error codes, runtime errors), type translation rules (supported types, translation rules), and linking configuration (how configured, platform-specific behavior). The specification is complete for native C FFI implementation.

Cross-File Adjustments (if any):
- Linking configuration uses SPEC-QUARRY-0000 series (Build System) for dependency management.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1202: Python Interoperability Strategy
================================================================================

**LEAF Definition (Line 12063-12098):**
- Kind: LEAF
- Source: REQ-355, REQ-380, REQ-381, REQ-382, REQ-394, SSOT Section 11.4
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-1202 defines Python interoperability strategy. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Python version compatibility
   - GIL acquisition failures
   - Exception translation edge cases
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for interop failures
3. **Optional runtime dependency**: "optional Python runtime dependency" doesn't specify:
   - How is optionality handled?
   - Compile-time? Runtime?
4. **Zero-copy transfer**: "zero-copy data transfer" doesn't specify:
   - When is it possible?
   - What are the constraints?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and optionality details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering Python version and GIL issues.
2. Add "Failure modes" section with error codes.
3. Specify optional runtime dependency mechanism.
4. Define zero-copy transfer constraints.

================================================================================
SPEC-LANG-1203: FFI Function Pointers and Callbacks
================================================================================

**LEAF Definition (Line 12041-12062):**
- Kind: LEAF
- Source: REQ-393, SSOT Section 14.2
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-1203 defines FFI function pointers and callbacks. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", "Dependencies", "User-facing behavior", or "Tests required" sections.
2. **Function pointer types**: "function pointer types" doesn't specify:
   - What is the syntax?
   - How are they declared?
3. **ABI translation**: "correct ABI translation" doesn't specify:
   - What are the translation rules?
   - Calling convention handling?
4. **Safety guarantees**: No mention of safety guarantees or restrictions.

**Verdict:** INCOMPLETE - Extremely minimal, missing all standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify function pointer syntax and declaration.
3. Define ABI translation rules.
4. Add safety guarantees and restrictions.

================================================================================
SPEC-LANG-1301: Performance-documented Standard Library
================================================================================

**LEAF Definition (Line 12115-12138):**
- Kind: LEAF
- Source: REQ-321, REQ-377, SSOT Section 9.12
- Status: PLANNED
- Priority: P3

**Analysis:**
SPEC-LANG-1301 defines performance-documented standard library. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Documentation format**: "includes time/space complexity" doesn't specify:
   - What is the documentation format?
   - Where is it located?
3. **Typical execution times**: "Typical execution times on common hardware" doesn't specify:
   - What hardware?
   - What are the units?
   - How are they measured?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify documentation format and location.
3. Define typical execution time measurement methodology.
4. Add examples of performance documentation.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1301
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Documentation format: What format, where located
- Typical execution times: What hardware, units, measurement methodology

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1301 is a LEAF (line 12115) defining performance-documented standard library. Documentation format: Markdown format in doc comments (inline documentation), also in separate performance documentation files (`.perf.md`). Location: Inline in source code (doc comments), separate files in `docs/performance/` directory. Typical execution times: Hardware: Common hardware (Intel x86_64, ARM64), units: Nanoseconds, microseconds, milliseconds (as appropriate), measurement: Benchmark suite (SPEC-QUARRY-0016 for test runner, benchmarks run on CI). Missing sections can be inferred from documentation patterns.
- Inferred-from-pattern: Documentation LEAFs in leafs.txt specify documentation standards. Performance documentation follows standard documentation patterns. Benchmarking uses test runner infrastructure.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Documentation format: Format: Markdown format in doc comments (inline documentation: `/// Performance: O(n) time, O(1) space`), also in separate performance documentation files (`.perf.md` files in `docs/performance/` directory). Where located: Inline in source code (doc comments above functions/types), separate files in `docs/performance/` directory (organized by module).
- Typical execution times: What hardware: Common hardware platforms (Intel x86_64, ARM64, typical configurations), specified in documentation (e.g., "Intel i7-9700K, 3.0 GHz"). Units: Nanoseconds (for fast operations), microseconds (for medium operations), milliseconds (for slow operations), as appropriate. How measured: Benchmark suite (SPEC-QUARRY-0016 for test runner, benchmarks run on CI), measurements taken on standard hardware, documented in performance docs.
- Semantics: Performance documentation provides time/space complexity and typical execution times for standard library functions. Documentation is part of standard library API documentation.
- Edge cases: Missing performance documentation: Warning (WARN-PERF-001) if function lacks performance documentation, not error. Outdated documentation: Manual review process, not automated.
- Failure modes: WARN-PERF-001 for missing performance documentation (warning, not error).
- Examples: `/// Performance: O(n) time where n is length, O(1) space` (inline doc comment), separate `.perf.md` file with detailed benchmarks.
- Implementation notes: Performance documentation is maintained alongside code. Benchmarks are run on CI to verify documented performance.
- Dependencies: SPEC-QUARRY-0016 (Test Runner) for benchmark execution.
- Tests required: Test that performance documentation exists for all public functions, test that documented performance matches benchmarks.
**Canonical Rationale:**
SPEC-LANG-1301 defines performance-documented standard library with complete documentation format specification (Markdown, inline and separate files), typical execution time methodology (hardware, units, measurement), and missing sections added. The specification is complete for performance documentation implementation.

Cross-File Adjustments (if any):
- Benchmark execution uses SPEC-QUARRY-0016 (Test Runner).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1302: Educational Performance Cookbook
================================================================================

**LEAF Definition (Line 12139-12158):**
- Kind: LEAF
- Source: REQ-322, REQ-325, REQ-326, SSOT Section 9.12
- Status: PLANNED
- Priority: P3

**Analysis:**
SPEC-LANG-1302 defines educational performance cookbook. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Repository structure**: "official Performance Cookbook repository" doesn't specify:
   - What is the structure?
   - How is it organized?
3. **Self-contained examples**: "self-contained, runnable examples" doesn't specify:
   - What format?
   - How are they tested?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify repository structure and organization.
3. Define example format and testing.
4. Add examples of cookbook entries.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1302
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Repository structure: Structure, organization
- Self-contained examples: Format, testing

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1302 is a LEAF (line 12139) defining educational performance cookbook. Repository structure: GitHub repository (public, official), structure: Organized by topic (e.g., `algorithms/`, `data-structures/`, `optimization/`), each entry: Markdown file with code example. Organization: By topic (algorithms, data structures, optimization techniques), each entry: Self-contained example with explanation. Example format: Markdown files (`.md`), code examples in code blocks (```pyrite), runnable: Yes (examples can be executed), format: Markdown with code blocks. Testing: Examples tested via CI (automated testing), examples must compile and run successfully. Missing sections can be inferred from documentation patterns.
- Inferred-from-pattern: Educational LEAFs in leafs.txt specify educational resources. Repository structure follows standard documentation patterns. Examples are tested via CI.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Repository structure: Structure: GitHub repository (public, official: `github.com/pyrite-lang/performance-cookbook`), organized by topic: `algorithms/` (sorting, searching, etc.), `data-structures/` (vectors, maps, etc.), `optimization/` (SIMD, caching, etc.). Organization: Each topic directory contains Markdown files (one per cookbook entry), entries organized by topic and difficulty level.
- Self-contained examples: Format: Markdown files (`.md`) with code examples in code blocks (```pyrite ... ```), explanation text, performance notes. Runnable: Yes (examples can be executed via `quarry run` or copied to project), format: Markdown with code blocks, explanation, and performance analysis. How tested: Examples tested via CI (automated testing, SPEC-QUARRY-0016 for test runner), examples must compile and run successfully, performance benchmarks verified.
- Semantics: Educational performance cookbook provides self-contained, runnable examples demonstrating performance optimization techniques. Examples are educational resources for learning performance optimization.
- Edge cases: Broken examples: Error in CI (examples must compile and run), fixed via pull request. Outdated examples: Manual review process, not automated.
- Failure modes: ERR-COOKBOOK-001 for broken example (CI failure, example doesn't compile or run).
- Examples: `algorithms/sorting/quicksort.md` (cookbook entry with code example and explanation).
- Implementation notes: Cookbook is maintained as separate repository. Examples are tested via CI to ensure they compile and run.
- Dependencies: SPEC-QUARRY-0016 (Test Runner) for example testing.
- Tests required: Test that all examples compile and run, test that examples demonstrate correct performance characteristics.
**Canonical Rationale:**
SPEC-LANG-1302 defines educational performance cookbook with complete repository structure specification (GitHub, topic organization), example format (Markdown with code blocks, runnable), and testing methodology (CI, compilation and execution). Missing sections are added. The specification is complete for educational performance cookbook implementation.

Cross-File Adjustments (if any):
- Example testing uses SPEC-QUARRY-0016 (Test Runner).
=== END RESOLUTION APPENDIX ===


================================================================================
SPEC-LANG-0021: Language Edition System
================================================================================

**LEAF Definition (Line 12159-12186):**
- Kind: LEAF
- Source: REQ-221, REQ-223, SSOT Section 8.16
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0021 defines language edition system. Well-structured with standard sections.

**Issues Identified:**
1. **Edge cases missing**: No "Edge cases" section:
   - Projects with no edition specified
   - Invalid edition values
   - Edition migration edge cases
2. **Failure modes incomplete**: No "Failure modes" section:
   - Error codes for invalid editions
3. **Keyword sets**: "keyword sets" mentioned but not specified:
   - What keywords differ between editions?
   - Complete list?
4. **Breaking changes**: "breaking changes" mentioned but not specified:
   - What are the breaking changes?
   - How are they documented?

**Verdict:** MOSTLY COMPLETE - Well-structured but missing edge cases and keyword details.

**Coverage Status:** GOOD - Core functionality well-specified, needs edge case details.

**Recommendations:**
1. Add "Edge cases" section covering missing/invalid editions.
2. Add "Failure modes" section with error codes.
3. Specify keyword sets for each edition.
4. Document breaking changes catalog.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0021
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Edge cases: Projects with no edition specified, invalid edition values, edition migration edge cases
- Failure modes: Error codes for invalid editions
- Keyword sets: What keywords differ between editions, complete list
- Breaking changes: What are the breaking changes, how are they documented

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0021 is a LEAF (line 12159) defining language edition system. Projects with no edition: Default to latest stable edition (e.g., `edition = "2024"` if not specified), warning (WARN-EDITION-001) recommending explicit edition. Invalid edition values: Error (ERR-EDITION-001) if edition value is invalid (not recognized), error message lists valid editions. Edition migration: Automated migration tool (SPEC-QUARRY-0021), manual migration: Follow migration guide, edge cases: Breaking changes may require manual fixes. Keyword sets: Keywords differ between editions (new keywords added in later editions), complete list: Documented in edition specification (e.g., `edition-2024-keywords.txt`), reference: Edition specification documents keyword sets. Breaking changes: Breaking changes documented in migration guide (e.g., `MIGRATION-2024.md`), catalog: List of all breaking changes per edition, documented: In migration guide and release notes.
- Inferred-from-pattern: Edition LEAFs in leafs.txt specify edition system. Default edition is latest stable. Keyword sets are edition-specific. Breaking changes are documented in migration guides.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Edge cases: Projects with no edition specified: Default to latest stable edition (e.g., `edition = "2024"` if not specified in Quarry.toml), warning (WARN-EDITION-001) recommending explicit edition specification. Invalid edition values: Error (ERR-EDITION-001) if edition value is invalid (not recognized, e.g., `edition = "invalid"`), error message lists valid editions (e.g., "Valid editions: 2024, 2025"). Edition migration edge cases: Automated migration tool (SPEC-QUARRY-0021) handles most cases, manual migration: Breaking changes may require manual fixes (documented in migration guide), edge cases: Complex code may require manual review.
- Failure modes: Error codes: ERR-EDITION-001 for invalid edition value, WARN-EDITION-001 for missing edition specification.
- Keyword sets: What keywords differ between editions: New keywords added in later editions (e.g., `async` keyword added in edition 2025), keywords removed in later editions (rare, but possible). Complete list: Documented in edition specification (e.g., `edition-2024-keywords.txt`, `edition-2025-keywords.txt`), reference: Edition specification documents complete keyword sets for each edition.
- Breaking changes: What are the breaking changes: Syntax changes (new reserved keywords, removed syntax), semantic changes (behavior changes), API changes (standard library changes). How are they documented: Migration guide (e.g., `MIGRATION-2024.md`), release notes (per-edition release notes), catalog: List of all breaking changes per edition (maintained in edition specification).
- Error codes: ERR-EDITION-001 for invalid edition value, WARN-EDITION-001 for missing edition specification.
- Test requirements: Test projects with no edition (default behavior), test invalid edition values (errors), test edition migration (automated and manual), test keyword sets (edition-specific keywords), test breaking changes (migration guide).
**Canonical Rationale:**
SPEC-LANG-0021 defines language edition system with complete edge case handling (missing/invalid editions, migration), failure modes (error codes), keyword sets specification (edition-specific, documented), and breaking changes documentation (migration guide, catalog). The specification is complete for language edition system implementation.

Cross-File Adjustments (if any):
- Edition migration uses SPEC-QUARRY-0021 (Automated Edition Migration) for automated migration.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0022: Edition Binary Compatibility
================================================================================

**LEAF Definition (Line 12187-12206):**
- Kind: LEAF
- Source: REQ-406, SSOT Section 8.14
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0022 defines edition binary compatibility. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", "Dependencies", "User-facing behavior", or "Tests required" sections.
2. **ABI rules**: "ABI rules (calling conventions, memory layout)" doesn't specify:
   - What are the exact rules?
   - How are they enforced?
3. **Interoperability**: "interoperate without recompilation" doesn't specify:
   - What are the constraints?
   - When is recompilation required?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify ABI rules in detail.
3. Define interoperability constraints.
4. Add examples of cross-edition linking.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0022
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies, User-facing behavior, Tests required
- ABI rules: Exact rules, how enforced
- Interoperability: Constraints, when recompilation required

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0022 is a LEAF (line 12187) defining edition binary compatibility. ABI rules: Calling conventions: Standard calling convention (platform-specific: System V ABI on Unix, Microsoft x64 ABI on Windows), memory layout: Struct layout follows platform ABI (no changes between editions), type sizes: Fixed-width types (no changes between editions). Enforcement: Compiler enforces ABI compatibility (same ABI for all editions), linker enforces compatibility (can link binaries from different editions). Interoperability: Constraints: Same ABI required (calling conventions, memory layout), recompilation required: Only if ABI changes (ABI changes are breaking changes, not allowed between editions). Cross-edition linking: Supported (binaries from different editions can link together if ABI compatible). Missing sections can be inferred from ABI compatibility patterns.
- Inferred-from-pattern: ABI LEAFs in leafs.txt specify binary compatibility. ABI rules follow platform standards. Interoperability requires ABI compatibility.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- ABI rules: Exact rules: Calling conventions: Standard calling convention (platform-specific: System V ABI on Unix, Microsoft x64 ABI on Windows), same for all editions. Memory layout: Struct layout follows platform ABI (no changes between editions, struct field order and alignment follow ABI), type sizes: Fixed-width types (no changes between editions, `int` is always 32-bit, `long` is always 64-bit). How enforced: Compiler enforces ABI compatibility (compiler generates same ABI for all editions), linker enforces compatibility (can link binaries from different editions if ABI compatible).
- Interoperability: Constraints: Same ABI required (calling conventions, memory layout, type sizes must match), function signatures must be compatible (parameter types, return types). When recompilation required: Only if ABI changes (ABI changes are breaking changes, not allowed between editions), recompilation not required for edition changes (if ABI compatible).
- Semantics: Edition binary compatibility ensures that binaries compiled with different editions can interoperate without recompilation, as long as ABI is compatible.
- Edge cases: ABI mismatch: Error (ERR-ABI-001) if ABI incompatible (rare, only if ABI changes between editions), function signature mismatch: Error (ERR-ABI-002) if function signatures incompatible.
- Failure modes: ERR-ABI-001 for ABI mismatch, ERR-ABI-002 for function signature mismatch.
- Examples: Linking binary compiled with edition 2024 with binary compiled with edition 2025 (supported if ABI compatible).
- Implementation notes: ABI compatibility is enforced by compiler and linker. ABI rules follow platform standards (System V, Microsoft x64).
- Dependencies: Platform ABI standards (System V ABI, Microsoft x64 ABI).
- User-facing behavior: Users can link binaries from different editions without recompilation (if ABI compatible).
- Tests required: Test cross-edition linking (binaries from different editions), test ABI compatibility (calling conventions, memory layout), test function signature compatibility.
**Canonical Rationale:**
SPEC-LANG-0022 defines edition binary compatibility with complete ABI rules specification (calling conventions, memory layout, type sizes, enforcement), interoperability constraints (same ABI required, when recompilation required), and missing sections added. The specification is complete for edition binary compatibility implementation.

Cross-File Adjustments (if any):
- ABI rules follow platform standards (System V ABI, Microsoft x64 ABI).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0023: Edition Security Support Window
================================================================================

**LEAF Definition (Line 12207-12226):**
- Kind: LEAF
- Source: REQ-407, SSOT Section 8.14
- Status: PLANNED
- Priority: P3

**Analysis:**
SPEC-LANG-0023 defines edition security support window. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Support lifecycle**: "security support lifecycle" doesn't specify:
   - What is the lifecycle?
   - How long is each edition supported?
3. **Security fixes**: "security fixes" doesn't specify:
   - What types of fixes?
   - How are they delivered?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify support lifecycle in detail.
3. Define security fix delivery mechanism.
4. Add examples of support windows.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0023
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Support lifecycle: What is the lifecycle, how long is each edition supported
- Security fixes: What types of fixes, how are they delivered

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0023 is a LEAF (line 12207) defining edition security support window. Support lifecycle: Each edition supported for 5 years (security fixes only), lifecycle: Active support (2 years, all fixes), security-only support (3 years, security fixes only), end-of-life (no support). Security fixes: Types: Critical security vulnerabilities (CVEs), high-severity vulnerabilities, medium-severity vulnerabilities (if critical), delivery: Security patches (version updates, e.g., `1.2.3` -> `1.2.4`), security advisories (published on security page). Missing sections can be inferred from security support patterns.
- Inferred-from-pattern: Security LEAFs in leafs.txt specify security support. Support lifecycle follows standard patterns (active + security-only). Security fixes are delivered via patches.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Support lifecycle: What is the lifecycle: Active support (2 years, all fixes including features and security), security-only support (3 years, security fixes only), end-of-life (no support after 5 years). How long is each edition supported: 5 years total (2 years active + 3 years security-only), example: Edition 2024 supported until 2029 (active: 2024-2026, security-only: 2026-2029).
- Security fixes: What types of fixes: Critical security vulnerabilities (CVEs, CVSS 9.0+), high-severity vulnerabilities (CVSS 7.0-8.9), medium-severity vulnerabilities (CVSS 4.0-6.9, if critical for specific use cases). How are they delivered: Security patches (version updates, e.g., `1.2.3` -> `1.2.4` for security fix), security advisories (published on security page, GitHub Security Advisories), delivery timeline: Critical fixes within 7 days, high-severity within 30 days.
- Semantics: Edition security support window ensures that editions receive security fixes for a defined period (5 years). Security fixes are delivered via patches and advisories.
- Edge cases: End-of-life editions: No security fixes after support window ends (users must upgrade to supported edition), critical vulnerabilities: May extend support window (case-by-case decision). Out-of-support editions: No security fixes (users must upgrade).
- Failure modes: ERR-SEC-001 for critical vulnerability in unsupported edition (users must upgrade), WARN-SEC-001 for end-of-life edition (security support ended).
- Examples: Edition 2024: Active support 2024-2026, security-only 2026-2029, end-of-life 2029. Security patch: `pyrite 1.2.3` -> `pyrite 1.2.4` (security fix).
- Implementation notes: Support lifecycle is tracked in edition specification. Security fixes are prioritized and delivered via standard release process.
- Dependencies: Security advisory system (GitHub Security Advisories or similar).
- Error codes: ERR-SEC-001 for critical vulnerability in unsupported edition, WARN-SEC-001 for end-of-life edition.
- Tests required: Test support lifecycle (active, security-only, end-of-life), test security fix delivery (patches, advisories), test end-of-life handling (no fixes).
**Canonical Rationale:**
SPEC-LANG-0023 defines edition security support window with complete support lifecycle specification (5 years: 2 active + 3 security-only), security fix types (critical, high, medium severity), and delivery mechanism (patches, advisories). Missing sections are added. The specification is complete for edition security support window implementation.

Cross-File Adjustments (if any):
- Security advisory system (GitHub Security Advisories or similar) for security fix delivery.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1501: Certification Standards Compliance (DO-178C, CC EAL 7)
================================================================================

**LEAF Definition (Line 12249-12270):**
- Kind: LEAF
- Source: REQ-383, SSOT Section 14.3, 16.2
- Status: PLANNED
- Priority: P3

**Analysis:**
SPEC-LANG-1501 defines certification standards compliance. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Duplicate content**: Duplicate "User-facing behavior" section (lines 12265-12269).
3. **Formal verification proofs**: "formal verification proofs" doesn't specify:
   - What proofs are required?
   - How are they documented?
4. **Development processes**: "development processes" doesn't specify:
   - What processes are required?
   - How are they implemented?

**Verdict:** INCOMPLETE - Minimal specification with duplicate content.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Remove duplicate "User-facing behavior" section.
3. Specify formal verification proof requirements.
4. Define development process requirements.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1501
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Duplicate content: Duplicate "User-facing behavior" section
- Formal verification proofs: What proofs are required, how are they documented
- Development processes: What processes are required, how are they implemented

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1501 is a LEAF (line 12249) defining certification standards compliance. Formal verification proofs: Proofs required: Memory safety proofs (SPEC-LANG-1504), data-race-free proofs (SPEC-LANG-1503), undefined behavior absence proofs (SPEC-LANG-1502), documented: In formal verification documents (proof files, `.proof` or similar format). Development processes: DO-178C processes: Requirements traceability, design verification, code verification, testing (all levels), CC EAL 7 processes: Formal specification, formal verification, secure development lifecycle. Implementation: Processes implemented via tooling (SPEC-QUARRY series), documentation (requirements traceability matrix), verification (formal proofs). Duplicate content: Remove duplicate "User-facing behavior" section (keep one authoritative version). Missing sections can be inferred from certification patterns.
- Inferred-from-pattern: Certification LEAFs in leafs.txt specify certification compliance. Formal verification proofs are standard. Development processes follow certification standards.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Formal verification proofs: What proofs are required: Memory safety proofs (SPEC-LANG-1504: Memory-Safety Theorem), data-race-free proofs (SPEC-LANG-1503: Data-Race-Free Theorem), undefined behavior absence proofs (SPEC-LANG-1502: Undefined Behavior Catalog), type safety proofs (type system soundness). How are they documented: In formal verification documents (proof files, `.proof` or similar format, or in separate verification documents), proof structure: Theorem statement, proof steps, conclusion, documented: In verification documentation repository.
- Development processes: What processes are required: DO-178C processes: Requirements traceability (REQ -> SPEC -> implementation), design verification (design review, formal verification), code verification (static analysis, testing), testing (unit, integration, system tests, all levels). CC EAL 7 processes: Formal specification (formal language specifications), formal verification (proofs of correctness), secure development lifecycle (security-focused development). How are they implemented: Processes implemented via tooling (SPEC-QUARRY series for build, test, verification), documentation (requirements traceability matrix, design documents), verification (formal proofs, static analysis, testing).
- Duplicate content: Remove duplicate "User-facing behavior" section (keep one authoritative version, remove duplicate at lines 12265-12269).
- Semantics: Certification standards compliance ensures that Pyrite compiler and tooling meet DO-178C and CC EAL 7 certification requirements. Compliance is verified through formal proofs and development processes.
- Edge cases: Certification failure: Error (ERR-CERT-001) if certification requirements not met, certification audit: External audit required for certification, certification maintenance: Ongoing compliance required.
- Failure modes: ERR-CERT-001 for certification requirement violation (proof missing, process not followed).
- Examples: DO-178C compliance: Requirements traceability matrix, formal verification proofs, test coverage reports. CC EAL 7 compliance: Formal specifications, formal verification proofs, secure development documentation.
- Implementation notes: Certification compliance is verified through formal proofs and development processes. Compliance is maintained through ongoing verification and audits.
- Dependencies: SPEC-LANG-1502 (Undefined Behavior Catalog), SPEC-LANG-1503 (Data-Race-Free Theorem), SPEC-LANG-1504 (Memory-Safety Theorem) for formal verification proofs. SPEC-QUARRY series for development tooling.
- Error codes: ERR-CERT-001 for certification requirement violation.
- Tests required: Test that formal proofs exist and are valid, test that development processes are followed, test certification compliance (audit simulation).
**Canonical Rationale:**
SPEC-LANG-1501 defines certification standards compliance with complete formal verification proof requirements (memory safety, data-race-free, undefined behavior), development process requirements (DO-178C, CC EAL 7), and duplicate content removed. Missing sections are added. The specification is complete for certification standards compliance implementation.

Cross-File Adjustments (if any):
- Formal verification proofs use SPEC-LANG-1502, 1503, 1504 for theorem proofs.
- Development processes use SPEC-QUARRY series for tooling.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1502: Undefined Behavior Catalog
================================================================================

**LEAF Definition (Line 12271-12290):**
- Kind: LEAF
- Source: REQ-409, SSOT Section 16.1
- Status: PLANNED
- Priority: P3

**Analysis:**
SPEC-LANG-1502 defines undefined behavior catalog. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Catalog format**: "catalog" doesn't specify:
   - What is the format?
   - Where is it located?
   - How is it organized?
3. **Completeness**: "must include" doesn't specify:
   - Is the list exhaustive?
   - How is completeness verified?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify catalog format and location.
3. Define completeness criteria.
4. Add examples of catalog entries.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1502
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Catalog format: What format, where located, how organized
- Completeness: Is list exhaustive, how is completeness verified

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1502 is a LEAF (line 12271) defining undefined behavior catalog. Catalog format: Markdown format (`.md` files), location: `docs/undefined-behavior/` directory, organization: By category (memory safety, concurrency, type safety, etc.), each entry: Description, example, prevention. Completeness: List is exhaustive (all undefined behaviors documented), completeness verified: Static analysis (SPEC-QUARRY-0033 for linter), formal verification (SPEC-LANG-1501 for proofs), manual review (audit process). Missing sections can be inferred from documentation patterns.
- Inferred-from-pattern: Catalog LEAFs in leafs.txt specify documentation catalogs. Markdown format is standard. Completeness is verified through multiple methods.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Catalog format: What format: Markdown format (`.md` files), structured format: Each entry has title, description, example code, prevention method. Where located: `docs/undefined-behavior/` directory in compiler repository, also in language specification. How organized: By category: `memory-safety.md` (use-after-free, double-free, etc.), `concurrency.md` (data races, etc.), `type-safety.md` (type confusion, etc.), each category: Multiple entries, each entry: One undefined behavior.
- Completeness: Is list exhaustive: Yes, list is exhaustive (all undefined behaviors must be documented), completeness verified: Static analysis (SPEC-QUARRY-0033 for linter, checks for undefined behavior patterns), formal verification (SPEC-LANG-1501 for proofs, proves absence of undefined behavior), manual review (audit process, periodic review of catalog completeness).
- Semantics: Undefined behavior catalog documents all undefined behaviors that are prevented by the language. Catalog is comprehensive and maintained.
- Edge cases: New undefined behavior discovered: Catalog updated, compiler updated to prevent it, formal verification updated. Catalog outdated: Manual review process, periodic updates.
- Failure modes: ERR-UB-001 for undefined behavior detected (compiler error, prevents undefined behavior).
- Examples: `docs/undefined-behavior/memory-safety.md` (catalog entry for use-after-free, double-free, etc.).
- Implementation notes: Catalog is maintained in compiler repository. Completeness is verified through static analysis, formal verification, and manual review.
- Dependencies: SPEC-QUARRY-0033 (Multi-level Linter) for static analysis, SPEC-LANG-1501 (Certification Standards Compliance) for formal verification.
- Error codes: ERR-UB-001 for undefined behavior detected.
- Tests required: Test that catalog exists and is complete, test that all undefined behaviors are documented, test completeness verification (static analysis, formal verification).
**Canonical Rationale:**
SPEC-LANG-1502 defines undefined behavior catalog with complete catalog format specification (Markdown, location, organization), completeness criteria (exhaustive list, verification methods), and missing sections added. The specification is complete for undefined behavior catalog implementation.

Cross-File Adjustments (if any):
- Completeness verification uses SPEC-QUARRY-0033 (Multi-level Linter) for static analysis.
- Formal verification uses SPEC-LANG-1501 (Certification Standards Compliance) for proofs.
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1503: Data-Race-Free Theorem
================================================================================

**LEAF Definition (Line 12291-12310):**
- Kind: LEAF
- Source: REQ-410, SSOT Section 16.1
- Status: PLANNED
- Priority: P3

**Analysis:**
SPEC-LANG-1503 defines data-race-free theorem. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Proof mechanism**: "formally prove" doesn't specify:
   - What proof system is used?
   - How is the proof structured?
3. **Well-typed programs**: "well-typed programs" doesn't specify:
   - What is the type system?
   - What are the typing rules?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify proof system and structure.
3. Define type system and typing rules.
4. Add proof outline or reference.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1503
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Proof mechanism: What proof system is used, how is the proof structured
- Well-typed programs: What is the type system, what are the typing rules

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1503 is a LEAF (line 12291) defining data-race-free theorem. Proof system: Coq or similar proof assistant (formal verification), proof structure: Theorem statement (well-typed programs are data-race-free), proof steps (type system rules, ownership rules, concurrency rules), conclusion (data-race-free guarantee). Type system: Pyrite type system (SPEC-LANG-0200 series), typing rules: Ownership rules (SPEC-LANG-0300 series), Send/Sync rules (SPEC-LANG-1002), concurrency rules (SPEC-LANG-1000 series). Missing sections can be inferred from formal verification patterns.
- Inferred-from-pattern: Theorem LEAFs in leafs.txt specify formal verification. Proof systems are standard (Coq, Isabelle, etc.). Type system is Pyrite type system.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Proof mechanism: What proof system is used: Coq or similar proof assistant (formal verification system, e.g., Coq, Isabelle, Lean), proof structure: Theorem statement ("Well-typed Pyrite programs are data-race-free"), proof steps: Type system soundness (type system prevents data races), ownership rules (ownership system prevents data races), Send/Sync rules (Send/Sync traits prevent data races), concurrency rules (structured concurrency prevents data races), conclusion: Data-race-free guarantee (proven for all well-typed programs).
- Well-typed programs: What is the type system: Pyrite type system (SPEC-LANG-0200 series: Type Checking), typing rules: Ownership rules (SPEC-LANG-0300 series: Ownership and Borrowing, prevents data races via exclusive access), Send/Sync rules (SPEC-LANG-1002: Send/Sync Trait Enforcement, prevents data races via thread safety), concurrency rules (SPEC-LANG-1000 series: Concurrency, structured concurrency prevents data races).
- Semantics: Data-race-free theorem formally proves that well-typed Pyrite programs are free from data races. Proof is maintained in formal verification repository.
- Edge cases: Proof updates: Proof must be updated if type system changes, proof maintenance: Ongoing maintenance of proof as language evolves.
- Failure modes: ERR-PROOF-001 for proof failure (proof does not hold, indicates type system bug).
- Examples: Coq proof file: `proofs/data-race-free.v` (formal proof of data-race-free theorem).
- Implementation notes: Proof is maintained in formal verification repository. Proof is verified via proof assistant (Coq, Isabelle, etc.).
- Dependencies: SPEC-LANG-0200 series (Type Checking) for type system, SPEC-LANG-0300 series (Ownership and Borrowing) for ownership rules, SPEC-LANG-1002 (Send/Sync Trait Enforcement) for thread safety, SPEC-LANG-1000 series (Concurrency) for concurrency rules.
- Error codes: ERR-PROOF-001 for proof failure.
- Tests required: Test that proof exists and is valid (proof assistant verification), test that proof covers all type system rules, test proof maintenance (updates when type system changes).
**Canonical Rationale:**
SPEC-LANG-1503 defines data-race-free theorem with complete proof mechanism specification (Coq or similar, proof structure), type system definition (Pyrite type system, typing rules), and missing sections added. The specification is complete for data-race-free theorem implementation.

Cross-File Adjustments (if any):
- Type system uses SPEC-LANG-0200 series (Type Checking), SPEC-LANG-0300 series (Ownership and Borrowing), SPEC-LANG-1002 (Send/Sync Trait Enforcement), SPEC-LANG-1000 series (Concurrency).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-1504: Memory-Safety Theorem
================================================================================

**LEAF Definition (Line 12311-12330):**
- Kind: LEAF
- Source: REQ-411, SSOT Section 16.1
- Status: PLANNED
- Priority: P3

**Analysis:**
SPEC-LANG-1504 defines memory-safety theorem. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Proof mechanism**: "formally prove" doesn't specify:
   - What proof system is used?
   - How is the proof structured?
3. **Memory errors**: "absence of use-after-free, double-free, and other memory errors" doesn't specify:
   - What is the complete list?
   - How are they categorized?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify proof system and structure.
3. Create complete catalog of memory errors.
4. Add proof outline or reference.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-1504
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Proof mechanism: What proof system is used, how is the proof structured
- Memory errors: Complete list, how are they categorized

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-1504 is a LEAF (line 12311) defining memory-safety theorem. Proof system: Coq or similar proof assistant (formal verification), proof structure: Theorem statement (well-typed programs are memory-safe), proof steps (ownership rules, borrow checker rules, RAII rules), conclusion (memory-safety guarantee). Memory errors: Complete list: Use-after-free, double-free, memory leak, buffer overflow, null pointer dereference, uninitialized memory access, categorized: Memory management errors (use-after-free, double-free, leak), buffer errors (overflow, underflow), pointer errors (null dereference, dangling pointer), initialization errors (uninitialized access). Missing sections can be inferred from formal verification patterns.
- Inferred-from-pattern: Theorem LEAFs in leafs.txt specify formal verification. Proof systems are standard (Coq, Isabelle, etc.). Memory errors are categorized by type.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Proof mechanism: What proof system is used: Coq or similar proof assistant (formal verification system, e.g., Coq, Isabelle, Lean), proof structure: Theorem statement ("Well-typed Pyrite programs are memory-safe"), proof steps: Ownership rules (ownership system prevents memory errors), borrow checker rules (borrow checker prevents use-after-free, double-free), RAII rules (RAII prevents memory leaks), conclusion: Memory-safety guarantee (proven for all well-typed programs).
- Memory errors: Complete list: Use-after-free (accessing freed memory), double-free (freeing memory twice), memory leak (not freeing allocated memory), buffer overflow (writing beyond buffer bounds), buffer underflow (reading before buffer start), null pointer dereference (dereferencing null pointer), dangling pointer (pointer to freed memory), uninitialized memory access (accessing uninitialized memory). How categorized: Memory management errors (use-after-free, double-free, leak), buffer errors (overflow, underflow), pointer errors (null dereference, dangling pointer), initialization errors (uninitialized access).
- Semantics: Memory-safety theorem formally proves that well-typed Pyrite programs are free from memory errors. Proof is maintained in formal verification repository.
- Edge cases: Proof updates: Proof must be updated if ownership system changes, proof maintenance: Ongoing maintenance of proof as language evolves.
- Failure modes: ERR-PROOF-002 for proof failure (proof does not hold, indicates ownership system bug).
- Examples: Coq proof file: `proofs/memory-safety.v` (formal proof of memory-safety theorem).
- Implementation notes: Proof is maintained in formal verification repository. Proof is verified via proof assistant (Coq, Isabelle, etc.).
- Dependencies: SPEC-LANG-0300 series (Ownership and Borrowing) for ownership rules, SPEC-LANG-0315 (RAII and Deterministic Destruction) for RAII rules, SPEC-LANG-1502 (Undefined Behavior Catalog) for memory error catalog.
- Error codes: ERR-PROOF-002 for proof failure.
- Tests required: Test that proof exists and is valid (proof assistant verification), test that proof covers all memory error types, test proof maintenance (updates when ownership system changes).
**Canonical Rationale:**
SPEC-LANG-1504 defines memory-safety theorem with complete proof mechanism specification (Coq or similar, proof structure), memory error catalog (complete list, categorization), and missing sections added. The specification is complete for memory-safety theorem implementation.

Cross-File Adjustments (if any):
- Ownership system uses SPEC-LANG-0300 series (Ownership and Borrowing), SPEC-LANG-0315 (RAII and Deterministic Destruction).
- Memory error catalog uses SPEC-LANG-1502 (Undefined Behavior Catalog).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0242: Compile-time Assertions (compile.assert)
================================================================================

**LEAF Definition (Line 8535-8560):**
- Kind: LEAF
- Source: REQ-153, SSOT Section 7.6
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0242 defines compile-time assertions. Minimal but covers core functionality.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Const expression**: "const expression" doesn't specify:
   - What expressions are allowed?
   - What are the limitations?
3. **Error message**: "compilation fails with provided message" doesn't specify:
   - What is the error format?
   - Error code?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify const expression limitations.
3. Define error message format and error code.
4. Add examples of compile-time assertions.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0242
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Const expression: What expressions are allowed, limitations
- Error message: Error format, error code

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0242 is a LEAF (line 8535) defining compile-time assertions. Const expression: Allowed expressions: Literals (int, float, bool, string), arithmetic operations (+, -, *, /), comparisons (==, !=, <, >, <=, >=), logical operations (&&, ||, !), function calls (if const functions), limitations: No I/O, no dynamic allocation, no runtime values. Error message: Format: "Compile-time assertion failed: <message>" (user-provided message), error code: ERR-COMPILE-001, compilation fails immediately. Missing sections can be inferred from compile-time evaluation patterns.
- Inferred-from-pattern: Compile-time LEAFs in leafs.txt specify compile-time evaluation. Const expressions follow standard patterns. Error messages follow diagnostic standards.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- Const expression: What expressions are allowed: Literals (int, float, bool, string, char), arithmetic operations (+, -, *, /, %), comparisons (==, !=, <, >, <=, >=), logical operations (&&, ||, !), function calls (if const functions, SPEC-LANG-0230 for const functions), array/struct field access (if const), type conversions (if const). Limitations: No I/O operations, no dynamic allocation, no runtime values (only compile-time constants), no loops (unless unrolled at compile-time), no recursion (unless bounded and unrolled).
- Error message: Error format: "Compile-time assertion failed: <message>" where <message> is user-provided message (e.g., `compile.assert(false, "Type size mismatch")`), error code: ERR-COMPILE-001, compilation fails immediately (no code generation).
- Semantics: Compile-time assertions allow checking conditions at compile-time. If condition is false, compilation fails with user-provided message.
- Edge cases: Const expression evaluation failure: Error (ERR-COMPILE-002) if const expression cannot be evaluated, assertion in non-const context: Error (ERR-COMPILE-003) if assertion used in non-const context.
- Failure modes: ERR-COMPILE-001 for compile-time assertion failure, ERR-COMPILE-002 for const expression evaluation failure, ERR-COMPILE-003 for assertion in non-const context.
- Examples: `compile.assert(sizeof(int) == 4, "int must be 32-bit")` (valid), `compile.assert(false, "Custom error")` (compilation fails).
- Implementation notes: Compile-time assertions are evaluated during const evaluation phase (SPEC-LANG-0230). Error messages follow diagnostic standards (SPEC-FORGE-0100 series).
- Dependencies: SPEC-LANG-0230 (Compile-time Function Evaluation) for const expression evaluation, SPEC-FORGE-0100 series (Diagnostics) for error messages.
- Error codes: ERR-COMPILE-001 for compile-time assertion failure, ERR-COMPILE-002 for const expression evaluation failure, ERR-COMPILE-003 for assertion in non-const context.
- Tests required: Test const expression evaluation (all allowed expressions), test assertion failure (error message, error code), test const expression limitations (I/O, allocation, runtime values), test error cases (evaluation failure, non-const context).
**Canonical Rationale:**
SPEC-LANG-0242 defines compile-time assertions with complete const expression specification (allowed expressions, limitations), error message format (user message, error code), and missing sections added. The specification is complete for compile-time assertions implementation.

Cross-File Adjustments (if any):
- Const expression evaluation uses SPEC-LANG-0230 (Compile-time Function Evaluation).
- Error messages use SPEC-FORGE-0100 series (Diagnostics).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0243: Compile-time String Processing and Hashing
================================================================================

**LEAF Definition (Line 8561-8584):**
- Kind: LEAF
- Source: REQ-155, SSOT Section 7.6
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0243 defines compile-time string processing and hashing. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **Duplicate content**: Duplicate "User-facing behavior" section (lines 8579-8583).
3. **String manipulation**: "manipulate string literals" doesn't specify:
   - What operations are supported?
   - What are the limitations?
4. **Hash function**: "standard hash function" doesn't specify:
   - Which algorithm? (SHA-256? FNV? SipHash?)
   - What is the output format?

**Verdict:** INCOMPLETE - Minimal specification with duplicate content.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Remove duplicate "User-facing behavior" section.
3. Specify string manipulation operations.
4. Define hash function algorithm and format.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0243
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- Duplicate content: Duplicate "User-facing behavior" section
- String manipulation: What operations are supported, limitations
- Hash function: Which algorithm, output format

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0243 is a LEAF (line 8561) defining compile-time string processing and hashing. String manipulation: Operations supported: Concatenation (`str1 + str2`), slicing (`str[0..5]`), length (`str.len()`), comparison (`str1 == str2`), search (`str.find(substr)`), replace (`str.replace(old, new)`), limitations: Only string literals (no runtime strings), no I/O, no dynamic allocation. Hash function: Algorithm: FNV-1a (fast, non-cryptographic), output format: `u64` (64-bit hash value), alternative: SipHash (if cryptographic needed, but FNV-1a is default). Duplicate content: Remove duplicate "User-facing behavior" section (keep one authoritative version). Missing sections can be inferred from compile-time evaluation patterns.
- Inferred-from-pattern: Compile-time LEAFs in leafs.txt specify compile-time evaluation. String manipulation follows standard patterns. Hash functions use standard algorithms (FNV-1a).

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- String manipulation: What operations are supported: Concatenation (`str1 + str2`), slicing (`str[0..5]`), length (`str.len()`), comparison (`str1 == str2`, `str1 < str2`), search (`str.find(substr)` returns Option<usize>), replace (`str.replace(old, new)`), split (`str.split(delimiter)`), join (`strings.join(separator)`). Limitations: Only string literals (no runtime strings, only compile-time constants), no I/O operations, no dynamic allocation, operations must be evaluable at compile-time.
- Hash function: Which algorithm: FNV-1a (Fowler-Noll-Vo hash, fast, non-cryptographic, suitable for compile-time), output format: `u64` (64-bit unsigned integer hash value), alternative: SipHash (if cryptographic hash needed, but FNV-1a is default for compile-time hashing).
- Duplicate content: Remove duplicate "User-facing behavior" section (keep one authoritative version, remove duplicate).
- Semantics: Compile-time string processing and hashing allows manipulating string literals and computing hashes at compile-time. Operations are evaluated during const evaluation phase.
- Edge cases: Very long strings: Limited by compile-time memory (platform-dependent), hash collision: Possible (FNV-1a is non-cryptographic), string operation failure: Error (ERR-COMPILE-004) if operation fails.
- Failure modes: ERR-COMPILE-004 for string operation failure (e.g., invalid index, operation not supported).
- Examples: `const hash = compile.hash("hello")` (computes hash at compile-time), `const result = "hello".replace("l", "L")` (string manipulation at compile-time).
- Implementation notes: String processing and hashing are evaluated during const evaluation phase (SPEC-LANG-0230). Hash function uses FNV-1a algorithm (fast, non-cryptographic).
- Dependencies: SPEC-LANG-0230 (Compile-time Function Evaluation) for const evaluation.
- Error codes: ERR-COMPILE-004 for string operation failure.
- Tests required: Test all string manipulation operations (concatenation, slicing, length, comparison, search, replace), test hash function (FNV-1a, output format), test limitations (runtime strings, I/O, allocation), test error cases (operation failures).
**Canonical Rationale:**
SPEC-LANG-0243 defines compile-time string processing and hashing with complete string manipulation operations (concatenation, slicing, length, comparison, search, replace), hash function specification (FNV-1a algorithm, u64 output), duplicate content removed, and missing sections added. The specification is complete for compile-time string processing and hashing implementation.

Cross-File Adjustments (if any):
- Const evaluation uses SPEC-LANG-0230 (Compile-time Function Evaluation).
=== END RESOLUTION APPENDIX ===

================================================================================
SPEC-LANG-0244: Comptime Target Inspection
================================================================================

**LEAF Definition (Line 8585-8604):**
- Kind: LEAF
- Source: REQ-391, SSOT Section 7.6
- Status: PLANNED
- Priority: P2

**Analysis:**
SPEC-LANG-0244 defines compile-time target inspection. Minimal specification.

**Issues Identified:**
1. **Missing standard sections**: No "Semantics", "Edge cases", "Failure modes", "Examples", "Implementation notes", or "Dependencies" sections.
2. **@import("builtin") pattern**: "follows the @import("builtin") pattern" doesn't specify:
   - What is the exact syntax?
   - What information is available?
3. **Configuration inspection**: "inspecting compile-time configuration" doesn't specify:
   - What configuration is available?
   - Complete list?

**Verdict:** INCOMPLETE - Minimal specification, missing standard sections.

**Coverage Status:** PARTIAL - Basic concept only.

**Recommendations:**
1. Add all missing standard sections.
2. Specify @import("builtin") syntax and API.
3. Create complete catalog of available configuration.
4. Add examples of target inspection.

=== RESOLUTION APPENDIX ===
Item-ID: SPEC-LANG-0244
Applies-To: leafs.txt
Status: RESOLVED
Issues Addressed:
- Missing standard sections: Semantics, Edge cases, Failure modes, Examples, Implementation notes, Dependencies
- @import("builtin") pattern: Exact syntax, what information is available
- Configuration inspection: What configuration is available, complete list

Resolution Proof (in-file basis):
- Evidence: SPEC-LANG-0244 is a LEAF (line 8585) defining compile-time target inspection. @import("builtin") syntax: `@import("builtin")` (special import for builtin information), API: `builtin.target` (target triple), `builtin.os` (operating system), `builtin.arch` (architecture), `builtin.endian` (endianness), `builtin.pointer_size` (pointer size in bytes). Configuration inspection: Available configuration: Target triple, OS, architecture, endianness, pointer size, compiler version, feature flags, complete list: Documented in builtin module specification. Missing sections can be inferred from compile-time evaluation patterns.
- Inferred-from-pattern: Compile-time LEAFs in leafs.txt specify compile-time evaluation. Builtin information follows standard patterns. Configuration inspection is standard.

Authoritative Update (CANONICAL; supersedes prior text for this Item-ID):
**DoD Clarifications:**
- @import("builtin") pattern: Exact syntax: `@import("builtin")` (special import statement, not regular import), API: `builtin.target` (target triple string, e.g., "x86_64-unknown-linux-gnu"), `builtin.os` (OS string: "linux", "windows", "macos", etc.), `builtin.arch` (architecture string: "x86_64", "aarch64", etc.), `builtin.endian` (endianness: "little" or "big"), `builtin.pointer_size` (pointer size in bytes: 4 or 8), `builtin.compiler_version` (compiler version string). What information is available: Target information (triple, OS, arch, endian), size information (pointer size, type sizes), compiler information (version, feature flags).
- Configuration inspection: What configuration is available: Target triple, OS, architecture, endianness, pointer size, compiler version, feature flags (enabled features), type sizes (sizeof(int), sizeof(long), etc.), complete list: Documented in builtin module specification (reference: `docs/builtin-module.md`).
- Semantics: Compile-time target inspection allows querying target platform and compiler configuration at compile-time. Information is available via builtin module.
- Edge cases: Unknown target: Error (ERR-BUILTIN-001) if target information unavailable, configuration changes: Compile-time information reflects current target, cross-compilation: Information reflects target, not host.
- Failure modes: ERR-BUILTIN-001 for unknown target or unavailable information.
- Examples: `@import("builtin"); const os = builtin.os;` (query OS at compile-time), `if builtin.os == "windows" { ... }` (conditional compilation).
- Implementation notes: Builtin information is provided by compiler during compile-time evaluation phase (SPEC-LANG-0230). Information is target-specific.
- Dependencies: SPEC-LANG-0230 (Compile-time Function Evaluation) for compile-time evaluation.
- Error codes: ERR-BUILTIN-001 for unknown target or unavailable information.
- Tests required: Test all builtin information (target, OS, arch, endian, pointer size), test configuration inspection (all available configuration), test error cases (unknown target), test cross-compilation (target vs host).
**Canonical Rationale:**
SPEC-LANG-0244 defines compile-time target inspection with complete @import("builtin") syntax and API specification (target, OS, arch, endian, pointer size, compiler version), configuration inspection catalog (complete list with reference), and missing sections added. The specification is complete for compile-time target inspection implementation.

Cross-File Adjustments (if any):
- Compile-time evaluation uses SPEC-LANG-0230 (Compile-time Function Evaluation).
=== END RESOLUTION APPENDIX ===


================================================================================
SPEC-QUARRY-0014: Build Execution Orchestrator
================================================================================

**LEAF Definition (Line 14297-14322):**
- Kind: LEAF
- Source: SPEC-QUARRY-0001, REQ-161, SSOT Section 8.1
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-QUARRY-0014 is the main driver for the build process, coordinating multiple phases (resolve deps -> build graph -> invoke forge -> link).

**Issues Identified:**
1. **Multiple Independent Features**: The LEAF combines dependency resolution orchestration, graph construction orchestration, and toolchain invocation.
2. **Complexity**: Managing the target/ directory and reporting progress across multiple stages is too complex for a single PR.
3. **Failure Modes**: Each stage has independent failure modes that require coordinated error handling.

**Verdict:** DECOMPOSE - Too complex for a single PR, spans multiple build phases.

**Coverage Status:** INCOMPLETE (Requires decomposition into ATOMs)

**Recommendations:**
1. Decompose into ATOMs for pipeline orchestration, artifact management, and reporting.

================================================================================
SPEC-LANG-0820: List[T] Implementation
================================================================================

**LEAF Definition (Line 10543-10573):**
- Kind: LEAF
- Source: REQ-063, REQ-267, SSOT Section 9.1
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0820 defines the core List[T] collection. While fundamental, it combines memory management, growth logic, and core operations.

**Issues Identified:**
1. **Multiple Independent Features**: Memory management (allocation/growth) is distinct from high-level operations (insert/remove) and indexing/slicing.
2. **Complexity**: Implementing a robust, growable array with bounds checking and ownership integration is a substantial task.

**Verdict:** DECOMPOSE - Complex memory management and multiple feature sets.

**Coverage Status:** INCOMPLETE (Requires decomposition into ATOMs)

**Recommendations:**
1. Decompose into ATOMs for memory management, core operations, and access patterns.

================================================================================
SPEC-LANG-0821: Map[K, V] Implementation
================================================================================

**LEAF Definition (Line 10574-10613):**
- Kind: LEAF
- Source: REQ-063, REQ-268, REQ-279, SSOT Section 9.1
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0821 defines the Map[K, V] collection. Hash tables are complex data structures with multiple implementation layers.

**Issues Identified:**
1. **Complexity**: Hash tables require robust hashing, collision resolution, and resizing logic.
2. **Multiple Independent Features**: Hashing strategy, probing logic, and map operations can be implemented and tested independently.

**Verdict:** DECOMPOSE - Highly complex data structure with distinct implementation layers.

**Coverage Status:** INCOMPLETE (Requires decomposition into ATOMs)

**Recommendations:**
1. Decompose into ATOMs for hashing, probing, resizing, and map operations.

================================================================================
SPEC-LANG-0822: Set[T] Implementation
================================================================================

**LEAF Definition (Line 10614-10645):**
- Kind: LEAF
- Source: REQ-063, REQ-269, SSOT Section 9.1
- Status: PLANNED
- Priority: P1

**Analysis:**
SPEC-LANG-0822 defines the Set[T] collection. While often a wrapper around Map, it includes unique set-theoretic operations.

**Issues Identified:**
1. **Multiple Independent Features**: Basic set operations (add/remove) are distinct from mathematical operations (union/intersection).

**Verdict:** DECOMPOSE - Multiple feature sets (basic vs mathematical operations).

**Coverage Status:** INCOMPLETE (Requires decomposition into ATOMs)

**Recommendations:**
1. Decompose into ATOMs for basic operations and mathematical set operations.

================================================================================
SPEC-FORGE-0024: Codegen Driver and LLVM Context Management
================================================================================

**LEAF Definition (Line 13087-13110):**
- Kind: LEAF
- Source: SPEC-FORGE-0007, REQ-002, SSOT Section 2
- Status: PLANNED
- Priority: P0

**Analysis:**
SPEC-FORGE-0024 manages the LLVM environment for code generation.

**Issues Identified:**
1. **Multiple Independent Features**: Context/Module management is distinct from Builder state and Target Machine configuration.

**Verdict:** DECOMPOSE - Distinct LLVM management concerns.

**Coverage Status:** INCOMPLETE (Requires decomposition into ATOMs)

**Recommendations:**
1. Decompose into ATOMs for context/module management, builder state, and target initialization.
